
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model QuoteItem
 * 
 */
export type QuoteItem = $Result.DefaultSelection<Prisma.$QuoteItemPayload>
/**
 * Model PasswordResetOTP
 * 
 */
export type PasswordResetOTP = $Result.DefaultSelection<Prisma.$PasswordResetOTPPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model tenantCurrency
 * 
 */
export type tenantCurrency = $Result.DefaultSelection<Prisma.$tenantCurrencyPayload>
/**
 * Model tenantPaymentTerms
 * 
 */
export type tenantPaymentTerms = $Result.DefaultSelection<Prisma.$tenantPaymentTermsPayload>
/**
 * Model tenantPaymentStatus
 * 
 */
export type tenantPaymentStatus = $Result.DefaultSelection<Prisma.$tenantPaymentStatusPayload>
/**
 * Model tenantQuoteStatus
 * 
 */
export type tenantQuoteStatus = $Result.DefaultSelection<Prisma.$tenantQuoteStatusPayload>
/**
 * Model tenantOrderStatus
 * 
 */
export type tenantOrderStatus = $Result.DefaultSelection<Prisma.$tenantOrderStatusPayload>
/**
 * Model tenantLogisticsStatus
 * 
 */
export type tenantLogisticsStatus = $Result.DefaultSelection<Prisma.$tenantLogisticsStatusPayload>
/**
 * Model tenantFinanceStatus
 * 
 */
export type tenantFinanceStatus = $Result.DefaultSelection<Prisma.$tenantFinanceStatusPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model companyService
 * 
 */
export type companyService = $Result.DefaultSelection<Prisma.$companyServicePayload>
/**
 * Model companyMaterial
 * 
 */
export type companyMaterial = $Result.DefaultSelection<Prisma.$companyMaterialPayload>
/**
 * Model companyFinish
 * 
 */
export type companyFinish = $Result.DefaultSelection<Prisma.$companyFinishPayload>
/**
 * Model CustomerAddress
 * 
 */
export type CustomerAddress = $Result.DefaultSelection<Prisma.$CustomerAddressPayload>
/**
 * Model CustomerTaxInfo
 * 
 */
export type CustomerTaxInfo = $Result.DefaultSelection<Prisma.$CustomerTaxInfoPayload>
/**
 * Model CustomerContact
 * 
 */
export type CustomerContact = $Result.DefaultSelection<Prisma.$CustomerContactPayload>
/**
 * Model CustomerOperationalInfo
 * 
 */
export type CustomerOperationalInfo = $Result.DefaultSelection<Prisma.$CustomerOperationalInfoPayload>
/**
 * Model CustomerNotesAndAttachments
 * 
 */
export type CustomerNotesAndAttachments = $Result.DefaultSelection<Prisma.$CustomerNotesAndAttachmentsPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model VendorContact
 * 
 */
export type VendorContact = $Result.DefaultSelection<Prisma.$VendorContactPayload>
/**
 * Model VendorAddress
 * 
 */
export type VendorAddress = $Result.DefaultSelection<Prisma.$VendorAddressPayload>
/**
 * Model VendorTaxCompliance
 * 
 */
export type VendorTaxCompliance = $Result.DefaultSelection<Prisma.$VendorTaxCompliancePayload>
/**
 * Model VendorFinancial
 * 
 */
export type VendorFinancial = $Result.DefaultSelection<Prisma.$VendorFinancialPayload>
/**
 * Model VendorOperationalSetting
 * 
 */
export type VendorOperationalSetting = $Result.DefaultSelection<Prisma.$VendorOperationalSettingPayload>
/**
 * Model VendorMetadata
 * 
 */
export type VendorMetadata = $Result.DefaultSelection<Prisma.$VendorMetadataPayload>
/**
 * Model company_vendor_capabilities
 * 
 */
export type company_vendor_capabilities = $Result.DefaultSelection<Prisma.$company_vendor_capabilitiesPayload>
/**
 * Model company_vendor_capability_sub_categories
 * 
 */
export type company_vendor_capability_sub_categories = $Result.DefaultSelection<Prisma.$company_vendor_capability_sub_categoriesPayload>
/**
 * Model company_vendor_certifications
 * 
 */
export type company_vendor_certifications = $Result.DefaultSelection<Prisma.$company_vendor_certificationsPayload>
/**
 * Model company_vendor_flags
 * 
 */
export type company_vendor_flags = $Result.DefaultSelection<Prisma.$company_vendor_flagsPayload>
/**
 * Model company_school
 * 
 */
export type company_school = $Result.DefaultSelection<Prisma.$company_schoolPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const QuoteType: {
  Prototype: 'Prototype',
  Production: 'Production'
};

export type QuoteType = (typeof QuoteType)[keyof typeof QuoteType]

}

export type QuoteType = $Enums.QuoteType

export const QuoteType: typeof $Enums.QuoteType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quoteItem`: Exposes CRUD operations for the **QuoteItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteItems
    * const quoteItems = await prisma.quoteItem.findMany()
    * ```
    */
  get quoteItem(): Prisma.QuoteItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetOTP`: Exposes CRUD operations for the **PasswordResetOTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetOTPS
    * const passwordResetOTPS = await prisma.passwordResetOTP.findMany()
    * ```
    */
  get passwordResetOTP(): Prisma.PasswordResetOTPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantCurrency`: Exposes CRUD operations for the **tenantCurrency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantCurrencies
    * const tenantCurrencies = await prisma.tenantCurrency.findMany()
    * ```
    */
  get tenantCurrency(): Prisma.tenantCurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantPaymentTerms`: Exposes CRUD operations for the **tenantPaymentTerms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantPaymentTerms
    * const tenantPaymentTerms = await prisma.tenantPaymentTerms.findMany()
    * ```
    */
  get tenantPaymentTerms(): Prisma.tenantPaymentTermsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantPaymentStatus`: Exposes CRUD operations for the **tenantPaymentStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantPaymentStatuses
    * const tenantPaymentStatuses = await prisma.tenantPaymentStatus.findMany()
    * ```
    */
  get tenantPaymentStatus(): Prisma.tenantPaymentStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantQuoteStatus`: Exposes CRUD operations for the **tenantQuoteStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantQuoteStatuses
    * const tenantQuoteStatuses = await prisma.tenantQuoteStatus.findMany()
    * ```
    */
  get tenantQuoteStatus(): Prisma.tenantQuoteStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantOrderStatus`: Exposes CRUD operations for the **tenantOrderStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantOrderStatuses
    * const tenantOrderStatuses = await prisma.tenantOrderStatus.findMany()
    * ```
    */
  get tenantOrderStatus(): Prisma.tenantOrderStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantLogisticsStatus`: Exposes CRUD operations for the **tenantLogisticsStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantLogisticsStatuses
    * const tenantLogisticsStatuses = await prisma.tenantLogisticsStatus.findMany()
    * ```
    */
  get tenantLogisticsStatus(): Prisma.tenantLogisticsStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantFinanceStatus`: Exposes CRUD operations for the **tenantFinanceStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantFinanceStatuses
    * const tenantFinanceStatuses = await prisma.tenantFinanceStatus.findMany()
    * ```
    */
  get tenantFinanceStatus(): Prisma.tenantFinanceStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyService`: Exposes CRUD operations for the **companyService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyServices
    * const companyServices = await prisma.companyService.findMany()
    * ```
    */
  get companyService(): Prisma.companyServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyMaterial`: Exposes CRUD operations for the **companyMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyMaterials
    * const companyMaterials = await prisma.companyMaterial.findMany()
    * ```
    */
  get companyMaterial(): Prisma.companyMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyFinish`: Exposes CRUD operations for the **companyFinish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyFinishes
    * const companyFinishes = await prisma.companyFinish.findMany()
    * ```
    */
  get companyFinish(): Prisma.companyFinishDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerAddress`: Exposes CRUD operations for the **CustomerAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerAddresses
    * const customerAddresses = await prisma.customerAddress.findMany()
    * ```
    */
  get customerAddress(): Prisma.CustomerAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerTaxInfo`: Exposes CRUD operations for the **CustomerTaxInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerTaxInfos
    * const customerTaxInfos = await prisma.customerTaxInfo.findMany()
    * ```
    */
  get customerTaxInfo(): Prisma.CustomerTaxInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerContact`: Exposes CRUD operations for the **CustomerContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerContacts
    * const customerContacts = await prisma.customerContact.findMany()
    * ```
    */
  get customerContact(): Prisma.CustomerContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerOperationalInfo`: Exposes CRUD operations for the **CustomerOperationalInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerOperationalInfos
    * const customerOperationalInfos = await prisma.customerOperationalInfo.findMany()
    * ```
    */
  get customerOperationalInfo(): Prisma.CustomerOperationalInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerNotesAndAttachments`: Exposes CRUD operations for the **CustomerNotesAndAttachments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerNotesAndAttachments
    * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.findMany()
    * ```
    */
  get customerNotesAndAttachments(): Prisma.CustomerNotesAndAttachmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorContact`: Exposes CRUD operations for the **VendorContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorContacts
    * const vendorContacts = await prisma.vendorContact.findMany()
    * ```
    */
  get vendorContact(): Prisma.VendorContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorAddress`: Exposes CRUD operations for the **VendorAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorAddresses
    * const vendorAddresses = await prisma.vendorAddress.findMany()
    * ```
    */
  get vendorAddress(): Prisma.VendorAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorTaxCompliance`: Exposes CRUD operations for the **VendorTaxCompliance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorTaxCompliances
    * const vendorTaxCompliances = await prisma.vendorTaxCompliance.findMany()
    * ```
    */
  get vendorTaxCompliance(): Prisma.VendorTaxComplianceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorFinancial`: Exposes CRUD operations for the **VendorFinancial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorFinancials
    * const vendorFinancials = await prisma.vendorFinancial.findMany()
    * ```
    */
  get vendorFinancial(): Prisma.VendorFinancialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorOperationalSetting`: Exposes CRUD operations for the **VendorOperationalSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorOperationalSettings
    * const vendorOperationalSettings = await prisma.vendorOperationalSetting.findMany()
    * ```
    */
  get vendorOperationalSetting(): Prisma.VendorOperationalSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorMetadata`: Exposes CRUD operations for the **VendorMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorMetadata
    * const vendorMetadata = await prisma.vendorMetadata.findMany()
    * ```
    */
  get vendorMetadata(): Prisma.VendorMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_vendor_capabilities`: Exposes CRUD operations for the **company_vendor_capabilities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_vendor_capabilities
    * const company_vendor_capabilities = await prisma.company_vendor_capabilities.findMany()
    * ```
    */
  get company_vendor_capabilities(): Prisma.company_vendor_capabilitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_vendor_capability_sub_categories`: Exposes CRUD operations for the **company_vendor_capability_sub_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_vendor_capability_sub_categories
    * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.findMany()
    * ```
    */
  get company_vendor_capability_sub_categories(): Prisma.company_vendor_capability_sub_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_vendor_certifications`: Exposes CRUD operations for the **company_vendor_certifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_vendor_certifications
    * const company_vendor_certifications = await prisma.company_vendor_certifications.findMany()
    * ```
    */
  get company_vendor_certifications(): Prisma.company_vendor_certificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_vendor_flags`: Exposes CRUD operations for the **company_vendor_flags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_vendor_flags
    * const company_vendor_flags = await prisma.company_vendor_flags.findMany()
    * ```
    */
  get company_vendor_flags(): Prisma.company_vendor_flagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_school`: Exposes CRUD operations for the **company_school** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_schools
    * const company_schools = await prisma.company_school.findMany()
    * ```
    */
  get company_school(): Prisma.company_schoolDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Quote: 'Quote',
    QuoteItem: 'QuoteItem',
    PasswordResetOTP: 'PasswordResetOTP',
    PasswordResetToken: 'PasswordResetToken',
    tenantCurrency: 'tenantCurrency',
    tenantPaymentTerms: 'tenantPaymentTerms',
    tenantPaymentStatus: 'tenantPaymentStatus',
    tenantQuoteStatus: 'tenantQuoteStatus',
    tenantOrderStatus: 'tenantOrderStatus',
    tenantLogisticsStatus: 'tenantLogisticsStatus',
    tenantFinanceStatus: 'tenantFinanceStatus',
    Customer: 'Customer',
    companyService: 'companyService',
    companyMaterial: 'companyMaterial',
    companyFinish: 'companyFinish',
    CustomerAddress: 'CustomerAddress',
    CustomerTaxInfo: 'CustomerTaxInfo',
    CustomerContact: 'CustomerContact',
    CustomerOperationalInfo: 'CustomerOperationalInfo',
    CustomerNotesAndAttachments: 'CustomerNotesAndAttachments',
    Vendor: 'Vendor',
    VendorContact: 'VendorContact',
    VendorAddress: 'VendorAddress',
    VendorTaxCompliance: 'VendorTaxCompliance',
    VendorFinancial: 'VendorFinancial',
    VendorOperationalSetting: 'VendorOperationalSetting',
    VendorMetadata: 'VendorMetadata',
    company_vendor_capabilities: 'company_vendor_capabilities',
    company_vendor_capability_sub_categories: 'company_vendor_capability_sub_categories',
    company_vendor_certifications: 'company_vendor_certifications',
    company_vendor_flags: 'company_vendor_flags',
    company_school: 'company_school'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    tenantDb?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "quote" | "quoteItem" | "passwordResetOTP" | "passwordResetToken" | "tenantCurrency" | "tenantPaymentTerms" | "tenantPaymentStatus" | "tenantQuoteStatus" | "tenantOrderStatus" | "tenantLogisticsStatus" | "tenantFinanceStatus" | "customer" | "companyService" | "companyMaterial" | "companyFinish" | "customerAddress" | "customerTaxInfo" | "customerContact" | "customerOperationalInfo" | "customerNotesAndAttachments" | "vendor" | "vendorContact" | "vendorAddress" | "vendorTaxCompliance" | "vendorFinancial" | "vendorOperationalSetting" | "vendorMetadata" | "company_vendor_capabilities" | "company_vendor_capability_sub_categories" | "company_vendor_certifications" | "company_vendor_flags" | "company_school"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      QuoteItem: {
        payload: Prisma.$QuoteItemPayload<ExtArgs>
        fields: Prisma.QuoteItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          findFirst: {
            args: Prisma.QuoteItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          findMany: {
            args: Prisma.QuoteItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          create: {
            args: Prisma.QuoteItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          createMany: {
            args: Prisma.QuoteItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          delete: {
            args: Prisma.QuoteItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          update: {
            args: Prisma.QuoteItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          deleteMany: {
            args: Prisma.QuoteItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          upsert: {
            args: Prisma.QuoteItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          aggregate: {
            args: Prisma.QuoteItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteItem>
          }
          groupBy: {
            args: Prisma.QuoteItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteItemCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetOTP: {
        payload: Prisma.$PasswordResetOTPPayload<ExtArgs>
        fields: Prisma.PasswordResetOTPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetOTPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetOTPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetOTPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetOTPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>
          }
          findMany: {
            args: Prisma.PasswordResetOTPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>[]
          }
          create: {
            args: Prisma.PasswordResetOTPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>
          }
          createMany: {
            args: Prisma.PasswordResetOTPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetOTPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetOTPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>
          }
          update: {
            args: Prisma.PasswordResetOTPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetOTPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetOTPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetOTPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetOTPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetOTPPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetOTPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetOTP>
          }
          groupBy: {
            args: Prisma.PasswordResetOTPGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetOTPGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetOTPCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetOTPCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      tenantCurrency: {
        payload: Prisma.$tenantCurrencyPayload<ExtArgs>
        fields: Prisma.tenantCurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenantCurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenantCurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>
          }
          findFirst: {
            args: Prisma.tenantCurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenantCurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>
          }
          findMany: {
            args: Prisma.tenantCurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>[]
          }
          create: {
            args: Prisma.tenantCurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>
          }
          createMany: {
            args: Prisma.tenantCurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenantCurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>[]
          }
          delete: {
            args: Prisma.tenantCurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>
          }
          update: {
            args: Prisma.tenantCurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>
          }
          deleteMany: {
            args: Prisma.tenantCurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenantCurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tenantCurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>[]
          }
          upsert: {
            args: Prisma.tenantCurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantCurrencyPayload>
          }
          aggregate: {
            args: Prisma.TenantCurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantCurrency>
          }
          groupBy: {
            args: Prisma.tenantCurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantCurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenantCurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCurrencyCountAggregateOutputType> | number
          }
        }
      }
      tenantPaymentTerms: {
        payload: Prisma.$tenantPaymentTermsPayload<ExtArgs>
        fields: Prisma.tenantPaymentTermsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenantPaymentTermsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenantPaymentTermsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>
          }
          findFirst: {
            args: Prisma.tenantPaymentTermsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenantPaymentTermsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>
          }
          findMany: {
            args: Prisma.tenantPaymentTermsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>[]
          }
          create: {
            args: Prisma.tenantPaymentTermsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>
          }
          createMany: {
            args: Prisma.tenantPaymentTermsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenantPaymentTermsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>[]
          }
          delete: {
            args: Prisma.tenantPaymentTermsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>
          }
          update: {
            args: Prisma.tenantPaymentTermsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>
          }
          deleteMany: {
            args: Prisma.tenantPaymentTermsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenantPaymentTermsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tenantPaymentTermsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>[]
          }
          upsert: {
            args: Prisma.tenantPaymentTermsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentTermsPayload>
          }
          aggregate: {
            args: Prisma.TenantPaymentTermsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantPaymentTerms>
          }
          groupBy: {
            args: Prisma.tenantPaymentTermsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantPaymentTermsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenantPaymentTermsCountArgs<ExtArgs>
            result: $Utils.Optional<TenantPaymentTermsCountAggregateOutputType> | number
          }
        }
      }
      tenantPaymentStatus: {
        payload: Prisma.$tenantPaymentStatusPayload<ExtArgs>
        fields: Prisma.tenantPaymentStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenantPaymentStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenantPaymentStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>
          }
          findFirst: {
            args: Prisma.tenantPaymentStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenantPaymentStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>
          }
          findMany: {
            args: Prisma.tenantPaymentStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>[]
          }
          create: {
            args: Prisma.tenantPaymentStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>
          }
          createMany: {
            args: Prisma.tenantPaymentStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenantPaymentStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>[]
          }
          delete: {
            args: Prisma.tenantPaymentStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>
          }
          update: {
            args: Prisma.tenantPaymentStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>
          }
          deleteMany: {
            args: Prisma.tenantPaymentStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenantPaymentStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tenantPaymentStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>[]
          }
          upsert: {
            args: Prisma.tenantPaymentStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantPaymentStatusPayload>
          }
          aggregate: {
            args: Prisma.TenantPaymentStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantPaymentStatus>
          }
          groupBy: {
            args: Prisma.tenantPaymentStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantPaymentStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenantPaymentStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TenantPaymentStatusCountAggregateOutputType> | number
          }
        }
      }
      tenantQuoteStatus: {
        payload: Prisma.$tenantQuoteStatusPayload<ExtArgs>
        fields: Prisma.tenantQuoteStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenantQuoteStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenantQuoteStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>
          }
          findFirst: {
            args: Prisma.tenantQuoteStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenantQuoteStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>
          }
          findMany: {
            args: Prisma.tenantQuoteStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>[]
          }
          create: {
            args: Prisma.tenantQuoteStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>
          }
          createMany: {
            args: Prisma.tenantQuoteStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenantQuoteStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>[]
          }
          delete: {
            args: Prisma.tenantQuoteStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>
          }
          update: {
            args: Prisma.tenantQuoteStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>
          }
          deleteMany: {
            args: Prisma.tenantQuoteStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenantQuoteStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tenantQuoteStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>[]
          }
          upsert: {
            args: Prisma.tenantQuoteStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantQuoteStatusPayload>
          }
          aggregate: {
            args: Prisma.TenantQuoteStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantQuoteStatus>
          }
          groupBy: {
            args: Prisma.tenantQuoteStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantQuoteStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenantQuoteStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TenantQuoteStatusCountAggregateOutputType> | number
          }
        }
      }
      tenantOrderStatus: {
        payload: Prisma.$tenantOrderStatusPayload<ExtArgs>
        fields: Prisma.tenantOrderStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenantOrderStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenantOrderStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>
          }
          findFirst: {
            args: Prisma.tenantOrderStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenantOrderStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>
          }
          findMany: {
            args: Prisma.tenantOrderStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>[]
          }
          create: {
            args: Prisma.tenantOrderStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>
          }
          createMany: {
            args: Prisma.tenantOrderStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenantOrderStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>[]
          }
          delete: {
            args: Prisma.tenantOrderStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>
          }
          update: {
            args: Prisma.tenantOrderStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>
          }
          deleteMany: {
            args: Prisma.tenantOrderStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenantOrderStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tenantOrderStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>[]
          }
          upsert: {
            args: Prisma.tenantOrderStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantOrderStatusPayload>
          }
          aggregate: {
            args: Prisma.TenantOrderStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantOrderStatus>
          }
          groupBy: {
            args: Prisma.tenantOrderStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantOrderStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenantOrderStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TenantOrderStatusCountAggregateOutputType> | number
          }
        }
      }
      tenantLogisticsStatus: {
        payload: Prisma.$tenantLogisticsStatusPayload<ExtArgs>
        fields: Prisma.tenantLogisticsStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenantLogisticsStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenantLogisticsStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>
          }
          findFirst: {
            args: Prisma.tenantLogisticsStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenantLogisticsStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>
          }
          findMany: {
            args: Prisma.tenantLogisticsStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>[]
          }
          create: {
            args: Prisma.tenantLogisticsStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>
          }
          createMany: {
            args: Prisma.tenantLogisticsStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenantLogisticsStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>[]
          }
          delete: {
            args: Prisma.tenantLogisticsStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>
          }
          update: {
            args: Prisma.tenantLogisticsStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>
          }
          deleteMany: {
            args: Prisma.tenantLogisticsStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenantLogisticsStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tenantLogisticsStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>[]
          }
          upsert: {
            args: Prisma.tenantLogisticsStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantLogisticsStatusPayload>
          }
          aggregate: {
            args: Prisma.TenantLogisticsStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantLogisticsStatus>
          }
          groupBy: {
            args: Prisma.tenantLogisticsStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantLogisticsStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenantLogisticsStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TenantLogisticsStatusCountAggregateOutputType> | number
          }
        }
      }
      tenantFinanceStatus: {
        payload: Prisma.$tenantFinanceStatusPayload<ExtArgs>
        fields: Prisma.tenantFinanceStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenantFinanceStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenantFinanceStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>
          }
          findFirst: {
            args: Prisma.tenantFinanceStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenantFinanceStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>
          }
          findMany: {
            args: Prisma.tenantFinanceStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>[]
          }
          create: {
            args: Prisma.tenantFinanceStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>
          }
          createMany: {
            args: Prisma.tenantFinanceStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenantFinanceStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>[]
          }
          delete: {
            args: Prisma.tenantFinanceStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>
          }
          update: {
            args: Prisma.tenantFinanceStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>
          }
          deleteMany: {
            args: Prisma.tenantFinanceStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenantFinanceStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tenantFinanceStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>[]
          }
          upsert: {
            args: Prisma.tenantFinanceStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenantFinanceStatusPayload>
          }
          aggregate: {
            args: Prisma.TenantFinanceStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantFinanceStatus>
          }
          groupBy: {
            args: Prisma.tenantFinanceStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantFinanceStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenantFinanceStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TenantFinanceStatusCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      companyService: {
        payload: Prisma.$companyServicePayload<ExtArgs>
        fields: Prisma.companyServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>
          }
          findFirst: {
            args: Prisma.companyServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>
          }
          findMany: {
            args: Prisma.companyServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>[]
          }
          create: {
            args: Prisma.companyServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>
          }
          createMany: {
            args: Prisma.companyServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companyServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>[]
          }
          delete: {
            args: Prisma.companyServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>
          }
          update: {
            args: Prisma.companyServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>
          }
          deleteMany: {
            args: Prisma.companyServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companyServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companyServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>[]
          }
          upsert: {
            args: Prisma.companyServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyServicePayload>
          }
          aggregate: {
            args: Prisma.CompanyServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyService>
          }
          groupBy: {
            args: Prisma.companyServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyServiceCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyServiceCountAggregateOutputType> | number
          }
        }
      }
      companyMaterial: {
        payload: Prisma.$companyMaterialPayload<ExtArgs>
        fields: Prisma.companyMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>
          }
          findFirst: {
            args: Prisma.companyMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>
          }
          findMany: {
            args: Prisma.companyMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>[]
          }
          create: {
            args: Prisma.companyMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>
          }
          createMany: {
            args: Prisma.companyMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companyMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>[]
          }
          delete: {
            args: Prisma.companyMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>
          }
          update: {
            args: Prisma.companyMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>
          }
          deleteMany: {
            args: Prisma.companyMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companyMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companyMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>[]
          }
          upsert: {
            args: Prisma.companyMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyMaterialPayload>
          }
          aggregate: {
            args: Prisma.CompanyMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyMaterial>
          }
          groupBy: {
            args: Prisma.companyMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyMaterialCountAggregateOutputType> | number
          }
        }
      }
      companyFinish: {
        payload: Prisma.$companyFinishPayload<ExtArgs>
        fields: Prisma.companyFinishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyFinishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyFinishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>
          }
          findFirst: {
            args: Prisma.companyFinishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyFinishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>
          }
          findMany: {
            args: Prisma.companyFinishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>[]
          }
          create: {
            args: Prisma.companyFinishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>
          }
          createMany: {
            args: Prisma.companyFinishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companyFinishCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>[]
          }
          delete: {
            args: Prisma.companyFinishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>
          }
          update: {
            args: Prisma.companyFinishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>
          }
          deleteMany: {
            args: Prisma.companyFinishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companyFinishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companyFinishUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>[]
          }
          upsert: {
            args: Prisma.companyFinishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyFinishPayload>
          }
          aggregate: {
            args: Prisma.CompanyFinishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyFinish>
          }
          groupBy: {
            args: Prisma.companyFinishGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyFinishGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyFinishCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyFinishCountAggregateOutputType> | number
          }
        }
      }
      CustomerAddress: {
        payload: Prisma.$CustomerAddressPayload<ExtArgs>
        fields: Prisma.CustomerAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findFirst: {
            args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findMany: {
            args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          create: {
            args: Prisma.CustomerAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          createMany: {
            args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          delete: {
            args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          update: {
            args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          deleteMany: {
            args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          upsert: {
            args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          aggregate: {
            args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerAddress>
          }
          groupBy: {
            args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerAddressCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressCountAggregateOutputType> | number
          }
        }
      }
      CustomerTaxInfo: {
        payload: Prisma.$CustomerTaxInfoPayload<ExtArgs>
        fields: Prisma.CustomerTaxInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerTaxInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerTaxInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>
          }
          findFirst: {
            args: Prisma.CustomerTaxInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerTaxInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>
          }
          findMany: {
            args: Prisma.CustomerTaxInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>[]
          }
          create: {
            args: Prisma.CustomerTaxInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>
          }
          createMany: {
            args: Prisma.CustomerTaxInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerTaxInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>[]
          }
          delete: {
            args: Prisma.CustomerTaxInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>
          }
          update: {
            args: Prisma.CustomerTaxInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>
          }
          deleteMany: {
            args: Prisma.CustomerTaxInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerTaxInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerTaxInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>[]
          }
          upsert: {
            args: Prisma.CustomerTaxInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTaxInfoPayload>
          }
          aggregate: {
            args: Prisma.CustomerTaxInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerTaxInfo>
          }
          groupBy: {
            args: Prisma.CustomerTaxInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerTaxInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerTaxInfoCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerTaxInfoCountAggregateOutputType> | number
          }
        }
      }
      CustomerContact: {
        payload: Prisma.$CustomerContactPayload<ExtArgs>
        fields: Prisma.CustomerContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          findFirst: {
            args: Prisma.CustomerContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          findMany: {
            args: Prisma.CustomerContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
          }
          create: {
            args: Prisma.CustomerContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          createMany: {
            args: Prisma.CustomerContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
          }
          delete: {
            args: Prisma.CustomerContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          update: {
            args: Prisma.CustomerContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          deleteMany: {
            args: Prisma.CustomerContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
          }
          upsert: {
            args: Prisma.CustomerContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerContactPayload>
          }
          aggregate: {
            args: Prisma.CustomerContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerContact>
          }
          groupBy: {
            args: Prisma.CustomerContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerContactCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerContactCountAggregateOutputType> | number
          }
        }
      }
      CustomerOperationalInfo: {
        payload: Prisma.$CustomerOperationalInfoPayload<ExtArgs>
        fields: Prisma.CustomerOperationalInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerOperationalInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerOperationalInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>
          }
          findFirst: {
            args: Prisma.CustomerOperationalInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerOperationalInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>
          }
          findMany: {
            args: Prisma.CustomerOperationalInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>[]
          }
          create: {
            args: Prisma.CustomerOperationalInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>
          }
          createMany: {
            args: Prisma.CustomerOperationalInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerOperationalInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>[]
          }
          delete: {
            args: Prisma.CustomerOperationalInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>
          }
          update: {
            args: Prisma.CustomerOperationalInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>
          }
          deleteMany: {
            args: Prisma.CustomerOperationalInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerOperationalInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerOperationalInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>[]
          }
          upsert: {
            args: Prisma.CustomerOperationalInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOperationalInfoPayload>
          }
          aggregate: {
            args: Prisma.CustomerOperationalInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerOperationalInfo>
          }
          groupBy: {
            args: Prisma.CustomerOperationalInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerOperationalInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerOperationalInfoCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerOperationalInfoCountAggregateOutputType> | number
          }
        }
      }
      CustomerNotesAndAttachments: {
        payload: Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>
        fields: Prisma.CustomerNotesAndAttachmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerNotesAndAttachmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerNotesAndAttachmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>
          }
          findFirst: {
            args: Prisma.CustomerNotesAndAttachmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerNotesAndAttachmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>
          }
          findMany: {
            args: Prisma.CustomerNotesAndAttachmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>[]
          }
          create: {
            args: Prisma.CustomerNotesAndAttachmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>
          }
          createMany: {
            args: Prisma.CustomerNotesAndAttachmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerNotesAndAttachmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>[]
          }
          delete: {
            args: Prisma.CustomerNotesAndAttachmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>
          }
          update: {
            args: Prisma.CustomerNotesAndAttachmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>
          }
          deleteMany: {
            args: Prisma.CustomerNotesAndAttachmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerNotesAndAttachmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerNotesAndAttachmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>[]
          }
          upsert: {
            args: Prisma.CustomerNotesAndAttachmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotesAndAttachmentsPayload>
          }
          aggregate: {
            args: Prisma.CustomerNotesAndAttachmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerNotesAndAttachments>
          }
          groupBy: {
            args: Prisma.CustomerNotesAndAttachmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerNotesAndAttachmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerNotesAndAttachmentsCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerNotesAndAttachmentsCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      VendorContact: {
        payload: Prisma.$VendorContactPayload<ExtArgs>
        fields: Prisma.VendorContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>
          }
          findFirst: {
            args: Prisma.VendorContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>
          }
          findMany: {
            args: Prisma.VendorContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>[]
          }
          create: {
            args: Prisma.VendorContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>
          }
          createMany: {
            args: Prisma.VendorContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>[]
          }
          delete: {
            args: Prisma.VendorContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>
          }
          update: {
            args: Prisma.VendorContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>
          }
          deleteMany: {
            args: Prisma.VendorContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>[]
          }
          upsert: {
            args: Prisma.VendorContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorContactPayload>
          }
          aggregate: {
            args: Prisma.VendorContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorContact>
          }
          groupBy: {
            args: Prisma.VendorContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorContactCountArgs<ExtArgs>
            result: $Utils.Optional<VendorContactCountAggregateOutputType> | number
          }
        }
      }
      VendorAddress: {
        payload: Prisma.$VendorAddressPayload<ExtArgs>
        fields: Prisma.VendorAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>
          }
          findFirst: {
            args: Prisma.VendorAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>
          }
          findMany: {
            args: Prisma.VendorAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>[]
          }
          create: {
            args: Prisma.VendorAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>
          }
          createMany: {
            args: Prisma.VendorAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>[]
          }
          delete: {
            args: Prisma.VendorAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>
          }
          update: {
            args: Prisma.VendorAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>
          }
          deleteMany: {
            args: Prisma.VendorAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>[]
          }
          upsert: {
            args: Prisma.VendorAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAddressPayload>
          }
          aggregate: {
            args: Prisma.VendorAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorAddress>
          }
          groupBy: {
            args: Prisma.VendorAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorAddressCountArgs<ExtArgs>
            result: $Utils.Optional<VendorAddressCountAggregateOutputType> | number
          }
        }
      }
      VendorTaxCompliance: {
        payload: Prisma.$VendorTaxCompliancePayload<ExtArgs>
        fields: Prisma.VendorTaxComplianceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorTaxComplianceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorTaxComplianceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>
          }
          findFirst: {
            args: Prisma.VendorTaxComplianceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorTaxComplianceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>
          }
          findMany: {
            args: Prisma.VendorTaxComplianceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>[]
          }
          create: {
            args: Prisma.VendorTaxComplianceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>
          }
          createMany: {
            args: Prisma.VendorTaxComplianceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorTaxComplianceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>[]
          }
          delete: {
            args: Prisma.VendorTaxComplianceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>
          }
          update: {
            args: Prisma.VendorTaxComplianceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>
          }
          deleteMany: {
            args: Prisma.VendorTaxComplianceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorTaxComplianceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorTaxComplianceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>[]
          }
          upsert: {
            args: Prisma.VendorTaxComplianceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorTaxCompliancePayload>
          }
          aggregate: {
            args: Prisma.VendorTaxComplianceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorTaxCompliance>
          }
          groupBy: {
            args: Prisma.VendorTaxComplianceGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorTaxComplianceGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorTaxComplianceCountArgs<ExtArgs>
            result: $Utils.Optional<VendorTaxComplianceCountAggregateOutputType> | number
          }
        }
      }
      VendorFinancial: {
        payload: Prisma.$VendorFinancialPayload<ExtArgs>
        fields: Prisma.VendorFinancialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFinancialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFinancialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>
          }
          findFirst: {
            args: Prisma.VendorFinancialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFinancialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>
          }
          findMany: {
            args: Prisma.VendorFinancialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>[]
          }
          create: {
            args: Prisma.VendorFinancialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>
          }
          createMany: {
            args: Prisma.VendorFinancialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorFinancialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>[]
          }
          delete: {
            args: Prisma.VendorFinancialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>
          }
          update: {
            args: Prisma.VendorFinancialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>
          }
          deleteMany: {
            args: Prisma.VendorFinancialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorFinancialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorFinancialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>[]
          }
          upsert: {
            args: Prisma.VendorFinancialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFinancialPayload>
          }
          aggregate: {
            args: Prisma.VendorFinancialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorFinancial>
          }
          groupBy: {
            args: Prisma.VendorFinancialGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorFinancialGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorFinancialCountArgs<ExtArgs>
            result: $Utils.Optional<VendorFinancialCountAggregateOutputType> | number
          }
        }
      }
      VendorOperationalSetting: {
        payload: Prisma.$VendorOperationalSettingPayload<ExtArgs>
        fields: Prisma.VendorOperationalSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorOperationalSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorOperationalSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>
          }
          findFirst: {
            args: Prisma.VendorOperationalSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorOperationalSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>
          }
          findMany: {
            args: Prisma.VendorOperationalSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>[]
          }
          create: {
            args: Prisma.VendorOperationalSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>
          }
          createMany: {
            args: Prisma.VendorOperationalSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorOperationalSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>[]
          }
          delete: {
            args: Prisma.VendorOperationalSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>
          }
          update: {
            args: Prisma.VendorOperationalSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>
          }
          deleteMany: {
            args: Prisma.VendorOperationalSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorOperationalSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorOperationalSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>[]
          }
          upsert: {
            args: Prisma.VendorOperationalSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorOperationalSettingPayload>
          }
          aggregate: {
            args: Prisma.VendorOperationalSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorOperationalSetting>
          }
          groupBy: {
            args: Prisma.VendorOperationalSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorOperationalSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorOperationalSettingCountArgs<ExtArgs>
            result: $Utils.Optional<VendorOperationalSettingCountAggregateOutputType> | number
          }
        }
      }
      VendorMetadata: {
        payload: Prisma.$VendorMetadataPayload<ExtArgs>
        fields: Prisma.VendorMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>
          }
          findFirst: {
            args: Prisma.VendorMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>
          }
          findMany: {
            args: Prisma.VendorMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>[]
          }
          create: {
            args: Prisma.VendorMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>
          }
          createMany: {
            args: Prisma.VendorMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>[]
          }
          delete: {
            args: Prisma.VendorMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>
          }
          update: {
            args: Prisma.VendorMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>
          }
          deleteMany: {
            args: Prisma.VendorMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>[]
          }
          upsert: {
            args: Prisma.VendorMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorMetadataPayload>
          }
          aggregate: {
            args: Prisma.VendorMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorMetadata>
          }
          groupBy: {
            args: Prisma.VendorMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<VendorMetadataCountAggregateOutputType> | number
          }
        }
      }
      company_vendor_capabilities: {
        payload: Prisma.$company_vendor_capabilitiesPayload<ExtArgs>
        fields: Prisma.company_vendor_capabilitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_vendor_capabilitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_vendor_capabilitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>
          }
          findFirst: {
            args: Prisma.company_vendor_capabilitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_vendor_capabilitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>
          }
          findMany: {
            args: Prisma.company_vendor_capabilitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>[]
          }
          create: {
            args: Prisma.company_vendor_capabilitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>
          }
          createMany: {
            args: Prisma.company_vendor_capabilitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_vendor_capabilitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>[]
          }
          delete: {
            args: Prisma.company_vendor_capabilitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>
          }
          update: {
            args: Prisma.company_vendor_capabilitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>
          }
          deleteMany: {
            args: Prisma.company_vendor_capabilitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_vendor_capabilitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_vendor_capabilitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>[]
          }
          upsert: {
            args: Prisma.company_vendor_capabilitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capabilitiesPayload>
          }
          aggregate: {
            args: Prisma.Company_vendor_capabilitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_vendor_capabilities>
          }
          groupBy: {
            args: Prisma.company_vendor_capabilitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_vendor_capabilitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_vendor_capabilitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Company_vendor_capabilitiesCountAggregateOutputType> | number
          }
        }
      }
      company_vendor_capability_sub_categories: {
        payload: Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>
        fields: Prisma.company_vendor_capability_sub_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_vendor_capability_sub_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_vendor_capability_sub_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>
          }
          findFirst: {
            args: Prisma.company_vendor_capability_sub_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_vendor_capability_sub_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>
          }
          findMany: {
            args: Prisma.company_vendor_capability_sub_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>[]
          }
          create: {
            args: Prisma.company_vendor_capability_sub_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>
          }
          createMany: {
            args: Prisma.company_vendor_capability_sub_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_vendor_capability_sub_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>[]
          }
          delete: {
            args: Prisma.company_vendor_capability_sub_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>
          }
          update: {
            args: Prisma.company_vendor_capability_sub_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.company_vendor_capability_sub_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_vendor_capability_sub_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_vendor_capability_sub_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.company_vendor_capability_sub_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_capability_sub_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Company_vendor_capability_sub_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_vendor_capability_sub_categories>
          }
          groupBy: {
            args: Prisma.company_vendor_capability_sub_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_vendor_capability_sub_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_vendor_capability_sub_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Company_vendor_capability_sub_categoriesCountAggregateOutputType> | number
          }
        }
      }
      company_vendor_certifications: {
        payload: Prisma.$company_vendor_certificationsPayload<ExtArgs>
        fields: Prisma.company_vendor_certificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_vendor_certificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_vendor_certificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>
          }
          findFirst: {
            args: Prisma.company_vendor_certificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_vendor_certificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>
          }
          findMany: {
            args: Prisma.company_vendor_certificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>[]
          }
          create: {
            args: Prisma.company_vendor_certificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>
          }
          createMany: {
            args: Prisma.company_vendor_certificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_vendor_certificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>[]
          }
          delete: {
            args: Prisma.company_vendor_certificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>
          }
          update: {
            args: Prisma.company_vendor_certificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>
          }
          deleteMany: {
            args: Prisma.company_vendor_certificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_vendor_certificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_vendor_certificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>[]
          }
          upsert: {
            args: Prisma.company_vendor_certificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_certificationsPayload>
          }
          aggregate: {
            args: Prisma.Company_vendor_certificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_vendor_certifications>
          }
          groupBy: {
            args: Prisma.company_vendor_certificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_vendor_certificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_vendor_certificationsCountArgs<ExtArgs>
            result: $Utils.Optional<Company_vendor_certificationsCountAggregateOutputType> | number
          }
        }
      }
      company_vendor_flags: {
        payload: Prisma.$company_vendor_flagsPayload<ExtArgs>
        fields: Prisma.company_vendor_flagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_vendor_flagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_vendor_flagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>
          }
          findFirst: {
            args: Prisma.company_vendor_flagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_vendor_flagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>
          }
          findMany: {
            args: Prisma.company_vendor_flagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>[]
          }
          create: {
            args: Prisma.company_vendor_flagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>
          }
          createMany: {
            args: Prisma.company_vendor_flagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_vendor_flagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>[]
          }
          delete: {
            args: Prisma.company_vendor_flagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>
          }
          update: {
            args: Prisma.company_vendor_flagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>
          }
          deleteMany: {
            args: Prisma.company_vendor_flagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_vendor_flagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_vendor_flagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>[]
          }
          upsert: {
            args: Prisma.company_vendor_flagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_vendor_flagsPayload>
          }
          aggregate: {
            args: Prisma.Company_vendor_flagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_vendor_flags>
          }
          groupBy: {
            args: Prisma.company_vendor_flagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_vendor_flagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_vendor_flagsCountArgs<ExtArgs>
            result: $Utils.Optional<Company_vendor_flagsCountAggregateOutputType> | number
          }
        }
      }
      company_school: {
        payload: Prisma.$company_schoolPayload<ExtArgs>
        fields: Prisma.company_schoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_schoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_schoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>
          }
          findFirst: {
            args: Prisma.company_schoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_schoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>
          }
          findMany: {
            args: Prisma.company_schoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>[]
          }
          create: {
            args: Prisma.company_schoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>
          }
          createMany: {
            args: Prisma.company_schoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_schoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>[]
          }
          delete: {
            args: Prisma.company_schoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>
          }
          update: {
            args: Prisma.company_schoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>
          }
          deleteMany: {
            args: Prisma.company_schoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_schoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_schoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>[]
          }
          upsert: {
            args: Prisma.company_schoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_schoolPayload>
          }
          aggregate: {
            args: Prisma.Company_schoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_school>
          }
          groupBy: {
            args: Prisma.company_schoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_schoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_schoolCountArgs<ExtArgs>
            result: $Utils.Optional<Company_schoolCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    quote?: QuoteOmit
    quoteItem?: QuoteItemOmit
    passwordResetOTP?: PasswordResetOTPOmit
    passwordResetToken?: PasswordResetTokenOmit
    tenantCurrency?: tenantCurrencyOmit
    tenantPaymentTerms?: tenantPaymentTermsOmit
    tenantPaymentStatus?: tenantPaymentStatusOmit
    tenantQuoteStatus?: tenantQuoteStatusOmit
    tenantOrderStatus?: tenantOrderStatusOmit
    tenantLogisticsStatus?: tenantLogisticsStatusOmit
    tenantFinanceStatus?: tenantFinanceStatusOmit
    customer?: CustomerOmit
    companyService?: companyServiceOmit
    companyMaterial?: companyMaterialOmit
    companyFinish?: companyFinishOmit
    customerAddress?: CustomerAddressOmit
    customerTaxInfo?: CustomerTaxInfoOmit
    customerContact?: CustomerContactOmit
    customerOperationalInfo?: CustomerOperationalInfoOmit
    customerNotesAndAttachments?: CustomerNotesAndAttachmentsOmit
    vendor?: VendorOmit
    vendorContact?: VendorContactOmit
    vendorAddress?: VendorAddressOmit
    vendorTaxCompliance?: VendorTaxComplianceOmit
    vendorFinancial?: VendorFinancialOmit
    vendorOperationalSetting?: VendorOperationalSettingOmit
    vendorMetadata?: VendorMetadataOmit
    company_vendor_capabilities?: company_vendor_capabilitiesOmit
    company_vendor_capability_sub_categories?: company_vendor_capability_sub_categoriesOmit
    company_vendor_certifications?: company_vendor_certificationsOmit
    company_vendor_flags?: company_vendor_flagsOmit
    company_school?: company_schoolOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    otps: number
    resetTokens: number
    quotes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otps?: boolean | UserCountOutputTypeCountOtpsArgs
    resetTokens?: boolean | UserCountOutputTypeCountResetTokensArgs
    quotes?: boolean | UserCountOutputTypeCountQuotesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetOTPWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }


  /**
   * Count Type QuoteCountOutputType
   */

  export type QuoteCountOutputType = {
    QuoteItems: number
  }

  export type QuoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QuoteItems?: boolean | QuoteCountOutputTypeCountQuoteItemsArgs
  }

  // Custom InputTypes
  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteCountOutputType
     */
    select?: QuoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountQuoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    addresses: number
    contacts: number
    attachments: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | CustomerCountOutputTypeCountAddressesArgs
    contacts?: boolean | CustomerCountOutputTypeCountContactsArgs
    attachments?: boolean | CustomerCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerContactWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerNotesAndAttachmentsWhereInput
  }


  /**
   * Count Type CompanyServiceCountOutputType
   */

  export type CompanyServiceCountOutputType = {
    materials: number
    finishes: number
  }

  export type CompanyServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | CompanyServiceCountOutputTypeCountMaterialsArgs
    finishes?: boolean | CompanyServiceCountOutputTypeCountFinishesArgs
  }

  // Custom InputTypes
  /**
   * CompanyServiceCountOutputType without action
   */
  export type CompanyServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyServiceCountOutputType
     */
    select?: CompanyServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyServiceCountOutputType without action
   */
  export type CompanyServiceCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyMaterialWhereInput
  }

  /**
   * CompanyServiceCountOutputType without action
   */
  export type CompanyServiceCountOutputTypeCountFinishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyFinishWhereInput
  }


  /**
   * Count Type Company_vendor_capabilitiesCountOutputType
   */

  export type Company_vendor_capabilitiesCountOutputType = {
    subCategories: number
  }

  export type Company_vendor_capabilitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | Company_vendor_capabilitiesCountOutputTypeCountSubCategoriesArgs
  }

  // Custom InputTypes
  /**
   * Company_vendor_capabilitiesCountOutputType without action
   */
  export type Company_vendor_capabilitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company_vendor_capabilitiesCountOutputType
     */
    select?: Company_vendor_capabilitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Company_vendor_capabilitiesCountOutputType without action
   */
  export type Company_vendor_capabilitiesCountOutputTypeCountSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_vendor_capability_sub_categoriesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    phone: number
    roles: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    roles?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone: string | null
    roles: JsonValue
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    roles?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | User$customerArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
    otps?: boolean | User$otpsArgs<ExtArgs>
    resetTokens?: boolean | User$resetTokensArgs<ExtArgs>
    quotes?: boolean | User$quotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    roles?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    roles?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    roles?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "phone" | "roles" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | User$customerArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
    otps?: boolean | User$otpsArgs<ExtArgs>
    resetTokens?: boolean | User$resetTokensArgs<ExtArgs>
    quotes?: boolean | User$quotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      otps: Prisma.$PasswordResetOTPPayload<ExtArgs>[]
      resetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      first_name: string
      last_name: string
      email: string
      password: string
      phone: string | null
      roles: Prisma.JsonValue
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends User$customerArgs<ExtArgs> = {}>(args?: Subset<T, User$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends User$vendorArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    otps<T extends User$otpsArgs<ExtArgs> = {}>(args?: Subset<T, User$otpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resetTokens<T extends User$resetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$resetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends User$quotesArgs<ExtArgs> = {}>(args?: Subset<T, User$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly roles: FieldRef<"User", 'Json'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.customer
   */
  export type User$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * User.vendor
   */
  export type User$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * User.otps
   */
  export type User$otpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    where?: PasswordResetOTPWhereInput
    orderBy?: PasswordResetOTPOrderByWithRelationInput | PasswordResetOTPOrderByWithRelationInput[]
    cursor?: PasswordResetOTPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetOTPScalarFieldEnum | PasswordResetOTPScalarFieldEnum[]
  }

  /**
   * User.resetTokens
   */
  export type User$resetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.quotes
   */
  export type User$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteAvgAggregateOutputType = {
    quote_item_id: number | null
    sales_person: number | null
    project_manager: number | null
    accept_agreement: number | null
  }

  export type QuoteSumAggregateOutputType = {
    quote_item_id: number | null
    sales_person: number | null
    project_manager: number | null
    accept_agreement: number | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    quote_item_id: number | null
    status: string | null
    payment_status: string | null
    quote_type: $Enums.QuoteType | null
    tax: string | null
    deposit_paid: string | null
    shipping: string | null
    tax_buy_price: string | null
    shipping_buy_price: string | null
    lead_time: string | null
    payable: string | null
    freight_condition: string | null
    freight_condition_dismiss: boolean | null
    customer_email: string | null
    emails: string | null
    invoice_date: Date | null
    invoice_email: string | null
    billing_name: string | null
    billing_company: string | null
    billing_address: string | null
    billing_city: string | null
    billing_state: string | null
    billing_country: string | null
    billing_zip: string | null
    billing_phone: string | null
    billing_fax: string | null
    shipping_name: string | null
    shipping_company: string | null
    shipping_address: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_country: string | null
    shipping_zip: string | null
    shipping_phone: string | null
    shipping_email: string | null
    shipping_fax: string | null
    sales_person: number | null
    project_manager: number | null
    accept_agreement: number | null
    date_created: Date | null
    created_month: string | null
    created_year: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    quote_item_id: number | null
    status: string | null
    payment_status: string | null
    quote_type: $Enums.QuoteType | null
    tax: string | null
    deposit_paid: string | null
    shipping: string | null
    tax_buy_price: string | null
    shipping_buy_price: string | null
    lead_time: string | null
    payable: string | null
    freight_condition: string | null
    freight_condition_dismiss: boolean | null
    customer_email: string | null
    emails: string | null
    invoice_date: Date | null
    invoice_email: string | null
    billing_name: string | null
    billing_company: string | null
    billing_address: string | null
    billing_city: string | null
    billing_state: string | null
    billing_country: string | null
    billing_zip: string | null
    billing_phone: string | null
    billing_fax: string | null
    shipping_name: string | null
    shipping_company: string | null
    shipping_address: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_country: string | null
    shipping_zip: string | null
    shipping_phone: string | null
    shipping_email: string | null
    shipping_fax: string | null
    sales_person: number | null
    project_manager: number | null
    accept_agreement: number | null
    date_created: Date | null
    created_month: string | null
    created_year: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    user_id: number
    quote_item_id: number
    status: number
    payment_status: number
    quote_type: number
    tax: number
    deposit_paid: number
    shipping: number
    tax_buy_price: number
    shipping_buy_price: number
    lead_time: number
    payable: number
    freight_condition: number
    freight_condition_dismiss: number
    customer_email: number
    emails: number
    invoice_date: number
    invoice_email: number
    billing_name: number
    billing_company: number
    billing_address: number
    billing_city: number
    billing_state: number
    billing_country: number
    billing_zip: number
    billing_phone: number
    billing_fax: number
    shipping_name: number
    shipping_company: number
    shipping_address: number
    shipping_city: number
    shipping_state: number
    shipping_country: number
    shipping_zip: number
    shipping_phone: number
    shipping_email: number
    shipping_fax: number
    sales_person: number
    project_manager: number
    accept_agreement: number
    date_created: number
    created_month: number
    created_year: number
    created_at: number
    updated_at: number
    deleted_at: number
    is_deleted: number
    _all: number
  }


  export type QuoteAvgAggregateInputType = {
    quote_item_id?: true
    sales_person?: true
    project_manager?: true
    accept_agreement?: true
  }

  export type QuoteSumAggregateInputType = {
    quote_item_id?: true
    sales_person?: true
    project_manager?: true
    accept_agreement?: true
  }

  export type QuoteMinAggregateInputType = {
    id?: true
    user_id?: true
    quote_item_id?: true
    status?: true
    payment_status?: true
    quote_type?: true
    tax?: true
    deposit_paid?: true
    shipping?: true
    tax_buy_price?: true
    shipping_buy_price?: true
    lead_time?: true
    payable?: true
    freight_condition?: true
    freight_condition_dismiss?: true
    customer_email?: true
    emails?: true
    invoice_date?: true
    invoice_email?: true
    billing_name?: true
    billing_company?: true
    billing_address?: true
    billing_city?: true
    billing_state?: true
    billing_country?: true
    billing_zip?: true
    billing_phone?: true
    billing_fax?: true
    shipping_name?: true
    shipping_company?: true
    shipping_address?: true
    shipping_city?: true
    shipping_state?: true
    shipping_country?: true
    shipping_zip?: true
    shipping_phone?: true
    shipping_email?: true
    shipping_fax?: true
    sales_person?: true
    project_manager?: true
    accept_agreement?: true
    date_created?: true
    created_month?: true
    created_year?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    user_id?: true
    quote_item_id?: true
    status?: true
    payment_status?: true
    quote_type?: true
    tax?: true
    deposit_paid?: true
    shipping?: true
    tax_buy_price?: true
    shipping_buy_price?: true
    lead_time?: true
    payable?: true
    freight_condition?: true
    freight_condition_dismiss?: true
    customer_email?: true
    emails?: true
    invoice_date?: true
    invoice_email?: true
    billing_name?: true
    billing_company?: true
    billing_address?: true
    billing_city?: true
    billing_state?: true
    billing_country?: true
    billing_zip?: true
    billing_phone?: true
    billing_fax?: true
    shipping_name?: true
    shipping_company?: true
    shipping_address?: true
    shipping_city?: true
    shipping_state?: true
    shipping_country?: true
    shipping_zip?: true
    shipping_phone?: true
    shipping_email?: true
    shipping_fax?: true
    sales_person?: true
    project_manager?: true
    accept_agreement?: true
    date_created?: true
    created_month?: true
    created_year?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    user_id?: true
    quote_item_id?: true
    status?: true
    payment_status?: true
    quote_type?: true
    tax?: true
    deposit_paid?: true
    shipping?: true
    tax_buy_price?: true
    shipping_buy_price?: true
    lead_time?: true
    payable?: true
    freight_condition?: true
    freight_condition_dismiss?: true
    customer_email?: true
    emails?: true
    invoice_date?: true
    invoice_email?: true
    billing_name?: true
    billing_company?: true
    billing_address?: true
    billing_city?: true
    billing_state?: true
    billing_country?: true
    billing_zip?: true
    billing_phone?: true
    billing_fax?: true
    shipping_name?: true
    shipping_company?: true
    shipping_address?: true
    shipping_city?: true
    shipping_state?: true
    shipping_country?: true
    shipping_zip?: true
    shipping_phone?: true
    shipping_email?: true
    shipping_fax?: true
    sales_person?: true
    project_manager?: true
    accept_agreement?: true
    date_created?: true
    created_month?: true
    created_year?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _avg?: QuoteAvgAggregateInputType
    _sum?: QuoteSumAggregateInputType
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    user_id: string
    quote_item_id: number
    status: string | null
    payment_status: string | null
    quote_type: $Enums.QuoteType
    tax: string | null
    deposit_paid: string | null
    shipping: string | null
    tax_buy_price: string | null
    shipping_buy_price: string | null
    lead_time: string | null
    payable: string | null
    freight_condition: string | null
    freight_condition_dismiss: boolean | null
    customer_email: string | null
    emails: string | null
    invoice_date: Date | null
    invoice_email: string | null
    billing_name: string | null
    billing_company: string | null
    billing_address: string | null
    billing_city: string | null
    billing_state: string | null
    billing_country: string | null
    billing_zip: string | null
    billing_phone: string | null
    billing_fax: string | null
    shipping_name: string | null
    shipping_company: string | null
    shipping_address: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_country: string | null
    shipping_zip: string | null
    shipping_phone: string | null
    shipping_email: string | null
    shipping_fax: string | null
    sales_person: number | null
    project_manager: number | null
    accept_agreement: number | null
    date_created: Date | null
    created_month: string | null
    created_year: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    is_deleted: boolean | null
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    quote_item_id?: boolean
    status?: boolean
    payment_status?: boolean
    quote_type?: boolean
    tax?: boolean
    deposit_paid?: boolean
    shipping?: boolean
    tax_buy_price?: boolean
    shipping_buy_price?: boolean
    lead_time?: boolean
    payable?: boolean
    freight_condition?: boolean
    freight_condition_dismiss?: boolean
    customer_email?: boolean
    emails?: boolean
    invoice_date?: boolean
    invoice_email?: boolean
    billing_name?: boolean
    billing_company?: boolean
    billing_address?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_country?: boolean
    billing_zip?: boolean
    billing_phone?: boolean
    billing_fax?: boolean
    shipping_name?: boolean
    shipping_company?: boolean
    shipping_address?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_country?: boolean
    shipping_zip?: boolean
    shipping_phone?: boolean
    shipping_email?: boolean
    shipping_fax?: boolean
    sales_person?: boolean
    project_manager?: boolean
    accept_agreement?: boolean
    date_created?: boolean
    created_month?: boolean
    created_year?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    User?: boolean | Quote$UserArgs<ExtArgs>
    QuoteItems?: boolean | Quote$QuoteItemsArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    quote_item_id?: boolean
    status?: boolean
    payment_status?: boolean
    quote_type?: boolean
    tax?: boolean
    deposit_paid?: boolean
    shipping?: boolean
    tax_buy_price?: boolean
    shipping_buy_price?: boolean
    lead_time?: boolean
    payable?: boolean
    freight_condition?: boolean
    freight_condition_dismiss?: boolean
    customer_email?: boolean
    emails?: boolean
    invoice_date?: boolean
    invoice_email?: boolean
    billing_name?: boolean
    billing_company?: boolean
    billing_address?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_country?: boolean
    billing_zip?: boolean
    billing_phone?: boolean
    billing_fax?: boolean
    shipping_name?: boolean
    shipping_company?: boolean
    shipping_address?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_country?: boolean
    shipping_zip?: boolean
    shipping_phone?: boolean
    shipping_email?: boolean
    shipping_fax?: boolean
    sales_person?: boolean
    project_manager?: boolean
    accept_agreement?: boolean
    date_created?: boolean
    created_month?: boolean
    created_year?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    User?: boolean | Quote$UserArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    quote_item_id?: boolean
    status?: boolean
    payment_status?: boolean
    quote_type?: boolean
    tax?: boolean
    deposit_paid?: boolean
    shipping?: boolean
    tax_buy_price?: boolean
    shipping_buy_price?: boolean
    lead_time?: boolean
    payable?: boolean
    freight_condition?: boolean
    freight_condition_dismiss?: boolean
    customer_email?: boolean
    emails?: boolean
    invoice_date?: boolean
    invoice_email?: boolean
    billing_name?: boolean
    billing_company?: boolean
    billing_address?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_country?: boolean
    billing_zip?: boolean
    billing_phone?: boolean
    billing_fax?: boolean
    shipping_name?: boolean
    shipping_company?: boolean
    shipping_address?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_country?: boolean
    shipping_zip?: boolean
    shipping_phone?: boolean
    shipping_email?: boolean
    shipping_fax?: boolean
    sales_person?: boolean
    project_manager?: boolean
    accept_agreement?: boolean
    date_created?: boolean
    created_month?: boolean
    created_year?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    User?: boolean | Quote$UserArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    id?: boolean
    user_id?: boolean
    quote_item_id?: boolean
    status?: boolean
    payment_status?: boolean
    quote_type?: boolean
    tax?: boolean
    deposit_paid?: boolean
    shipping?: boolean
    tax_buy_price?: boolean
    shipping_buy_price?: boolean
    lead_time?: boolean
    payable?: boolean
    freight_condition?: boolean
    freight_condition_dismiss?: boolean
    customer_email?: boolean
    emails?: boolean
    invoice_date?: boolean
    invoice_email?: boolean
    billing_name?: boolean
    billing_company?: boolean
    billing_address?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_country?: boolean
    billing_zip?: boolean
    billing_phone?: boolean
    billing_fax?: boolean
    shipping_name?: boolean
    shipping_company?: boolean
    shipping_address?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_country?: boolean
    shipping_zip?: boolean
    shipping_phone?: boolean
    shipping_email?: boolean
    shipping_fax?: boolean
    sales_person?: boolean
    project_manager?: boolean
    accept_agreement?: boolean
    date_created?: boolean
    created_month?: boolean
    created_year?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
  }

  export type QuoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "quote_item_id" | "status" | "payment_status" | "quote_type" | "tax" | "deposit_paid" | "shipping" | "tax_buy_price" | "shipping_buy_price" | "lead_time" | "payable" | "freight_condition" | "freight_condition_dismiss" | "customer_email" | "emails" | "invoice_date" | "invoice_email" | "billing_name" | "billing_company" | "billing_address" | "billing_city" | "billing_state" | "billing_country" | "billing_zip" | "billing_phone" | "billing_fax" | "shipping_name" | "shipping_company" | "shipping_address" | "shipping_city" | "shipping_state" | "shipping_country" | "shipping_zip" | "shipping_phone" | "shipping_email" | "shipping_fax" | "sales_person" | "project_manager" | "accept_agreement" | "date_created" | "created_month" | "created_year" | "created_at" | "updated_at" | "deleted_at" | "is_deleted", ExtArgs["result"]["quote"]>
  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Quote$UserArgs<ExtArgs>
    QuoteItems?: boolean | Quote$QuoteItemsArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Quote$UserArgs<ExtArgs>
  }
  export type QuoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Quote$UserArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      QuoteItems: Prisma.$QuoteItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      quote_item_id: number
      status: string | null
      payment_status: string | null
      quote_type: $Enums.QuoteType
      tax: string | null
      deposit_paid: string | null
      shipping: string | null
      tax_buy_price: string | null
      shipping_buy_price: string | null
      lead_time: string | null
      payable: string | null
      freight_condition: string | null
      freight_condition_dismiss: boolean | null
      customer_email: string | null
      emails: string | null
      invoice_date: Date | null
      invoice_email: string | null
      billing_name: string | null
      billing_company: string | null
      billing_address: string | null
      billing_city: string | null
      billing_state: string | null
      billing_country: string | null
      billing_zip: string | null
      billing_phone: string | null
      billing_fax: string | null
      shipping_name: string | null
      shipping_company: string | null
      shipping_address: string | null
      shipping_city: string | null
      shipping_state: string | null
      shipping_country: string | null
      shipping_zip: string | null
      shipping_phone: string | null
      shipping_email: string | null
      shipping_fax: string | null
      sales_person: number | null
      project_manager: number | null
      accept_agreement: number | null
      date_created: Date | null
      created_month: string | null
      created_year: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      is_deleted: boolean | null
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes and returns the data updated in the database.
     * @param {QuoteUpdateManyAndReturnArgs} args - Arguments to update many Quotes.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Quote$UserArgs<ExtArgs> = {}>(args?: Subset<T, Quote$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    QuoteItems<T extends Quote$QuoteItemsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$QuoteItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'String'>
    readonly user_id: FieldRef<"Quote", 'String'>
    readonly quote_item_id: FieldRef<"Quote", 'Int'>
    readonly status: FieldRef<"Quote", 'String'>
    readonly payment_status: FieldRef<"Quote", 'String'>
    readonly quote_type: FieldRef<"Quote", 'QuoteType'>
    readonly tax: FieldRef<"Quote", 'String'>
    readonly deposit_paid: FieldRef<"Quote", 'String'>
    readonly shipping: FieldRef<"Quote", 'String'>
    readonly tax_buy_price: FieldRef<"Quote", 'String'>
    readonly shipping_buy_price: FieldRef<"Quote", 'String'>
    readonly lead_time: FieldRef<"Quote", 'String'>
    readonly payable: FieldRef<"Quote", 'String'>
    readonly freight_condition: FieldRef<"Quote", 'String'>
    readonly freight_condition_dismiss: FieldRef<"Quote", 'Boolean'>
    readonly customer_email: FieldRef<"Quote", 'String'>
    readonly emails: FieldRef<"Quote", 'String'>
    readonly invoice_date: FieldRef<"Quote", 'DateTime'>
    readonly invoice_email: FieldRef<"Quote", 'String'>
    readonly billing_name: FieldRef<"Quote", 'String'>
    readonly billing_company: FieldRef<"Quote", 'String'>
    readonly billing_address: FieldRef<"Quote", 'String'>
    readonly billing_city: FieldRef<"Quote", 'String'>
    readonly billing_state: FieldRef<"Quote", 'String'>
    readonly billing_country: FieldRef<"Quote", 'String'>
    readonly billing_zip: FieldRef<"Quote", 'String'>
    readonly billing_phone: FieldRef<"Quote", 'String'>
    readonly billing_fax: FieldRef<"Quote", 'String'>
    readonly shipping_name: FieldRef<"Quote", 'String'>
    readonly shipping_company: FieldRef<"Quote", 'String'>
    readonly shipping_address: FieldRef<"Quote", 'String'>
    readonly shipping_city: FieldRef<"Quote", 'String'>
    readonly shipping_state: FieldRef<"Quote", 'String'>
    readonly shipping_country: FieldRef<"Quote", 'String'>
    readonly shipping_zip: FieldRef<"Quote", 'String'>
    readonly shipping_phone: FieldRef<"Quote", 'String'>
    readonly shipping_email: FieldRef<"Quote", 'String'>
    readonly shipping_fax: FieldRef<"Quote", 'String'>
    readonly sales_person: FieldRef<"Quote", 'Int'>
    readonly project_manager: FieldRef<"Quote", 'Int'>
    readonly accept_agreement: FieldRef<"Quote", 'Int'>
    readonly date_created: FieldRef<"Quote", 'DateTime'>
    readonly created_month: FieldRef<"Quote", 'String'>
    readonly created_year: FieldRef<"Quote", 'String'>
    readonly created_at: FieldRef<"Quote", 'DateTime'>
    readonly updated_at: FieldRef<"Quote", 'DateTime'>
    readonly deleted_at: FieldRef<"Quote", 'DateTime'>
    readonly is_deleted: FieldRef<"Quote", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
  }

  /**
   * Quote updateManyAndReturn
   */
  export type QuoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to delete.
     */
    limit?: number
  }

  /**
   * Quote.User
   */
  export type Quote$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Quote.QuoteItems
   */
  export type Quote$QuoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    cursor?: QuoteItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model QuoteItem
   */

  export type AggregateQuoteItem = {
    _count: QuoteItemCountAggregateOutputType | null
    _avg: QuoteItemAvgAggregateOutputType | null
    _sum: QuoteItemSumAggregateOutputType | null
    _min: QuoteItemMinAggregateOutputType | null
    _max: QuoteItemMaxAggregateOutputType | null
  }

  export type QuoteItemAvgAggregateOutputType = {
    quantity: number | null
    non_taxable: number | null
    non_shipping: number | null
    last_updated_by: number | null
  }

  export type QuoteItemSumAggregateOutputType = {
    quantity: number | null
    non_taxable: number | null
    non_shipping: number | null
    last_updated_by: number | null
  }

  export type QuoteItemMinAggregateOutputType = {
    id: string | null
    quote_id: string | null
    file_name: string | null
    file_url: string | null
    status: boolean | null
    quantity: number | null
    service: string | null
    material: string | null
    finish: string | null
    description: string | null
    process: string | null
    specification: string | null
    price: string | null
    cost: string | null
    cost_shipping_price: string | null
    cost_shipping_total: string | null
    custom_shipping_total: string | null
    buy_price: string | null
    buy_shipping_price: string | null
    buy_shipping_total: string | null
    quantity_owed: string | null
    invoiced: boolean | null
    non_taxable: number | null
    non_shipping: number | null
    is_deleted: boolean | null
    vendor_id: string | null
    vendor_details: string | null
    last_updated_by: number | null
    work_instructions: string | null
    add_vendor: boolean | null
    markings: string | null
    part_item_number: string | null
    file_year: string | null
    file_month: string | null
    tab_open: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type QuoteItemMaxAggregateOutputType = {
    id: string | null
    quote_id: string | null
    file_name: string | null
    file_url: string | null
    status: boolean | null
    quantity: number | null
    service: string | null
    material: string | null
    finish: string | null
    description: string | null
    process: string | null
    specification: string | null
    price: string | null
    cost: string | null
    cost_shipping_price: string | null
    cost_shipping_total: string | null
    custom_shipping_total: string | null
    buy_price: string | null
    buy_shipping_price: string | null
    buy_shipping_total: string | null
    quantity_owed: string | null
    invoiced: boolean | null
    non_taxable: number | null
    non_shipping: number | null
    is_deleted: boolean | null
    vendor_id: string | null
    vendor_details: string | null
    last_updated_by: number | null
    work_instructions: string | null
    add_vendor: boolean | null
    markings: string | null
    part_item_number: string | null
    file_year: string | null
    file_month: string | null
    tab_open: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type QuoteItemCountAggregateOutputType = {
    id: number
    quote_id: number
    file_name: number
    file_url: number
    status: number
    quantity: number
    service: number
    material: number
    finish: number
    description: number
    process: number
    specification: number
    price: number
    cost: number
    cost_shipping_price: number
    cost_shipping_total: number
    custom_shipping_total: number
    buy_price: number
    buy_shipping_price: number
    buy_shipping_total: number
    quantity_owed: number
    invoiced: number
    non_taxable: number
    non_shipping: number
    is_deleted: number
    vendor_id: number
    vendor_details: number
    last_updated_by: number
    work_instructions: number
    add_vendor: number
    markings: number
    part_item_number: number
    file_year: number
    file_month: number
    tab_open: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type QuoteItemAvgAggregateInputType = {
    quantity?: true
    non_taxable?: true
    non_shipping?: true
    last_updated_by?: true
  }

  export type QuoteItemSumAggregateInputType = {
    quantity?: true
    non_taxable?: true
    non_shipping?: true
    last_updated_by?: true
  }

  export type QuoteItemMinAggregateInputType = {
    id?: true
    quote_id?: true
    file_name?: true
    file_url?: true
    status?: true
    quantity?: true
    service?: true
    material?: true
    finish?: true
    description?: true
    process?: true
    specification?: true
    price?: true
    cost?: true
    cost_shipping_price?: true
    cost_shipping_total?: true
    custom_shipping_total?: true
    buy_price?: true
    buy_shipping_price?: true
    buy_shipping_total?: true
    quantity_owed?: true
    invoiced?: true
    non_taxable?: true
    non_shipping?: true
    is_deleted?: true
    vendor_id?: true
    vendor_details?: true
    last_updated_by?: true
    work_instructions?: true
    add_vendor?: true
    markings?: true
    part_item_number?: true
    file_year?: true
    file_month?: true
    tab_open?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type QuoteItemMaxAggregateInputType = {
    id?: true
    quote_id?: true
    file_name?: true
    file_url?: true
    status?: true
    quantity?: true
    service?: true
    material?: true
    finish?: true
    description?: true
    process?: true
    specification?: true
    price?: true
    cost?: true
    cost_shipping_price?: true
    cost_shipping_total?: true
    custom_shipping_total?: true
    buy_price?: true
    buy_shipping_price?: true
    buy_shipping_total?: true
    quantity_owed?: true
    invoiced?: true
    non_taxable?: true
    non_shipping?: true
    is_deleted?: true
    vendor_id?: true
    vendor_details?: true
    last_updated_by?: true
    work_instructions?: true
    add_vendor?: true
    markings?: true
    part_item_number?: true
    file_year?: true
    file_month?: true
    tab_open?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type QuoteItemCountAggregateInputType = {
    id?: true
    quote_id?: true
    file_name?: true
    file_url?: true
    status?: true
    quantity?: true
    service?: true
    material?: true
    finish?: true
    description?: true
    process?: true
    specification?: true
    price?: true
    cost?: true
    cost_shipping_price?: true
    cost_shipping_total?: true
    custom_shipping_total?: true
    buy_price?: true
    buy_shipping_price?: true
    buy_shipping_total?: true
    quantity_owed?: true
    invoiced?: true
    non_taxable?: true
    non_shipping?: true
    is_deleted?: true
    vendor_id?: true
    vendor_details?: true
    last_updated_by?: true
    work_instructions?: true
    add_vendor?: true
    markings?: true
    part_item_number?: true
    file_year?: true
    file_month?: true
    tab_open?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type QuoteItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteItem to aggregate.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteItems
    **/
    _count?: true | QuoteItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteItemMaxAggregateInputType
  }

  export type GetQuoteItemAggregateType<T extends QuoteItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteItem[P]>
      : GetScalarType<T[P], AggregateQuoteItem[P]>
  }




  export type QuoteItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithAggregationInput | QuoteItemOrderByWithAggregationInput[]
    by: QuoteItemScalarFieldEnum[] | QuoteItemScalarFieldEnum
    having?: QuoteItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteItemCountAggregateInputType | true
    _avg?: QuoteItemAvgAggregateInputType
    _sum?: QuoteItemSumAggregateInputType
    _min?: QuoteItemMinAggregateInputType
    _max?: QuoteItemMaxAggregateInputType
  }

  export type QuoteItemGroupByOutputType = {
    id: string
    quote_id: string
    file_name: string | null
    file_url: string | null
    status: boolean
    quantity: number
    service: string | null
    material: string | null
    finish: string | null
    description: string | null
    process: string | null
    specification: string | null
    price: string | null
    cost: string | null
    cost_shipping_price: string | null
    cost_shipping_total: string | null
    custom_shipping_total: string | null
    buy_price: string | null
    buy_shipping_price: string | null
    buy_shipping_total: string | null
    quantity_owed: string | null
    invoiced: boolean | null
    non_taxable: number | null
    non_shipping: number | null
    is_deleted: boolean | null
    vendor_id: string | null
    vendor_details: string | null
    last_updated_by: number | null
    work_instructions: string | null
    add_vendor: boolean | null
    markings: string | null
    part_item_number: string | null
    file_year: string | null
    file_month: string | null
    tab_open: boolean | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: QuoteItemCountAggregateOutputType | null
    _avg: QuoteItemAvgAggregateOutputType | null
    _sum: QuoteItemSumAggregateOutputType | null
    _min: QuoteItemMinAggregateOutputType | null
    _max: QuoteItemMaxAggregateOutputType | null
  }

  type GetQuoteItemGroupByPayload<T extends QuoteItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteItemGroupByOutputType[P]>
        }
      >
    >


  export type QuoteItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    file_name?: boolean
    file_url?: boolean
    status?: boolean
    quantity?: boolean
    service?: boolean
    material?: boolean
    finish?: boolean
    description?: boolean
    process?: boolean
    specification?: boolean
    price?: boolean
    cost?: boolean
    cost_shipping_price?: boolean
    cost_shipping_total?: boolean
    custom_shipping_total?: boolean
    buy_price?: boolean
    buy_shipping_price?: boolean
    buy_shipping_total?: boolean
    quantity_owed?: boolean
    invoiced?: boolean
    non_taxable?: boolean
    non_shipping?: boolean
    is_deleted?: boolean
    vendor_id?: boolean
    vendor_details?: boolean
    last_updated_by?: boolean
    work_instructions?: boolean
    add_vendor?: boolean
    markings?: boolean
    part_item_number?: boolean
    file_year?: boolean
    file_month?: boolean
    tab_open?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    file_name?: boolean
    file_url?: boolean
    status?: boolean
    quantity?: boolean
    service?: boolean
    material?: boolean
    finish?: boolean
    description?: boolean
    process?: boolean
    specification?: boolean
    price?: boolean
    cost?: boolean
    cost_shipping_price?: boolean
    cost_shipping_total?: boolean
    custom_shipping_total?: boolean
    buy_price?: boolean
    buy_shipping_price?: boolean
    buy_shipping_total?: boolean
    quantity_owed?: boolean
    invoiced?: boolean
    non_taxable?: boolean
    non_shipping?: boolean
    is_deleted?: boolean
    vendor_id?: boolean
    vendor_details?: boolean
    last_updated_by?: boolean
    work_instructions?: boolean
    add_vendor?: boolean
    markings?: boolean
    part_item_number?: boolean
    file_year?: boolean
    file_month?: boolean
    tab_open?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    file_name?: boolean
    file_url?: boolean
    status?: boolean
    quantity?: boolean
    service?: boolean
    material?: boolean
    finish?: boolean
    description?: boolean
    process?: boolean
    specification?: boolean
    price?: boolean
    cost?: boolean
    cost_shipping_price?: boolean
    cost_shipping_total?: boolean
    custom_shipping_total?: boolean
    buy_price?: boolean
    buy_shipping_price?: boolean
    buy_shipping_total?: boolean
    quantity_owed?: boolean
    invoiced?: boolean
    non_taxable?: boolean
    non_shipping?: boolean
    is_deleted?: boolean
    vendor_id?: boolean
    vendor_details?: boolean
    last_updated_by?: boolean
    work_instructions?: boolean
    add_vendor?: boolean
    markings?: boolean
    part_item_number?: boolean
    file_year?: boolean
    file_month?: boolean
    tab_open?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectScalar = {
    id?: boolean
    quote_id?: boolean
    file_name?: boolean
    file_url?: boolean
    status?: boolean
    quantity?: boolean
    service?: boolean
    material?: boolean
    finish?: boolean
    description?: boolean
    process?: boolean
    specification?: boolean
    price?: boolean
    cost?: boolean
    cost_shipping_price?: boolean
    cost_shipping_total?: boolean
    custom_shipping_total?: boolean
    buy_price?: boolean
    buy_shipping_price?: boolean
    buy_shipping_total?: boolean
    quantity_owed?: boolean
    invoiced?: boolean
    non_taxable?: boolean
    non_shipping?: boolean
    is_deleted?: boolean
    vendor_id?: boolean
    vendor_details?: boolean
    last_updated_by?: boolean
    work_instructions?: boolean
    add_vendor?: boolean
    markings?: boolean
    part_item_number?: boolean
    file_year?: boolean
    file_month?: boolean
    tab_open?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type QuoteItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quote_id" | "file_name" | "file_url" | "status" | "quantity" | "service" | "material" | "finish" | "description" | "process" | "specification" | "price" | "cost" | "cost_shipping_price" | "cost_shipping_total" | "custom_shipping_total" | "buy_price" | "buy_shipping_price" | "buy_shipping_total" | "quantity_owed" | "invoiced" | "non_taxable" | "non_shipping" | "is_deleted" | "vendor_id" | "vendor_details" | "last_updated_by" | "work_instructions" | "add_vendor" | "markings" | "part_item_number" | "file_year" | "file_month" | "tab_open" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["quoteItem"]>
  export type QuoteItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuoteItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuoteItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $QuoteItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteItem"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quote_id: string
      file_name: string | null
      file_url: string | null
      status: boolean
      quantity: number
      service: string | null
      material: string | null
      finish: string | null
      description: string | null
      process: string | null
      specification: string | null
      price: string | null
      cost: string | null
      cost_shipping_price: string | null
      cost_shipping_total: string | null
      custom_shipping_total: string | null
      buy_price: string | null
      buy_shipping_price: string | null
      buy_shipping_total: string | null
      quantity_owed: string | null
      invoiced: boolean | null
      non_taxable: number | null
      non_shipping: number | null
      is_deleted: boolean | null
      vendor_id: string | null
      vendor_details: string | null
      last_updated_by: number | null
      work_instructions: string | null
      add_vendor: boolean | null
      markings: string | null
      part_item_number: string | null
      file_year: string | null
      file_month: string | null
      tab_open: boolean | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["quoteItem"]>
    composites: {}
  }

  type QuoteItemGetPayload<S extends boolean | null | undefined | QuoteItemDefaultArgs> = $Result.GetResult<Prisma.$QuoteItemPayload, S>

  type QuoteItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteItemCountAggregateInputType | true
    }

  export interface QuoteItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteItem'], meta: { name: 'QuoteItem' } }
    /**
     * Find zero or one QuoteItem that matches the filter.
     * @param {QuoteItemFindUniqueArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteItemFindUniqueArgs>(args: SelectSubset<T, QuoteItemFindUniqueArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuoteItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteItemFindUniqueOrThrowArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindFirstArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteItemFindFirstArgs>(args?: SelectSubset<T, QuoteItemFindFirstArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindFirstOrThrowArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuoteItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteItems
     * const quoteItems = await prisma.quoteItem.findMany()
     * 
     * // Get first 10 QuoteItems
     * const quoteItems = await prisma.quoteItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteItemFindManyArgs>(args?: SelectSubset<T, QuoteItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuoteItem.
     * @param {QuoteItemCreateArgs} args - Arguments to create a QuoteItem.
     * @example
     * // Create one QuoteItem
     * const QuoteItem = await prisma.quoteItem.create({
     *   data: {
     *     // ... data to create a QuoteItem
     *   }
     * })
     * 
     */
    create<T extends QuoteItemCreateArgs>(args: SelectSubset<T, QuoteItemCreateArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuoteItems.
     * @param {QuoteItemCreateManyArgs} args - Arguments to create many QuoteItems.
     * @example
     * // Create many QuoteItems
     * const quoteItem = await prisma.quoteItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteItemCreateManyArgs>(args?: SelectSubset<T, QuoteItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteItems and returns the data saved in the database.
     * @param {QuoteItemCreateManyAndReturnArgs} args - Arguments to create many QuoteItems.
     * @example
     * // Create many QuoteItems
     * const quoteItem = await prisma.quoteItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteItems and only return the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuoteItem.
     * @param {QuoteItemDeleteArgs} args - Arguments to delete one QuoteItem.
     * @example
     * // Delete one QuoteItem
     * const QuoteItem = await prisma.quoteItem.delete({
     *   where: {
     *     // ... filter to delete one QuoteItem
     *   }
     * })
     * 
     */
    delete<T extends QuoteItemDeleteArgs>(args: SelectSubset<T, QuoteItemDeleteArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuoteItem.
     * @param {QuoteItemUpdateArgs} args - Arguments to update one QuoteItem.
     * @example
     * // Update one QuoteItem
     * const quoteItem = await prisma.quoteItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteItemUpdateArgs>(args: SelectSubset<T, QuoteItemUpdateArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuoteItems.
     * @param {QuoteItemDeleteManyArgs} args - Arguments to filter QuoteItems to delete.
     * @example
     * // Delete a few QuoteItems
     * const { count } = await prisma.quoteItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteItemDeleteManyArgs>(args?: SelectSubset<T, QuoteItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteItems
     * const quoteItem = await prisma.quoteItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteItemUpdateManyArgs>(args: SelectSubset<T, QuoteItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteItems and returns the data updated in the database.
     * @param {QuoteItemUpdateManyAndReturnArgs} args - Arguments to update many QuoteItems.
     * @example
     * // Update many QuoteItems
     * const quoteItem = await prisma.quoteItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuoteItems and only return the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuoteItem.
     * @param {QuoteItemUpsertArgs} args - Arguments to update or create a QuoteItem.
     * @example
     * // Update or create a QuoteItem
     * const quoteItem = await prisma.quoteItem.upsert({
     *   create: {
     *     // ... data to create a QuoteItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteItem we want to update
     *   }
     * })
     */
    upsert<T extends QuoteItemUpsertArgs>(args: SelectSubset<T, QuoteItemUpsertArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemCountArgs} args - Arguments to filter QuoteItems to count.
     * @example
     * // Count the number of QuoteItems
     * const count = await prisma.quoteItem.count({
     *   where: {
     *     // ... the filter for the QuoteItems we want to count
     *   }
     * })
    **/
    count<T extends QuoteItemCountArgs>(
      args?: Subset<T, QuoteItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteItemAggregateArgs>(args: Subset<T, QuoteItemAggregateArgs>): Prisma.PrismaPromise<GetQuoteItemAggregateType<T>>

    /**
     * Group by QuoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteItemGroupByArgs['orderBy'] }
        : { orderBy?: QuoteItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteItem model
   */
  readonly fields: QuoteItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteItem model
   */
  interface QuoteItemFieldRefs {
    readonly id: FieldRef<"QuoteItem", 'String'>
    readonly quote_id: FieldRef<"QuoteItem", 'String'>
    readonly file_name: FieldRef<"QuoteItem", 'String'>
    readonly file_url: FieldRef<"QuoteItem", 'String'>
    readonly status: FieldRef<"QuoteItem", 'Boolean'>
    readonly quantity: FieldRef<"QuoteItem", 'Int'>
    readonly service: FieldRef<"QuoteItem", 'String'>
    readonly material: FieldRef<"QuoteItem", 'String'>
    readonly finish: FieldRef<"QuoteItem", 'String'>
    readonly description: FieldRef<"QuoteItem", 'String'>
    readonly process: FieldRef<"QuoteItem", 'String'>
    readonly specification: FieldRef<"QuoteItem", 'String'>
    readonly price: FieldRef<"QuoteItem", 'String'>
    readonly cost: FieldRef<"QuoteItem", 'String'>
    readonly cost_shipping_price: FieldRef<"QuoteItem", 'String'>
    readonly cost_shipping_total: FieldRef<"QuoteItem", 'String'>
    readonly custom_shipping_total: FieldRef<"QuoteItem", 'String'>
    readonly buy_price: FieldRef<"QuoteItem", 'String'>
    readonly buy_shipping_price: FieldRef<"QuoteItem", 'String'>
    readonly buy_shipping_total: FieldRef<"QuoteItem", 'String'>
    readonly quantity_owed: FieldRef<"QuoteItem", 'String'>
    readonly invoiced: FieldRef<"QuoteItem", 'Boolean'>
    readonly non_taxable: FieldRef<"QuoteItem", 'Int'>
    readonly non_shipping: FieldRef<"QuoteItem", 'Int'>
    readonly is_deleted: FieldRef<"QuoteItem", 'Boolean'>
    readonly vendor_id: FieldRef<"QuoteItem", 'String'>
    readonly vendor_details: FieldRef<"QuoteItem", 'String'>
    readonly last_updated_by: FieldRef<"QuoteItem", 'Int'>
    readonly work_instructions: FieldRef<"QuoteItem", 'String'>
    readonly add_vendor: FieldRef<"QuoteItem", 'Boolean'>
    readonly markings: FieldRef<"QuoteItem", 'String'>
    readonly part_item_number: FieldRef<"QuoteItem", 'String'>
    readonly file_year: FieldRef<"QuoteItem", 'String'>
    readonly file_month: FieldRef<"QuoteItem", 'String'>
    readonly tab_open: FieldRef<"QuoteItem", 'Boolean'>
    readonly created_at: FieldRef<"QuoteItem", 'DateTime'>
    readonly updated_at: FieldRef<"QuoteItem", 'DateTime'>
    readonly deleted_at: FieldRef<"QuoteItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuoteItem findUnique
   */
  export type QuoteItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem findUniqueOrThrow
   */
  export type QuoteItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem findFirst
   */
  export type QuoteItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteItems.
     */
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem findFirstOrThrow
   */
  export type QuoteItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteItems.
     */
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem findMany
   */
  export type QuoteItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItems to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem create
   */
  export type QuoteItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteItem.
     */
    data: XOR<QuoteItemCreateInput, QuoteItemUncheckedCreateInput>
  }

  /**
   * QuoteItem createMany
   */
  export type QuoteItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteItems.
     */
    data: QuoteItemCreateManyInput | QuoteItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteItem createManyAndReturn
   */
  export type QuoteItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * The data used to create many QuoteItems.
     */
    data: QuoteItemCreateManyInput | QuoteItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteItem update
   */
  export type QuoteItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteItem.
     */
    data: XOR<QuoteItemUpdateInput, QuoteItemUncheckedUpdateInput>
    /**
     * Choose, which QuoteItem to update.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem updateMany
   */
  export type QuoteItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteItems.
     */
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteItems to update
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to update.
     */
    limit?: number
  }

  /**
   * QuoteItem updateManyAndReturn
   */
  export type QuoteItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * The data used to update QuoteItems.
     */
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteItems to update
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteItem upsert
   */
  export type QuoteItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteItem to update in case it exists.
     */
    where: QuoteItemWhereUniqueInput
    /**
     * In case the QuoteItem found by the `where` argument doesn't exist, create a new QuoteItem with this data.
     */
    create: XOR<QuoteItemCreateInput, QuoteItemUncheckedCreateInput>
    /**
     * In case the QuoteItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteItemUpdateInput, QuoteItemUncheckedUpdateInput>
  }

  /**
   * QuoteItem delete
   */
  export type QuoteItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter which QuoteItem to delete.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem deleteMany
   */
  export type QuoteItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteItems to delete
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to delete.
     */
    limit?: number
  }

  /**
   * QuoteItem without action
   */
  export type QuoteItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetOTP
   */

  export type AggregatePasswordResetOTP = {
    _count: PasswordResetOTPCountAggregateOutputType | null
    _min: PasswordResetOTPMinAggregateOutputType | null
    _max: PasswordResetOTPMaxAggregateOutputType | null
  }

  export type PasswordResetOTPMinAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    request_id: string | null
    expires_at: Date | null
    created_at: Date | null
    user_id: string | null
  }

  export type PasswordResetOTPMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    request_id: string | null
    expires_at: Date | null
    created_at: Date | null
    user_id: string | null
  }

  export type PasswordResetOTPCountAggregateOutputType = {
    id: number
    email: number
    otp: number
    request_id: number
    expires_at: number
    created_at: number
    user_id: number
    _all: number
  }


  export type PasswordResetOTPMinAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    request_id?: true
    expires_at?: true
    created_at?: true
    user_id?: true
  }

  export type PasswordResetOTPMaxAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    request_id?: true
    expires_at?: true
    created_at?: true
    user_id?: true
  }

  export type PasswordResetOTPCountAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    request_id?: true
    expires_at?: true
    created_at?: true
    user_id?: true
    _all?: true
  }

  export type PasswordResetOTPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetOTP to aggregate.
     */
    where?: PasswordResetOTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetOTPS to fetch.
     */
    orderBy?: PasswordResetOTPOrderByWithRelationInput | PasswordResetOTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetOTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetOTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetOTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetOTPS
    **/
    _count?: true | PasswordResetOTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetOTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetOTPMaxAggregateInputType
  }

  export type GetPasswordResetOTPAggregateType<T extends PasswordResetOTPAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetOTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetOTP[P]>
      : GetScalarType<T[P], AggregatePasswordResetOTP[P]>
  }




  export type PasswordResetOTPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetOTPWhereInput
    orderBy?: PasswordResetOTPOrderByWithAggregationInput | PasswordResetOTPOrderByWithAggregationInput[]
    by: PasswordResetOTPScalarFieldEnum[] | PasswordResetOTPScalarFieldEnum
    having?: PasswordResetOTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetOTPCountAggregateInputType | true
    _min?: PasswordResetOTPMinAggregateInputType
    _max?: PasswordResetOTPMaxAggregateInputType
  }

  export type PasswordResetOTPGroupByOutputType = {
    id: string
    email: string
    otp: string
    request_id: string
    expires_at: Date
    created_at: Date
    user_id: string
    _count: PasswordResetOTPCountAggregateOutputType | null
    _min: PasswordResetOTPMinAggregateOutputType | null
    _max: PasswordResetOTPMaxAggregateOutputType | null
  }

  type GetPasswordResetOTPGroupByPayload<T extends PasswordResetOTPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetOTPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetOTPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetOTPGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetOTPGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetOTPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    request_id?: boolean
    expires_at?: boolean
    created_at?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetOTP"]>

  export type PasswordResetOTPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    request_id?: boolean
    expires_at?: boolean
    created_at?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetOTP"]>

  export type PasswordResetOTPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    request_id?: boolean
    expires_at?: boolean
    created_at?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetOTP"]>

  export type PasswordResetOTPSelectScalar = {
    id?: boolean
    email?: boolean
    otp?: boolean
    request_id?: boolean
    expires_at?: boolean
    created_at?: boolean
    user_id?: boolean
  }

  export type PasswordResetOTPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otp" | "request_id" | "expires_at" | "created_at" | "user_id", ExtArgs["result"]["passwordResetOTP"]>
  export type PasswordResetOTPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetOTPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetOTPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetOTPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetOTP"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otp: string
      request_id: string
      expires_at: Date
      created_at: Date
      user_id: string
    }, ExtArgs["result"]["passwordResetOTP"]>
    composites: {}
  }

  type PasswordResetOTPGetPayload<S extends boolean | null | undefined | PasswordResetOTPDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetOTPPayload, S>

  type PasswordResetOTPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetOTPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetOTPCountAggregateInputType | true
    }

  export interface PasswordResetOTPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetOTP'], meta: { name: 'PasswordResetOTP' } }
    /**
     * Find zero or one PasswordResetOTP that matches the filter.
     * @param {PasswordResetOTPFindUniqueArgs} args - Arguments to find a PasswordResetOTP
     * @example
     * // Get one PasswordResetOTP
     * const passwordResetOTP = await prisma.passwordResetOTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetOTPFindUniqueArgs>(args: SelectSubset<T, PasswordResetOTPFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetOTPClient<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetOTP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetOTPFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetOTP
     * @example
     * // Get one PasswordResetOTP
     * const passwordResetOTP = await prisma.passwordResetOTP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetOTPFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetOTPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetOTPClient<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetOTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetOTPFindFirstArgs} args - Arguments to find a PasswordResetOTP
     * @example
     * // Get one PasswordResetOTP
     * const passwordResetOTP = await prisma.passwordResetOTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetOTPFindFirstArgs>(args?: SelectSubset<T, PasswordResetOTPFindFirstArgs<ExtArgs>>): Prisma__PasswordResetOTPClient<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetOTP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetOTPFindFirstOrThrowArgs} args - Arguments to find a PasswordResetOTP
     * @example
     * // Get one PasswordResetOTP
     * const passwordResetOTP = await prisma.passwordResetOTP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetOTPFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetOTPFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetOTPClient<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetOTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetOTPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetOTPS
     * const passwordResetOTPS = await prisma.passwordResetOTP.findMany()
     * 
     * // Get first 10 PasswordResetOTPS
     * const passwordResetOTPS = await prisma.passwordResetOTP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetOTPWithIdOnly = await prisma.passwordResetOTP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetOTPFindManyArgs>(args?: SelectSubset<T, PasswordResetOTPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetOTP.
     * @param {PasswordResetOTPCreateArgs} args - Arguments to create a PasswordResetOTP.
     * @example
     * // Create one PasswordResetOTP
     * const PasswordResetOTP = await prisma.passwordResetOTP.create({
     *   data: {
     *     // ... data to create a PasswordResetOTP
     *   }
     * })
     * 
     */
    create<T extends PasswordResetOTPCreateArgs>(args: SelectSubset<T, PasswordResetOTPCreateArgs<ExtArgs>>): Prisma__PasswordResetOTPClient<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetOTPS.
     * @param {PasswordResetOTPCreateManyArgs} args - Arguments to create many PasswordResetOTPS.
     * @example
     * // Create many PasswordResetOTPS
     * const passwordResetOTP = await prisma.passwordResetOTP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetOTPCreateManyArgs>(args?: SelectSubset<T, PasswordResetOTPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetOTPS and returns the data saved in the database.
     * @param {PasswordResetOTPCreateManyAndReturnArgs} args - Arguments to create many PasswordResetOTPS.
     * @example
     * // Create many PasswordResetOTPS
     * const passwordResetOTP = await prisma.passwordResetOTP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetOTPS and only return the `id`
     * const passwordResetOTPWithIdOnly = await prisma.passwordResetOTP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetOTPCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetOTPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetOTP.
     * @param {PasswordResetOTPDeleteArgs} args - Arguments to delete one PasswordResetOTP.
     * @example
     * // Delete one PasswordResetOTP
     * const PasswordResetOTP = await prisma.passwordResetOTP.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetOTP
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetOTPDeleteArgs>(args: SelectSubset<T, PasswordResetOTPDeleteArgs<ExtArgs>>): Prisma__PasswordResetOTPClient<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetOTP.
     * @param {PasswordResetOTPUpdateArgs} args - Arguments to update one PasswordResetOTP.
     * @example
     * // Update one PasswordResetOTP
     * const passwordResetOTP = await prisma.passwordResetOTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetOTPUpdateArgs>(args: SelectSubset<T, PasswordResetOTPUpdateArgs<ExtArgs>>): Prisma__PasswordResetOTPClient<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetOTPS.
     * @param {PasswordResetOTPDeleteManyArgs} args - Arguments to filter PasswordResetOTPS to delete.
     * @example
     * // Delete a few PasswordResetOTPS
     * const { count } = await prisma.passwordResetOTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetOTPDeleteManyArgs>(args?: SelectSubset<T, PasswordResetOTPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetOTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetOTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetOTPS
     * const passwordResetOTP = await prisma.passwordResetOTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetOTPUpdateManyArgs>(args: SelectSubset<T, PasswordResetOTPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetOTPS and returns the data updated in the database.
     * @param {PasswordResetOTPUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetOTPS.
     * @example
     * // Update many PasswordResetOTPS
     * const passwordResetOTP = await prisma.passwordResetOTP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetOTPS and only return the `id`
     * const passwordResetOTPWithIdOnly = await prisma.passwordResetOTP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetOTPUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetOTPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetOTP.
     * @param {PasswordResetOTPUpsertArgs} args - Arguments to update or create a PasswordResetOTP.
     * @example
     * // Update or create a PasswordResetOTP
     * const passwordResetOTP = await prisma.passwordResetOTP.upsert({
     *   create: {
     *     // ... data to create a PasswordResetOTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetOTP we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetOTPUpsertArgs>(args: SelectSubset<T, PasswordResetOTPUpsertArgs<ExtArgs>>): Prisma__PasswordResetOTPClient<$Result.GetResult<Prisma.$PasswordResetOTPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetOTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetOTPCountArgs} args - Arguments to filter PasswordResetOTPS to count.
     * @example
     * // Count the number of PasswordResetOTPS
     * const count = await prisma.passwordResetOTP.count({
     *   where: {
     *     // ... the filter for the PasswordResetOTPS we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetOTPCountArgs>(
      args?: Subset<T, PasswordResetOTPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetOTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetOTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetOTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetOTPAggregateArgs>(args: Subset<T, PasswordResetOTPAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetOTPAggregateType<T>>

    /**
     * Group by PasswordResetOTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetOTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetOTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetOTPGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetOTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetOTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetOTPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetOTP model
   */
  readonly fields: PasswordResetOTPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetOTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetOTPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetOTP model
   */
  interface PasswordResetOTPFieldRefs {
    readonly id: FieldRef<"PasswordResetOTP", 'String'>
    readonly email: FieldRef<"PasswordResetOTP", 'String'>
    readonly otp: FieldRef<"PasswordResetOTP", 'String'>
    readonly request_id: FieldRef<"PasswordResetOTP", 'String'>
    readonly expires_at: FieldRef<"PasswordResetOTP", 'DateTime'>
    readonly created_at: FieldRef<"PasswordResetOTP", 'DateTime'>
    readonly user_id: FieldRef<"PasswordResetOTP", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetOTP findUnique
   */
  export type PasswordResetOTPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetOTP to fetch.
     */
    where: PasswordResetOTPWhereUniqueInput
  }

  /**
   * PasswordResetOTP findUniqueOrThrow
   */
  export type PasswordResetOTPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetOTP to fetch.
     */
    where: PasswordResetOTPWhereUniqueInput
  }

  /**
   * PasswordResetOTP findFirst
   */
  export type PasswordResetOTPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetOTP to fetch.
     */
    where?: PasswordResetOTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetOTPS to fetch.
     */
    orderBy?: PasswordResetOTPOrderByWithRelationInput | PasswordResetOTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetOTPS.
     */
    cursor?: PasswordResetOTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetOTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetOTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetOTPS.
     */
    distinct?: PasswordResetOTPScalarFieldEnum | PasswordResetOTPScalarFieldEnum[]
  }

  /**
   * PasswordResetOTP findFirstOrThrow
   */
  export type PasswordResetOTPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetOTP to fetch.
     */
    where?: PasswordResetOTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetOTPS to fetch.
     */
    orderBy?: PasswordResetOTPOrderByWithRelationInput | PasswordResetOTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetOTPS.
     */
    cursor?: PasswordResetOTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetOTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetOTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetOTPS.
     */
    distinct?: PasswordResetOTPScalarFieldEnum | PasswordResetOTPScalarFieldEnum[]
  }

  /**
   * PasswordResetOTP findMany
   */
  export type PasswordResetOTPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetOTPS to fetch.
     */
    where?: PasswordResetOTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetOTPS to fetch.
     */
    orderBy?: PasswordResetOTPOrderByWithRelationInput | PasswordResetOTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetOTPS.
     */
    cursor?: PasswordResetOTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetOTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetOTPS.
     */
    skip?: number
    distinct?: PasswordResetOTPScalarFieldEnum | PasswordResetOTPScalarFieldEnum[]
  }

  /**
   * PasswordResetOTP create
   */
  export type PasswordResetOTPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetOTP.
     */
    data: XOR<PasswordResetOTPCreateInput, PasswordResetOTPUncheckedCreateInput>
  }

  /**
   * PasswordResetOTP createMany
   */
  export type PasswordResetOTPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetOTPS.
     */
    data: PasswordResetOTPCreateManyInput | PasswordResetOTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetOTP createManyAndReturn
   */
  export type PasswordResetOTPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetOTPS.
     */
    data: PasswordResetOTPCreateManyInput | PasswordResetOTPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetOTP update
   */
  export type PasswordResetOTPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetOTP.
     */
    data: XOR<PasswordResetOTPUpdateInput, PasswordResetOTPUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetOTP to update.
     */
    where: PasswordResetOTPWhereUniqueInput
  }

  /**
   * PasswordResetOTP updateMany
   */
  export type PasswordResetOTPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetOTPS.
     */
    data: XOR<PasswordResetOTPUpdateManyMutationInput, PasswordResetOTPUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetOTPS to update
     */
    where?: PasswordResetOTPWhereInput
    /**
     * Limit how many PasswordResetOTPS to update.
     */
    limit?: number
  }

  /**
   * PasswordResetOTP updateManyAndReturn
   */
  export type PasswordResetOTPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetOTPS.
     */
    data: XOR<PasswordResetOTPUpdateManyMutationInput, PasswordResetOTPUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetOTPS to update
     */
    where?: PasswordResetOTPWhereInput
    /**
     * Limit how many PasswordResetOTPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetOTP upsert
   */
  export type PasswordResetOTPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetOTP to update in case it exists.
     */
    where: PasswordResetOTPWhereUniqueInput
    /**
     * In case the PasswordResetOTP found by the `where` argument doesn't exist, create a new PasswordResetOTP with this data.
     */
    create: XOR<PasswordResetOTPCreateInput, PasswordResetOTPUncheckedCreateInput>
    /**
     * In case the PasswordResetOTP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetOTPUpdateInput, PasswordResetOTPUncheckedUpdateInput>
  }

  /**
   * PasswordResetOTP delete
   */
  export type PasswordResetOTPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetOTP to delete.
     */
    where: PasswordResetOTPWhereUniqueInput
  }

  /**
   * PasswordResetOTP deleteMany
   */
  export type PasswordResetOTPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetOTPS to delete
     */
    where?: PasswordResetOTPWhereInput
    /**
     * Limit how many PasswordResetOTPS to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetOTP without action
   */
  export type PasswordResetOTPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetOTP
     */
    select?: PasswordResetOTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetOTP
     */
    omit?: PasswordResetOTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetOTPInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    token: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    token: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    user_id: number
    token: number
    expires_at: number
    created_at: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    user_id: string
    token: string
    expires_at: Date
    created_at: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token" | "expires_at" | "created_at", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      token: string
      expires_at: Date
      created_at: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly user_id: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires_at: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly created_at: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model tenantCurrency
   */

  export type AggregateTenantCurrency = {
    _count: TenantCurrencyCountAggregateOutputType | null
    _avg: TenantCurrencyAvgAggregateOutputType | null
    _sum: TenantCurrencySumAggregateOutputType | null
    _min: TenantCurrencyMinAggregateOutputType | null
    _max: TenantCurrencyMaxAggregateOutputType | null
  }

  export type TenantCurrencyAvgAggregateOutputType = {
    currency_id: number | null
  }

  export type TenantCurrencySumAggregateOutputType = {
    currency_id: number | null
  }

  export type TenantCurrencyMinAggregateOutputType = {
    id: string | null
    currency_id: number | null
    code: string | null
    name: string | null
    symbol: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantCurrencyMaxAggregateOutputType = {
    id: string | null
    currency_id: number | null
    code: string | null
    name: string | null
    symbol: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantCurrencyCountAggregateOutputType = {
    id: number
    currency_id: number
    code: number
    name: number
    symbol: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantCurrencyAvgAggregateInputType = {
    currency_id?: true
  }

  export type TenantCurrencySumAggregateInputType = {
    currency_id?: true
  }

  export type TenantCurrencyMinAggregateInputType = {
    id?: true
    currency_id?: true
    code?: true
    name?: true
    symbol?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantCurrencyMaxAggregateInputType = {
    id?: true
    currency_id?: true
    code?: true
    name?: true
    symbol?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantCurrencyCountAggregateInputType = {
    id?: true
    currency_id?: true
    code?: true
    name?: true
    symbol?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantCurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantCurrency to aggregate.
     */
    where?: tenantCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantCurrencies to fetch.
     */
    orderBy?: tenantCurrencyOrderByWithRelationInput | tenantCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenantCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenantCurrencies
    **/
    _count?: true | TenantCurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantCurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantCurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantCurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantCurrencyMaxAggregateInputType
  }

  export type GetTenantCurrencyAggregateType<T extends TenantCurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantCurrency[P]>
      : GetScalarType<T[P], AggregateTenantCurrency[P]>
  }




  export type tenantCurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenantCurrencyWhereInput
    orderBy?: tenantCurrencyOrderByWithAggregationInput | tenantCurrencyOrderByWithAggregationInput[]
    by: TenantCurrencyScalarFieldEnum[] | TenantCurrencyScalarFieldEnum
    having?: tenantCurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCurrencyCountAggregateInputType | true
    _avg?: TenantCurrencyAvgAggregateInputType
    _sum?: TenantCurrencySumAggregateInputType
    _min?: TenantCurrencyMinAggregateInputType
    _max?: TenantCurrencyMaxAggregateInputType
  }

  export type TenantCurrencyGroupByOutputType = {
    id: string
    currency_id: number
    code: string
    name: string
    symbol: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantCurrencyCountAggregateOutputType | null
    _avg: TenantCurrencyAvgAggregateOutputType | null
    _sum: TenantCurrencySumAggregateOutputType | null
    _min: TenantCurrencyMinAggregateOutputType | null
    _max: TenantCurrencyMaxAggregateOutputType | null
  }

  type GetTenantCurrencyGroupByPayload<T extends tenantCurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantCurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantCurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantCurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], TenantCurrencyGroupByOutputType[P]>
        }
      >
    >


  export type tenantCurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency_id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantCurrency"]>

  export type tenantCurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency_id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantCurrency"]>

  export type tenantCurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency_id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantCurrency"]>

  export type tenantCurrencySelectScalar = {
    id?: boolean
    currency_id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tenantCurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currency_id" | "code" | "name" | "symbol" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenantCurrency"]>

  export type $tenantCurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenantCurrency"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      currency_id: number
      code: string
      name: string
      symbol: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenantCurrency"]>
    composites: {}
  }

  type tenantCurrencyGetPayload<S extends boolean | null | undefined | tenantCurrencyDefaultArgs> = $Result.GetResult<Prisma.$tenantCurrencyPayload, S>

  type tenantCurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tenantCurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCurrencyCountAggregateInputType | true
    }

  export interface tenantCurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenantCurrency'], meta: { name: 'tenantCurrency' } }
    /**
     * Find zero or one TenantCurrency that matches the filter.
     * @param {tenantCurrencyFindUniqueArgs} args - Arguments to find a TenantCurrency
     * @example
     * // Get one TenantCurrency
     * const tenantCurrency = await prisma.tenantCurrency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenantCurrencyFindUniqueArgs>(args: SelectSubset<T, tenantCurrencyFindUniqueArgs<ExtArgs>>): Prisma__tenantCurrencyClient<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantCurrency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tenantCurrencyFindUniqueOrThrowArgs} args - Arguments to find a TenantCurrency
     * @example
     * // Get one TenantCurrency
     * const tenantCurrency = await prisma.tenantCurrency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenantCurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, tenantCurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenantCurrencyClient<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantCurrency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantCurrencyFindFirstArgs} args - Arguments to find a TenantCurrency
     * @example
     * // Get one TenantCurrency
     * const tenantCurrency = await prisma.tenantCurrency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenantCurrencyFindFirstArgs>(args?: SelectSubset<T, tenantCurrencyFindFirstArgs<ExtArgs>>): Prisma__tenantCurrencyClient<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantCurrency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantCurrencyFindFirstOrThrowArgs} args - Arguments to find a TenantCurrency
     * @example
     * // Get one TenantCurrency
     * const tenantCurrency = await prisma.tenantCurrency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenantCurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, tenantCurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenantCurrencyClient<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantCurrencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantCurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantCurrencies
     * const tenantCurrencies = await prisma.tenantCurrency.findMany()
     * 
     * // Get first 10 TenantCurrencies
     * const tenantCurrencies = await prisma.tenantCurrency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantCurrencyWithIdOnly = await prisma.tenantCurrency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenantCurrencyFindManyArgs>(args?: SelectSubset<T, tenantCurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantCurrency.
     * @param {tenantCurrencyCreateArgs} args - Arguments to create a TenantCurrency.
     * @example
     * // Create one TenantCurrency
     * const TenantCurrency = await prisma.tenantCurrency.create({
     *   data: {
     *     // ... data to create a TenantCurrency
     *   }
     * })
     * 
     */
    create<T extends tenantCurrencyCreateArgs>(args: SelectSubset<T, tenantCurrencyCreateArgs<ExtArgs>>): Prisma__tenantCurrencyClient<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantCurrencies.
     * @param {tenantCurrencyCreateManyArgs} args - Arguments to create many TenantCurrencies.
     * @example
     * // Create many TenantCurrencies
     * const tenantCurrency = await prisma.tenantCurrency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenantCurrencyCreateManyArgs>(args?: SelectSubset<T, tenantCurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantCurrencies and returns the data saved in the database.
     * @param {tenantCurrencyCreateManyAndReturnArgs} args - Arguments to create many TenantCurrencies.
     * @example
     * // Create many TenantCurrencies
     * const tenantCurrency = await prisma.tenantCurrency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantCurrencies and only return the `id`
     * const tenantCurrencyWithIdOnly = await prisma.tenantCurrency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenantCurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, tenantCurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantCurrency.
     * @param {tenantCurrencyDeleteArgs} args - Arguments to delete one TenantCurrency.
     * @example
     * // Delete one TenantCurrency
     * const TenantCurrency = await prisma.tenantCurrency.delete({
     *   where: {
     *     // ... filter to delete one TenantCurrency
     *   }
     * })
     * 
     */
    delete<T extends tenantCurrencyDeleteArgs>(args: SelectSubset<T, tenantCurrencyDeleteArgs<ExtArgs>>): Prisma__tenantCurrencyClient<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantCurrency.
     * @param {tenantCurrencyUpdateArgs} args - Arguments to update one TenantCurrency.
     * @example
     * // Update one TenantCurrency
     * const tenantCurrency = await prisma.tenantCurrency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenantCurrencyUpdateArgs>(args: SelectSubset<T, tenantCurrencyUpdateArgs<ExtArgs>>): Prisma__tenantCurrencyClient<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantCurrencies.
     * @param {tenantCurrencyDeleteManyArgs} args - Arguments to filter TenantCurrencies to delete.
     * @example
     * // Delete a few TenantCurrencies
     * const { count } = await prisma.tenantCurrency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenantCurrencyDeleteManyArgs>(args?: SelectSubset<T, tenantCurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantCurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantCurrencies
     * const tenantCurrency = await prisma.tenantCurrency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenantCurrencyUpdateManyArgs>(args: SelectSubset<T, tenantCurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantCurrencies and returns the data updated in the database.
     * @param {tenantCurrencyUpdateManyAndReturnArgs} args - Arguments to update many TenantCurrencies.
     * @example
     * // Update many TenantCurrencies
     * const tenantCurrency = await prisma.tenantCurrency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantCurrencies and only return the `id`
     * const tenantCurrencyWithIdOnly = await prisma.tenantCurrency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tenantCurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, tenantCurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantCurrency.
     * @param {tenantCurrencyUpsertArgs} args - Arguments to update or create a TenantCurrency.
     * @example
     * // Update or create a TenantCurrency
     * const tenantCurrency = await prisma.tenantCurrency.upsert({
     *   create: {
     *     // ... data to create a TenantCurrency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantCurrency we want to update
     *   }
     * })
     */
    upsert<T extends tenantCurrencyUpsertArgs>(args: SelectSubset<T, tenantCurrencyUpsertArgs<ExtArgs>>): Prisma__tenantCurrencyClient<$Result.GetResult<Prisma.$tenantCurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantCurrencyCountArgs} args - Arguments to filter TenantCurrencies to count.
     * @example
     * // Count the number of TenantCurrencies
     * const count = await prisma.tenantCurrency.count({
     *   where: {
     *     // ... the filter for the TenantCurrencies we want to count
     *   }
     * })
    **/
    count<T extends tenantCurrencyCountArgs>(
      args?: Subset<T, tenantCurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantCurrencyAggregateArgs>(args: Subset<T, TenantCurrencyAggregateArgs>): Prisma.PrismaPromise<GetTenantCurrencyAggregateType<T>>

    /**
     * Group by TenantCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantCurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenantCurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenantCurrencyGroupByArgs['orderBy'] }
        : { orderBy?: tenantCurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenantCurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenantCurrency model
   */
  readonly fields: tenantCurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenantCurrency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenantCurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenantCurrency model
   */
  interface tenantCurrencyFieldRefs {
    readonly id: FieldRef<"tenantCurrency", 'String'>
    readonly currency_id: FieldRef<"tenantCurrency", 'Int'>
    readonly code: FieldRef<"tenantCurrency", 'String'>
    readonly name: FieldRef<"tenantCurrency", 'String'>
    readonly symbol: FieldRef<"tenantCurrency", 'String'>
    readonly is_active: FieldRef<"tenantCurrency", 'Boolean'>
    readonly created_at: FieldRef<"tenantCurrency", 'DateTime'>
    readonly updated_at: FieldRef<"tenantCurrency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tenantCurrency findUnique
   */
  export type tenantCurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * Filter, which tenantCurrency to fetch.
     */
    where: tenantCurrencyWhereUniqueInput
  }

  /**
   * tenantCurrency findUniqueOrThrow
   */
  export type tenantCurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * Filter, which tenantCurrency to fetch.
     */
    where: tenantCurrencyWhereUniqueInput
  }

  /**
   * tenantCurrency findFirst
   */
  export type tenantCurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * Filter, which tenantCurrency to fetch.
     */
    where?: tenantCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantCurrencies to fetch.
     */
    orderBy?: tenantCurrencyOrderByWithRelationInput | tenantCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantCurrencies.
     */
    cursor?: tenantCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantCurrencies.
     */
    distinct?: TenantCurrencyScalarFieldEnum | TenantCurrencyScalarFieldEnum[]
  }

  /**
   * tenantCurrency findFirstOrThrow
   */
  export type tenantCurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * Filter, which tenantCurrency to fetch.
     */
    where?: tenantCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantCurrencies to fetch.
     */
    orderBy?: tenantCurrencyOrderByWithRelationInput | tenantCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantCurrencies.
     */
    cursor?: tenantCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantCurrencies.
     */
    distinct?: TenantCurrencyScalarFieldEnum | TenantCurrencyScalarFieldEnum[]
  }

  /**
   * tenantCurrency findMany
   */
  export type tenantCurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * Filter, which tenantCurrencies to fetch.
     */
    where?: tenantCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantCurrencies to fetch.
     */
    orderBy?: tenantCurrencyOrderByWithRelationInput | tenantCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenantCurrencies.
     */
    cursor?: tenantCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantCurrencies.
     */
    skip?: number
    distinct?: TenantCurrencyScalarFieldEnum | TenantCurrencyScalarFieldEnum[]
  }

  /**
   * tenantCurrency create
   */
  export type tenantCurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * The data needed to create a tenantCurrency.
     */
    data: XOR<tenantCurrencyCreateInput, tenantCurrencyUncheckedCreateInput>
  }

  /**
   * tenantCurrency createMany
   */
  export type tenantCurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenantCurrencies.
     */
    data: tenantCurrencyCreateManyInput | tenantCurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantCurrency createManyAndReturn
   */
  export type tenantCurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many tenantCurrencies.
     */
    data: tenantCurrencyCreateManyInput | tenantCurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantCurrency update
   */
  export type tenantCurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * The data needed to update a tenantCurrency.
     */
    data: XOR<tenantCurrencyUpdateInput, tenantCurrencyUncheckedUpdateInput>
    /**
     * Choose, which tenantCurrency to update.
     */
    where: tenantCurrencyWhereUniqueInput
  }

  /**
   * tenantCurrency updateMany
   */
  export type tenantCurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenantCurrencies.
     */
    data: XOR<tenantCurrencyUpdateManyMutationInput, tenantCurrencyUncheckedUpdateManyInput>
    /**
     * Filter which tenantCurrencies to update
     */
    where?: tenantCurrencyWhereInput
    /**
     * Limit how many tenantCurrencies to update.
     */
    limit?: number
  }

  /**
   * tenantCurrency updateManyAndReturn
   */
  export type tenantCurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * The data used to update tenantCurrencies.
     */
    data: XOR<tenantCurrencyUpdateManyMutationInput, tenantCurrencyUncheckedUpdateManyInput>
    /**
     * Filter which tenantCurrencies to update
     */
    where?: tenantCurrencyWhereInput
    /**
     * Limit how many tenantCurrencies to update.
     */
    limit?: number
  }

  /**
   * tenantCurrency upsert
   */
  export type tenantCurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * The filter to search for the tenantCurrency to update in case it exists.
     */
    where: tenantCurrencyWhereUniqueInput
    /**
     * In case the tenantCurrency found by the `where` argument doesn't exist, create a new tenantCurrency with this data.
     */
    create: XOR<tenantCurrencyCreateInput, tenantCurrencyUncheckedCreateInput>
    /**
     * In case the tenantCurrency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenantCurrencyUpdateInput, tenantCurrencyUncheckedUpdateInput>
  }

  /**
   * tenantCurrency delete
   */
  export type tenantCurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
    /**
     * Filter which tenantCurrency to delete.
     */
    where: tenantCurrencyWhereUniqueInput
  }

  /**
   * tenantCurrency deleteMany
   */
  export type tenantCurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantCurrencies to delete
     */
    where?: tenantCurrencyWhereInput
    /**
     * Limit how many tenantCurrencies to delete.
     */
    limit?: number
  }

  /**
   * tenantCurrency without action
   */
  export type tenantCurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantCurrency
     */
    select?: tenantCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantCurrency
     */
    omit?: tenantCurrencyOmit<ExtArgs> | null
  }


  /**
   * Model tenantPaymentTerms
   */

  export type AggregateTenantPaymentTerms = {
    _count: TenantPaymentTermsCountAggregateOutputType | null
    _avg: TenantPaymentTermsAvgAggregateOutputType | null
    _sum: TenantPaymentTermsSumAggregateOutputType | null
    _min: TenantPaymentTermsMinAggregateOutputType | null
    _max: TenantPaymentTermsMaxAggregateOutputType | null
  }

  export type TenantPaymentTermsAvgAggregateOutputType = {
    payment_terms_id: number | null
    due_days: number | null
    discount_days: number | null
    discount_percent: Decimal | null
  }

  export type TenantPaymentTermsSumAggregateOutputType = {
    payment_terms_id: number | null
    due_days: number | null
    discount_days: number | null
    discount_percent: Decimal | null
  }

  export type TenantPaymentTermsMinAggregateOutputType = {
    id: string | null
    payment_terms_id: number | null
    name: string | null
    description: string | null
    due_days: number | null
    discount_days: number | null
    discount_percent: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantPaymentTermsMaxAggregateOutputType = {
    id: string | null
    payment_terms_id: number | null
    name: string | null
    description: string | null
    due_days: number | null
    discount_days: number | null
    discount_percent: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantPaymentTermsCountAggregateOutputType = {
    id: number
    payment_terms_id: number
    name: number
    description: number
    due_days: number
    discount_days: number
    discount_percent: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantPaymentTermsAvgAggregateInputType = {
    payment_terms_id?: true
    due_days?: true
    discount_days?: true
    discount_percent?: true
  }

  export type TenantPaymentTermsSumAggregateInputType = {
    payment_terms_id?: true
    due_days?: true
    discount_days?: true
    discount_percent?: true
  }

  export type TenantPaymentTermsMinAggregateInputType = {
    id?: true
    payment_terms_id?: true
    name?: true
    description?: true
    due_days?: true
    discount_days?: true
    discount_percent?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantPaymentTermsMaxAggregateInputType = {
    id?: true
    payment_terms_id?: true
    name?: true
    description?: true
    due_days?: true
    discount_days?: true
    discount_percent?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantPaymentTermsCountAggregateInputType = {
    id?: true
    payment_terms_id?: true
    name?: true
    description?: true
    due_days?: true
    discount_days?: true
    discount_percent?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantPaymentTermsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantPaymentTerms to aggregate.
     */
    where?: tenantPaymentTermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantPaymentTerms to fetch.
     */
    orderBy?: tenantPaymentTermsOrderByWithRelationInput | tenantPaymentTermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenantPaymentTermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantPaymentTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantPaymentTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenantPaymentTerms
    **/
    _count?: true | TenantPaymentTermsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantPaymentTermsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantPaymentTermsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantPaymentTermsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantPaymentTermsMaxAggregateInputType
  }

  export type GetTenantPaymentTermsAggregateType<T extends TenantPaymentTermsAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantPaymentTerms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantPaymentTerms[P]>
      : GetScalarType<T[P], AggregateTenantPaymentTerms[P]>
  }




  export type tenantPaymentTermsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenantPaymentTermsWhereInput
    orderBy?: tenantPaymentTermsOrderByWithAggregationInput | tenantPaymentTermsOrderByWithAggregationInput[]
    by: TenantPaymentTermsScalarFieldEnum[] | TenantPaymentTermsScalarFieldEnum
    having?: tenantPaymentTermsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantPaymentTermsCountAggregateInputType | true
    _avg?: TenantPaymentTermsAvgAggregateInputType
    _sum?: TenantPaymentTermsSumAggregateInputType
    _min?: TenantPaymentTermsMinAggregateInputType
    _max?: TenantPaymentTermsMaxAggregateInputType
  }

  export type TenantPaymentTermsGroupByOutputType = {
    id: string
    payment_terms_id: number
    name: string
    description: string | null
    due_days: number
    discount_days: number
    discount_percent: Decimal
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantPaymentTermsCountAggregateOutputType | null
    _avg: TenantPaymentTermsAvgAggregateOutputType | null
    _sum: TenantPaymentTermsSumAggregateOutputType | null
    _min: TenantPaymentTermsMinAggregateOutputType | null
    _max: TenantPaymentTermsMaxAggregateOutputType | null
  }

  type GetTenantPaymentTermsGroupByPayload<T extends tenantPaymentTermsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantPaymentTermsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantPaymentTermsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantPaymentTermsGroupByOutputType[P]>
            : GetScalarType<T[P], TenantPaymentTermsGroupByOutputType[P]>
        }
      >
    >


  export type tenantPaymentTermsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_terms_id?: boolean
    name?: boolean
    description?: boolean
    due_days?: boolean
    discount_days?: boolean
    discount_percent?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantPaymentTerms"]>

  export type tenantPaymentTermsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_terms_id?: boolean
    name?: boolean
    description?: boolean
    due_days?: boolean
    discount_days?: boolean
    discount_percent?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantPaymentTerms"]>

  export type tenantPaymentTermsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_terms_id?: boolean
    name?: boolean
    description?: boolean
    due_days?: boolean
    discount_days?: boolean
    discount_percent?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantPaymentTerms"]>

  export type tenantPaymentTermsSelectScalar = {
    id?: boolean
    payment_terms_id?: boolean
    name?: boolean
    description?: boolean
    due_days?: boolean
    discount_days?: boolean
    discount_percent?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tenantPaymentTermsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "payment_terms_id" | "name" | "description" | "due_days" | "discount_days" | "discount_percent" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenantPaymentTerms"]>

  export type $tenantPaymentTermsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenantPaymentTerms"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      payment_terms_id: number
      name: string
      description: string | null
      due_days: number
      discount_days: number
      discount_percent: Prisma.Decimal
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenantPaymentTerms"]>
    composites: {}
  }

  type tenantPaymentTermsGetPayload<S extends boolean | null | undefined | tenantPaymentTermsDefaultArgs> = $Result.GetResult<Prisma.$tenantPaymentTermsPayload, S>

  type tenantPaymentTermsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tenantPaymentTermsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantPaymentTermsCountAggregateInputType | true
    }

  export interface tenantPaymentTermsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenantPaymentTerms'], meta: { name: 'tenantPaymentTerms' } }
    /**
     * Find zero or one TenantPaymentTerms that matches the filter.
     * @param {tenantPaymentTermsFindUniqueArgs} args - Arguments to find a TenantPaymentTerms
     * @example
     * // Get one TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenantPaymentTermsFindUniqueArgs>(args: SelectSubset<T, tenantPaymentTermsFindUniqueArgs<ExtArgs>>): Prisma__tenantPaymentTermsClient<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantPaymentTerms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tenantPaymentTermsFindUniqueOrThrowArgs} args - Arguments to find a TenantPaymentTerms
     * @example
     * // Get one TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenantPaymentTermsFindUniqueOrThrowArgs>(args: SelectSubset<T, tenantPaymentTermsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenantPaymentTermsClient<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantPaymentTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentTermsFindFirstArgs} args - Arguments to find a TenantPaymentTerms
     * @example
     * // Get one TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenantPaymentTermsFindFirstArgs>(args?: SelectSubset<T, tenantPaymentTermsFindFirstArgs<ExtArgs>>): Prisma__tenantPaymentTermsClient<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantPaymentTerms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentTermsFindFirstOrThrowArgs} args - Arguments to find a TenantPaymentTerms
     * @example
     * // Get one TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenantPaymentTermsFindFirstOrThrowArgs>(args?: SelectSubset<T, tenantPaymentTermsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenantPaymentTermsClient<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantPaymentTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentTermsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.findMany()
     * 
     * // Get first 10 TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantPaymentTermsWithIdOnly = await prisma.tenantPaymentTerms.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenantPaymentTermsFindManyArgs>(args?: SelectSubset<T, tenantPaymentTermsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantPaymentTerms.
     * @param {tenantPaymentTermsCreateArgs} args - Arguments to create a TenantPaymentTerms.
     * @example
     * // Create one TenantPaymentTerms
     * const TenantPaymentTerms = await prisma.tenantPaymentTerms.create({
     *   data: {
     *     // ... data to create a TenantPaymentTerms
     *   }
     * })
     * 
     */
    create<T extends tenantPaymentTermsCreateArgs>(args: SelectSubset<T, tenantPaymentTermsCreateArgs<ExtArgs>>): Prisma__tenantPaymentTermsClient<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantPaymentTerms.
     * @param {tenantPaymentTermsCreateManyArgs} args - Arguments to create many TenantPaymentTerms.
     * @example
     * // Create many TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenantPaymentTermsCreateManyArgs>(args?: SelectSubset<T, tenantPaymentTermsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantPaymentTerms and returns the data saved in the database.
     * @param {tenantPaymentTermsCreateManyAndReturnArgs} args - Arguments to create many TenantPaymentTerms.
     * @example
     * // Create many TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantPaymentTerms and only return the `id`
     * const tenantPaymentTermsWithIdOnly = await prisma.tenantPaymentTerms.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenantPaymentTermsCreateManyAndReturnArgs>(args?: SelectSubset<T, tenantPaymentTermsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantPaymentTerms.
     * @param {tenantPaymentTermsDeleteArgs} args - Arguments to delete one TenantPaymentTerms.
     * @example
     * // Delete one TenantPaymentTerms
     * const TenantPaymentTerms = await prisma.tenantPaymentTerms.delete({
     *   where: {
     *     // ... filter to delete one TenantPaymentTerms
     *   }
     * })
     * 
     */
    delete<T extends tenantPaymentTermsDeleteArgs>(args: SelectSubset<T, tenantPaymentTermsDeleteArgs<ExtArgs>>): Prisma__tenantPaymentTermsClient<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantPaymentTerms.
     * @param {tenantPaymentTermsUpdateArgs} args - Arguments to update one TenantPaymentTerms.
     * @example
     * // Update one TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenantPaymentTermsUpdateArgs>(args: SelectSubset<T, tenantPaymentTermsUpdateArgs<ExtArgs>>): Prisma__tenantPaymentTermsClient<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantPaymentTerms.
     * @param {tenantPaymentTermsDeleteManyArgs} args - Arguments to filter TenantPaymentTerms to delete.
     * @example
     * // Delete a few TenantPaymentTerms
     * const { count } = await prisma.tenantPaymentTerms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenantPaymentTermsDeleteManyArgs>(args?: SelectSubset<T, tenantPaymentTermsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantPaymentTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentTermsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenantPaymentTermsUpdateManyArgs>(args: SelectSubset<T, tenantPaymentTermsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantPaymentTerms and returns the data updated in the database.
     * @param {tenantPaymentTermsUpdateManyAndReturnArgs} args - Arguments to update many TenantPaymentTerms.
     * @example
     * // Update many TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantPaymentTerms and only return the `id`
     * const tenantPaymentTermsWithIdOnly = await prisma.tenantPaymentTerms.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tenantPaymentTermsUpdateManyAndReturnArgs>(args: SelectSubset<T, tenantPaymentTermsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantPaymentTerms.
     * @param {tenantPaymentTermsUpsertArgs} args - Arguments to update or create a TenantPaymentTerms.
     * @example
     * // Update or create a TenantPaymentTerms
     * const tenantPaymentTerms = await prisma.tenantPaymentTerms.upsert({
     *   create: {
     *     // ... data to create a TenantPaymentTerms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantPaymentTerms we want to update
     *   }
     * })
     */
    upsert<T extends tenantPaymentTermsUpsertArgs>(args: SelectSubset<T, tenantPaymentTermsUpsertArgs<ExtArgs>>): Prisma__tenantPaymentTermsClient<$Result.GetResult<Prisma.$tenantPaymentTermsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantPaymentTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentTermsCountArgs} args - Arguments to filter TenantPaymentTerms to count.
     * @example
     * // Count the number of TenantPaymentTerms
     * const count = await prisma.tenantPaymentTerms.count({
     *   where: {
     *     // ... the filter for the TenantPaymentTerms we want to count
     *   }
     * })
    **/
    count<T extends tenantPaymentTermsCountArgs>(
      args?: Subset<T, tenantPaymentTermsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantPaymentTermsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantPaymentTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPaymentTermsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantPaymentTermsAggregateArgs>(args: Subset<T, TenantPaymentTermsAggregateArgs>): Prisma.PrismaPromise<GetTenantPaymentTermsAggregateType<T>>

    /**
     * Group by TenantPaymentTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentTermsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenantPaymentTermsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenantPaymentTermsGroupByArgs['orderBy'] }
        : { orderBy?: tenantPaymentTermsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenantPaymentTermsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantPaymentTermsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenantPaymentTerms model
   */
  readonly fields: tenantPaymentTermsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenantPaymentTerms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenantPaymentTermsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenantPaymentTerms model
   */
  interface tenantPaymentTermsFieldRefs {
    readonly id: FieldRef<"tenantPaymentTerms", 'String'>
    readonly payment_terms_id: FieldRef<"tenantPaymentTerms", 'Int'>
    readonly name: FieldRef<"tenantPaymentTerms", 'String'>
    readonly description: FieldRef<"tenantPaymentTerms", 'String'>
    readonly due_days: FieldRef<"tenantPaymentTerms", 'Int'>
    readonly discount_days: FieldRef<"tenantPaymentTerms", 'Int'>
    readonly discount_percent: FieldRef<"tenantPaymentTerms", 'Decimal'>
    readonly is_active: FieldRef<"tenantPaymentTerms", 'Boolean'>
    readonly created_at: FieldRef<"tenantPaymentTerms", 'DateTime'>
    readonly updated_at: FieldRef<"tenantPaymentTerms", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tenantPaymentTerms findUnique
   */
  export type tenantPaymentTermsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentTerms to fetch.
     */
    where: tenantPaymentTermsWhereUniqueInput
  }

  /**
   * tenantPaymentTerms findUniqueOrThrow
   */
  export type tenantPaymentTermsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentTerms to fetch.
     */
    where: tenantPaymentTermsWhereUniqueInput
  }

  /**
   * tenantPaymentTerms findFirst
   */
  export type tenantPaymentTermsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentTerms to fetch.
     */
    where?: tenantPaymentTermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantPaymentTerms to fetch.
     */
    orderBy?: tenantPaymentTermsOrderByWithRelationInput | tenantPaymentTermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantPaymentTerms.
     */
    cursor?: tenantPaymentTermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantPaymentTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantPaymentTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantPaymentTerms.
     */
    distinct?: TenantPaymentTermsScalarFieldEnum | TenantPaymentTermsScalarFieldEnum[]
  }

  /**
   * tenantPaymentTerms findFirstOrThrow
   */
  export type tenantPaymentTermsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentTerms to fetch.
     */
    where?: tenantPaymentTermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantPaymentTerms to fetch.
     */
    orderBy?: tenantPaymentTermsOrderByWithRelationInput | tenantPaymentTermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantPaymentTerms.
     */
    cursor?: tenantPaymentTermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantPaymentTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantPaymentTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantPaymentTerms.
     */
    distinct?: TenantPaymentTermsScalarFieldEnum | TenantPaymentTermsScalarFieldEnum[]
  }

  /**
   * tenantPaymentTerms findMany
   */
  export type tenantPaymentTermsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentTerms to fetch.
     */
    where?: tenantPaymentTermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantPaymentTerms to fetch.
     */
    orderBy?: tenantPaymentTermsOrderByWithRelationInput | tenantPaymentTermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenantPaymentTerms.
     */
    cursor?: tenantPaymentTermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantPaymentTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantPaymentTerms.
     */
    skip?: number
    distinct?: TenantPaymentTermsScalarFieldEnum | TenantPaymentTermsScalarFieldEnum[]
  }

  /**
   * tenantPaymentTerms create
   */
  export type tenantPaymentTermsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * The data needed to create a tenantPaymentTerms.
     */
    data: XOR<tenantPaymentTermsCreateInput, tenantPaymentTermsUncheckedCreateInput>
  }

  /**
   * tenantPaymentTerms createMany
   */
  export type tenantPaymentTermsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenantPaymentTerms.
     */
    data: tenantPaymentTermsCreateManyInput | tenantPaymentTermsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantPaymentTerms createManyAndReturn
   */
  export type tenantPaymentTermsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * The data used to create many tenantPaymentTerms.
     */
    data: tenantPaymentTermsCreateManyInput | tenantPaymentTermsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantPaymentTerms update
   */
  export type tenantPaymentTermsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * The data needed to update a tenantPaymentTerms.
     */
    data: XOR<tenantPaymentTermsUpdateInput, tenantPaymentTermsUncheckedUpdateInput>
    /**
     * Choose, which tenantPaymentTerms to update.
     */
    where: tenantPaymentTermsWhereUniqueInput
  }

  /**
   * tenantPaymentTerms updateMany
   */
  export type tenantPaymentTermsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenantPaymentTerms.
     */
    data: XOR<tenantPaymentTermsUpdateManyMutationInput, tenantPaymentTermsUncheckedUpdateManyInput>
    /**
     * Filter which tenantPaymentTerms to update
     */
    where?: tenantPaymentTermsWhereInput
    /**
     * Limit how many tenantPaymentTerms to update.
     */
    limit?: number
  }

  /**
   * tenantPaymentTerms updateManyAndReturn
   */
  export type tenantPaymentTermsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * The data used to update tenantPaymentTerms.
     */
    data: XOR<tenantPaymentTermsUpdateManyMutationInput, tenantPaymentTermsUncheckedUpdateManyInput>
    /**
     * Filter which tenantPaymentTerms to update
     */
    where?: tenantPaymentTermsWhereInput
    /**
     * Limit how many tenantPaymentTerms to update.
     */
    limit?: number
  }

  /**
   * tenantPaymentTerms upsert
   */
  export type tenantPaymentTermsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * The filter to search for the tenantPaymentTerms to update in case it exists.
     */
    where: tenantPaymentTermsWhereUniqueInput
    /**
     * In case the tenantPaymentTerms found by the `where` argument doesn't exist, create a new tenantPaymentTerms with this data.
     */
    create: XOR<tenantPaymentTermsCreateInput, tenantPaymentTermsUncheckedCreateInput>
    /**
     * In case the tenantPaymentTerms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenantPaymentTermsUpdateInput, tenantPaymentTermsUncheckedUpdateInput>
  }

  /**
   * tenantPaymentTerms delete
   */
  export type tenantPaymentTermsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
    /**
     * Filter which tenantPaymentTerms to delete.
     */
    where: tenantPaymentTermsWhereUniqueInput
  }

  /**
   * tenantPaymentTerms deleteMany
   */
  export type tenantPaymentTermsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantPaymentTerms to delete
     */
    where?: tenantPaymentTermsWhereInput
    /**
     * Limit how many tenantPaymentTerms to delete.
     */
    limit?: number
  }

  /**
   * tenantPaymentTerms without action
   */
  export type tenantPaymentTermsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentTerms
     */
    select?: tenantPaymentTermsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentTerms
     */
    omit?: tenantPaymentTermsOmit<ExtArgs> | null
  }


  /**
   * Model tenantPaymentStatus
   */

  export type AggregateTenantPaymentStatus = {
    _count: TenantPaymentStatusCountAggregateOutputType | null
    _min: TenantPaymentStatusMinAggregateOutputType | null
    _max: TenantPaymentStatusMaxAggregateOutputType | null
  }

  export type TenantPaymentStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantPaymentStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantPaymentStatusCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantPaymentStatusMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantPaymentStatusMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantPaymentStatusCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantPaymentStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantPaymentStatus to aggregate.
     */
    where?: tenantPaymentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantPaymentStatuses to fetch.
     */
    orderBy?: tenantPaymentStatusOrderByWithRelationInput | tenantPaymentStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenantPaymentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantPaymentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantPaymentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenantPaymentStatuses
    **/
    _count?: true | TenantPaymentStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantPaymentStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantPaymentStatusMaxAggregateInputType
  }

  export type GetTenantPaymentStatusAggregateType<T extends TenantPaymentStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantPaymentStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantPaymentStatus[P]>
      : GetScalarType<T[P], AggregateTenantPaymentStatus[P]>
  }




  export type tenantPaymentStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenantPaymentStatusWhereInput
    orderBy?: tenantPaymentStatusOrderByWithAggregationInput | tenantPaymentStatusOrderByWithAggregationInput[]
    by: TenantPaymentStatusScalarFieldEnum[] | TenantPaymentStatusScalarFieldEnum
    having?: tenantPaymentStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantPaymentStatusCountAggregateInputType | true
    _min?: TenantPaymentStatusMinAggregateInputType
    _max?: TenantPaymentStatusMaxAggregateInputType
  }

  export type TenantPaymentStatusGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantPaymentStatusCountAggregateOutputType | null
    _min: TenantPaymentStatusMinAggregateOutputType | null
    _max: TenantPaymentStatusMaxAggregateOutputType | null
  }

  type GetTenantPaymentStatusGroupByPayload<T extends tenantPaymentStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantPaymentStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantPaymentStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantPaymentStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TenantPaymentStatusGroupByOutputType[P]>
        }
      >
    >


  export type tenantPaymentStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantPaymentStatus"]>

  export type tenantPaymentStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantPaymentStatus"]>

  export type tenantPaymentStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantPaymentStatus"]>

  export type tenantPaymentStatusSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tenantPaymentStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenantPaymentStatus"]>

  export type $tenantPaymentStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenantPaymentStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenantPaymentStatus"]>
    composites: {}
  }

  type tenantPaymentStatusGetPayload<S extends boolean | null | undefined | tenantPaymentStatusDefaultArgs> = $Result.GetResult<Prisma.$tenantPaymentStatusPayload, S>

  type tenantPaymentStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tenantPaymentStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantPaymentStatusCountAggregateInputType | true
    }

  export interface tenantPaymentStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenantPaymentStatus'], meta: { name: 'tenantPaymentStatus' } }
    /**
     * Find zero or one TenantPaymentStatus that matches the filter.
     * @param {tenantPaymentStatusFindUniqueArgs} args - Arguments to find a TenantPaymentStatus
     * @example
     * // Get one TenantPaymentStatus
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenantPaymentStatusFindUniqueArgs>(args: SelectSubset<T, tenantPaymentStatusFindUniqueArgs<ExtArgs>>): Prisma__tenantPaymentStatusClient<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantPaymentStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tenantPaymentStatusFindUniqueOrThrowArgs} args - Arguments to find a TenantPaymentStatus
     * @example
     * // Get one TenantPaymentStatus
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenantPaymentStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, tenantPaymentStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenantPaymentStatusClient<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantPaymentStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentStatusFindFirstArgs} args - Arguments to find a TenantPaymentStatus
     * @example
     * // Get one TenantPaymentStatus
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenantPaymentStatusFindFirstArgs>(args?: SelectSubset<T, tenantPaymentStatusFindFirstArgs<ExtArgs>>): Prisma__tenantPaymentStatusClient<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantPaymentStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentStatusFindFirstOrThrowArgs} args - Arguments to find a TenantPaymentStatus
     * @example
     * // Get one TenantPaymentStatus
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenantPaymentStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, tenantPaymentStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenantPaymentStatusClient<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantPaymentStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantPaymentStatuses
     * const tenantPaymentStatuses = await prisma.tenantPaymentStatus.findMany()
     * 
     * // Get first 10 TenantPaymentStatuses
     * const tenantPaymentStatuses = await prisma.tenantPaymentStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantPaymentStatusWithIdOnly = await prisma.tenantPaymentStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenantPaymentStatusFindManyArgs>(args?: SelectSubset<T, tenantPaymentStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantPaymentStatus.
     * @param {tenantPaymentStatusCreateArgs} args - Arguments to create a TenantPaymentStatus.
     * @example
     * // Create one TenantPaymentStatus
     * const TenantPaymentStatus = await prisma.tenantPaymentStatus.create({
     *   data: {
     *     // ... data to create a TenantPaymentStatus
     *   }
     * })
     * 
     */
    create<T extends tenantPaymentStatusCreateArgs>(args: SelectSubset<T, tenantPaymentStatusCreateArgs<ExtArgs>>): Prisma__tenantPaymentStatusClient<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantPaymentStatuses.
     * @param {tenantPaymentStatusCreateManyArgs} args - Arguments to create many TenantPaymentStatuses.
     * @example
     * // Create many TenantPaymentStatuses
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenantPaymentStatusCreateManyArgs>(args?: SelectSubset<T, tenantPaymentStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantPaymentStatuses and returns the data saved in the database.
     * @param {tenantPaymentStatusCreateManyAndReturnArgs} args - Arguments to create many TenantPaymentStatuses.
     * @example
     * // Create many TenantPaymentStatuses
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantPaymentStatuses and only return the `id`
     * const tenantPaymentStatusWithIdOnly = await prisma.tenantPaymentStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenantPaymentStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, tenantPaymentStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantPaymentStatus.
     * @param {tenantPaymentStatusDeleteArgs} args - Arguments to delete one TenantPaymentStatus.
     * @example
     * // Delete one TenantPaymentStatus
     * const TenantPaymentStatus = await prisma.tenantPaymentStatus.delete({
     *   where: {
     *     // ... filter to delete one TenantPaymentStatus
     *   }
     * })
     * 
     */
    delete<T extends tenantPaymentStatusDeleteArgs>(args: SelectSubset<T, tenantPaymentStatusDeleteArgs<ExtArgs>>): Prisma__tenantPaymentStatusClient<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantPaymentStatus.
     * @param {tenantPaymentStatusUpdateArgs} args - Arguments to update one TenantPaymentStatus.
     * @example
     * // Update one TenantPaymentStatus
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenantPaymentStatusUpdateArgs>(args: SelectSubset<T, tenantPaymentStatusUpdateArgs<ExtArgs>>): Prisma__tenantPaymentStatusClient<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantPaymentStatuses.
     * @param {tenantPaymentStatusDeleteManyArgs} args - Arguments to filter TenantPaymentStatuses to delete.
     * @example
     * // Delete a few TenantPaymentStatuses
     * const { count } = await prisma.tenantPaymentStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenantPaymentStatusDeleteManyArgs>(args?: SelectSubset<T, tenantPaymentStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantPaymentStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantPaymentStatuses
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenantPaymentStatusUpdateManyArgs>(args: SelectSubset<T, tenantPaymentStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantPaymentStatuses and returns the data updated in the database.
     * @param {tenantPaymentStatusUpdateManyAndReturnArgs} args - Arguments to update many TenantPaymentStatuses.
     * @example
     * // Update many TenantPaymentStatuses
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantPaymentStatuses and only return the `id`
     * const tenantPaymentStatusWithIdOnly = await prisma.tenantPaymentStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tenantPaymentStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, tenantPaymentStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantPaymentStatus.
     * @param {tenantPaymentStatusUpsertArgs} args - Arguments to update or create a TenantPaymentStatus.
     * @example
     * // Update or create a TenantPaymentStatus
     * const tenantPaymentStatus = await prisma.tenantPaymentStatus.upsert({
     *   create: {
     *     // ... data to create a TenantPaymentStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantPaymentStatus we want to update
     *   }
     * })
     */
    upsert<T extends tenantPaymentStatusUpsertArgs>(args: SelectSubset<T, tenantPaymentStatusUpsertArgs<ExtArgs>>): Prisma__tenantPaymentStatusClient<$Result.GetResult<Prisma.$tenantPaymentStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantPaymentStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentStatusCountArgs} args - Arguments to filter TenantPaymentStatuses to count.
     * @example
     * // Count the number of TenantPaymentStatuses
     * const count = await prisma.tenantPaymentStatus.count({
     *   where: {
     *     // ... the filter for the TenantPaymentStatuses we want to count
     *   }
     * })
    **/
    count<T extends tenantPaymentStatusCountArgs>(
      args?: Subset<T, tenantPaymentStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantPaymentStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantPaymentStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPaymentStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantPaymentStatusAggregateArgs>(args: Subset<T, TenantPaymentStatusAggregateArgs>): Prisma.PrismaPromise<GetTenantPaymentStatusAggregateType<T>>

    /**
     * Group by TenantPaymentStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantPaymentStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenantPaymentStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenantPaymentStatusGroupByArgs['orderBy'] }
        : { orderBy?: tenantPaymentStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenantPaymentStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantPaymentStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenantPaymentStatus model
   */
  readonly fields: tenantPaymentStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenantPaymentStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenantPaymentStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenantPaymentStatus model
   */
  interface tenantPaymentStatusFieldRefs {
    readonly id: FieldRef<"tenantPaymentStatus", 'String'>
    readonly name: FieldRef<"tenantPaymentStatus", 'String'>
    readonly is_active: FieldRef<"tenantPaymentStatus", 'Boolean'>
    readonly created_at: FieldRef<"tenantPaymentStatus", 'DateTime'>
    readonly updated_at: FieldRef<"tenantPaymentStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tenantPaymentStatus findUnique
   */
  export type tenantPaymentStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentStatus to fetch.
     */
    where: tenantPaymentStatusWhereUniqueInput
  }

  /**
   * tenantPaymentStatus findUniqueOrThrow
   */
  export type tenantPaymentStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentStatus to fetch.
     */
    where: tenantPaymentStatusWhereUniqueInput
  }

  /**
   * tenantPaymentStatus findFirst
   */
  export type tenantPaymentStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentStatus to fetch.
     */
    where?: tenantPaymentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantPaymentStatuses to fetch.
     */
    orderBy?: tenantPaymentStatusOrderByWithRelationInput | tenantPaymentStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantPaymentStatuses.
     */
    cursor?: tenantPaymentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantPaymentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantPaymentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantPaymentStatuses.
     */
    distinct?: TenantPaymentStatusScalarFieldEnum | TenantPaymentStatusScalarFieldEnum[]
  }

  /**
   * tenantPaymentStatus findFirstOrThrow
   */
  export type tenantPaymentStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentStatus to fetch.
     */
    where?: tenantPaymentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantPaymentStatuses to fetch.
     */
    orderBy?: tenantPaymentStatusOrderByWithRelationInput | tenantPaymentStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantPaymentStatuses.
     */
    cursor?: tenantPaymentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantPaymentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantPaymentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantPaymentStatuses.
     */
    distinct?: TenantPaymentStatusScalarFieldEnum | TenantPaymentStatusScalarFieldEnum[]
  }

  /**
   * tenantPaymentStatus findMany
   */
  export type tenantPaymentStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantPaymentStatuses to fetch.
     */
    where?: tenantPaymentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantPaymentStatuses to fetch.
     */
    orderBy?: tenantPaymentStatusOrderByWithRelationInput | tenantPaymentStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenantPaymentStatuses.
     */
    cursor?: tenantPaymentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantPaymentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantPaymentStatuses.
     */
    skip?: number
    distinct?: TenantPaymentStatusScalarFieldEnum | TenantPaymentStatusScalarFieldEnum[]
  }

  /**
   * tenantPaymentStatus create
   */
  export type tenantPaymentStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a tenantPaymentStatus.
     */
    data: XOR<tenantPaymentStatusCreateInput, tenantPaymentStatusUncheckedCreateInput>
  }

  /**
   * tenantPaymentStatus createMany
   */
  export type tenantPaymentStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenantPaymentStatuses.
     */
    data: tenantPaymentStatusCreateManyInput | tenantPaymentStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantPaymentStatus createManyAndReturn
   */
  export type tenantPaymentStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * The data used to create many tenantPaymentStatuses.
     */
    data: tenantPaymentStatusCreateManyInput | tenantPaymentStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantPaymentStatus update
   */
  export type tenantPaymentStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a tenantPaymentStatus.
     */
    data: XOR<tenantPaymentStatusUpdateInput, tenantPaymentStatusUncheckedUpdateInput>
    /**
     * Choose, which tenantPaymentStatus to update.
     */
    where: tenantPaymentStatusWhereUniqueInput
  }

  /**
   * tenantPaymentStatus updateMany
   */
  export type tenantPaymentStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenantPaymentStatuses.
     */
    data: XOR<tenantPaymentStatusUpdateManyMutationInput, tenantPaymentStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantPaymentStatuses to update
     */
    where?: tenantPaymentStatusWhereInput
    /**
     * Limit how many tenantPaymentStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantPaymentStatus updateManyAndReturn
   */
  export type tenantPaymentStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * The data used to update tenantPaymentStatuses.
     */
    data: XOR<tenantPaymentStatusUpdateManyMutationInput, tenantPaymentStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantPaymentStatuses to update
     */
    where?: tenantPaymentStatusWhereInput
    /**
     * Limit how many tenantPaymentStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantPaymentStatus upsert
   */
  export type tenantPaymentStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the tenantPaymentStatus to update in case it exists.
     */
    where: tenantPaymentStatusWhereUniqueInput
    /**
     * In case the tenantPaymentStatus found by the `where` argument doesn't exist, create a new tenantPaymentStatus with this data.
     */
    create: XOR<tenantPaymentStatusCreateInput, tenantPaymentStatusUncheckedCreateInput>
    /**
     * In case the tenantPaymentStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenantPaymentStatusUpdateInput, tenantPaymentStatusUncheckedUpdateInput>
  }

  /**
   * tenantPaymentStatus delete
   */
  export type tenantPaymentStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
    /**
     * Filter which tenantPaymentStatus to delete.
     */
    where: tenantPaymentStatusWhereUniqueInput
  }

  /**
   * tenantPaymentStatus deleteMany
   */
  export type tenantPaymentStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantPaymentStatuses to delete
     */
    where?: tenantPaymentStatusWhereInput
    /**
     * Limit how many tenantPaymentStatuses to delete.
     */
    limit?: number
  }

  /**
   * tenantPaymentStatus without action
   */
  export type tenantPaymentStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantPaymentStatus
     */
    select?: tenantPaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantPaymentStatus
     */
    omit?: tenantPaymentStatusOmit<ExtArgs> | null
  }


  /**
   * Model tenantQuoteStatus
   */

  export type AggregateTenantQuoteStatus = {
    _count: TenantQuoteStatusCountAggregateOutputType | null
    _min: TenantQuoteStatusMinAggregateOutputType | null
    _max: TenantQuoteStatusMaxAggregateOutputType | null
  }

  export type TenantQuoteStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantQuoteStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantQuoteStatusCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantQuoteStatusMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantQuoteStatusMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantQuoteStatusCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantQuoteStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantQuoteStatus to aggregate.
     */
    where?: tenantQuoteStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantQuoteStatuses to fetch.
     */
    orderBy?: tenantQuoteStatusOrderByWithRelationInput | tenantQuoteStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenantQuoteStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantQuoteStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantQuoteStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenantQuoteStatuses
    **/
    _count?: true | TenantQuoteStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantQuoteStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantQuoteStatusMaxAggregateInputType
  }

  export type GetTenantQuoteStatusAggregateType<T extends TenantQuoteStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantQuoteStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantQuoteStatus[P]>
      : GetScalarType<T[P], AggregateTenantQuoteStatus[P]>
  }




  export type tenantQuoteStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenantQuoteStatusWhereInput
    orderBy?: tenantQuoteStatusOrderByWithAggregationInput | tenantQuoteStatusOrderByWithAggregationInput[]
    by: TenantQuoteStatusScalarFieldEnum[] | TenantQuoteStatusScalarFieldEnum
    having?: tenantQuoteStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantQuoteStatusCountAggregateInputType | true
    _min?: TenantQuoteStatusMinAggregateInputType
    _max?: TenantQuoteStatusMaxAggregateInputType
  }

  export type TenantQuoteStatusGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantQuoteStatusCountAggregateOutputType | null
    _min: TenantQuoteStatusMinAggregateOutputType | null
    _max: TenantQuoteStatusMaxAggregateOutputType | null
  }

  type GetTenantQuoteStatusGroupByPayload<T extends tenantQuoteStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantQuoteStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantQuoteStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantQuoteStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TenantQuoteStatusGroupByOutputType[P]>
        }
      >
    >


  export type tenantQuoteStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantQuoteStatus"]>

  export type tenantQuoteStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantQuoteStatus"]>

  export type tenantQuoteStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantQuoteStatus"]>

  export type tenantQuoteStatusSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tenantQuoteStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenantQuoteStatus"]>

  export type $tenantQuoteStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenantQuoteStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenantQuoteStatus"]>
    composites: {}
  }

  type tenantQuoteStatusGetPayload<S extends boolean | null | undefined | tenantQuoteStatusDefaultArgs> = $Result.GetResult<Prisma.$tenantQuoteStatusPayload, S>

  type tenantQuoteStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tenantQuoteStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantQuoteStatusCountAggregateInputType | true
    }

  export interface tenantQuoteStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenantQuoteStatus'], meta: { name: 'tenantQuoteStatus' } }
    /**
     * Find zero or one TenantQuoteStatus that matches the filter.
     * @param {tenantQuoteStatusFindUniqueArgs} args - Arguments to find a TenantQuoteStatus
     * @example
     * // Get one TenantQuoteStatus
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenantQuoteStatusFindUniqueArgs>(args: SelectSubset<T, tenantQuoteStatusFindUniqueArgs<ExtArgs>>): Prisma__tenantQuoteStatusClient<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantQuoteStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tenantQuoteStatusFindUniqueOrThrowArgs} args - Arguments to find a TenantQuoteStatus
     * @example
     * // Get one TenantQuoteStatus
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenantQuoteStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, tenantQuoteStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenantQuoteStatusClient<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantQuoteStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantQuoteStatusFindFirstArgs} args - Arguments to find a TenantQuoteStatus
     * @example
     * // Get one TenantQuoteStatus
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenantQuoteStatusFindFirstArgs>(args?: SelectSubset<T, tenantQuoteStatusFindFirstArgs<ExtArgs>>): Prisma__tenantQuoteStatusClient<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantQuoteStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantQuoteStatusFindFirstOrThrowArgs} args - Arguments to find a TenantQuoteStatus
     * @example
     * // Get one TenantQuoteStatus
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenantQuoteStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, tenantQuoteStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenantQuoteStatusClient<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantQuoteStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantQuoteStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantQuoteStatuses
     * const tenantQuoteStatuses = await prisma.tenantQuoteStatus.findMany()
     * 
     * // Get first 10 TenantQuoteStatuses
     * const tenantQuoteStatuses = await prisma.tenantQuoteStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantQuoteStatusWithIdOnly = await prisma.tenantQuoteStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenantQuoteStatusFindManyArgs>(args?: SelectSubset<T, tenantQuoteStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantQuoteStatus.
     * @param {tenantQuoteStatusCreateArgs} args - Arguments to create a TenantQuoteStatus.
     * @example
     * // Create one TenantQuoteStatus
     * const TenantQuoteStatus = await prisma.tenantQuoteStatus.create({
     *   data: {
     *     // ... data to create a TenantQuoteStatus
     *   }
     * })
     * 
     */
    create<T extends tenantQuoteStatusCreateArgs>(args: SelectSubset<T, tenantQuoteStatusCreateArgs<ExtArgs>>): Prisma__tenantQuoteStatusClient<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantQuoteStatuses.
     * @param {tenantQuoteStatusCreateManyArgs} args - Arguments to create many TenantQuoteStatuses.
     * @example
     * // Create many TenantQuoteStatuses
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenantQuoteStatusCreateManyArgs>(args?: SelectSubset<T, tenantQuoteStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantQuoteStatuses and returns the data saved in the database.
     * @param {tenantQuoteStatusCreateManyAndReturnArgs} args - Arguments to create many TenantQuoteStatuses.
     * @example
     * // Create many TenantQuoteStatuses
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantQuoteStatuses and only return the `id`
     * const tenantQuoteStatusWithIdOnly = await prisma.tenantQuoteStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenantQuoteStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, tenantQuoteStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantQuoteStatus.
     * @param {tenantQuoteStatusDeleteArgs} args - Arguments to delete one TenantQuoteStatus.
     * @example
     * // Delete one TenantQuoteStatus
     * const TenantQuoteStatus = await prisma.tenantQuoteStatus.delete({
     *   where: {
     *     // ... filter to delete one TenantQuoteStatus
     *   }
     * })
     * 
     */
    delete<T extends tenantQuoteStatusDeleteArgs>(args: SelectSubset<T, tenantQuoteStatusDeleteArgs<ExtArgs>>): Prisma__tenantQuoteStatusClient<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantQuoteStatus.
     * @param {tenantQuoteStatusUpdateArgs} args - Arguments to update one TenantQuoteStatus.
     * @example
     * // Update one TenantQuoteStatus
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenantQuoteStatusUpdateArgs>(args: SelectSubset<T, tenantQuoteStatusUpdateArgs<ExtArgs>>): Prisma__tenantQuoteStatusClient<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantQuoteStatuses.
     * @param {tenantQuoteStatusDeleteManyArgs} args - Arguments to filter TenantQuoteStatuses to delete.
     * @example
     * // Delete a few TenantQuoteStatuses
     * const { count } = await prisma.tenantQuoteStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenantQuoteStatusDeleteManyArgs>(args?: SelectSubset<T, tenantQuoteStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantQuoteStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantQuoteStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantQuoteStatuses
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenantQuoteStatusUpdateManyArgs>(args: SelectSubset<T, tenantQuoteStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantQuoteStatuses and returns the data updated in the database.
     * @param {tenantQuoteStatusUpdateManyAndReturnArgs} args - Arguments to update many TenantQuoteStatuses.
     * @example
     * // Update many TenantQuoteStatuses
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantQuoteStatuses and only return the `id`
     * const tenantQuoteStatusWithIdOnly = await prisma.tenantQuoteStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tenantQuoteStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, tenantQuoteStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantQuoteStatus.
     * @param {tenantQuoteStatusUpsertArgs} args - Arguments to update or create a TenantQuoteStatus.
     * @example
     * // Update or create a TenantQuoteStatus
     * const tenantQuoteStatus = await prisma.tenantQuoteStatus.upsert({
     *   create: {
     *     // ... data to create a TenantQuoteStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantQuoteStatus we want to update
     *   }
     * })
     */
    upsert<T extends tenantQuoteStatusUpsertArgs>(args: SelectSubset<T, tenantQuoteStatusUpsertArgs<ExtArgs>>): Prisma__tenantQuoteStatusClient<$Result.GetResult<Prisma.$tenantQuoteStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantQuoteStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantQuoteStatusCountArgs} args - Arguments to filter TenantQuoteStatuses to count.
     * @example
     * // Count the number of TenantQuoteStatuses
     * const count = await prisma.tenantQuoteStatus.count({
     *   where: {
     *     // ... the filter for the TenantQuoteStatuses we want to count
     *   }
     * })
    **/
    count<T extends tenantQuoteStatusCountArgs>(
      args?: Subset<T, tenantQuoteStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantQuoteStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantQuoteStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantQuoteStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantQuoteStatusAggregateArgs>(args: Subset<T, TenantQuoteStatusAggregateArgs>): Prisma.PrismaPromise<GetTenantQuoteStatusAggregateType<T>>

    /**
     * Group by TenantQuoteStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantQuoteStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenantQuoteStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenantQuoteStatusGroupByArgs['orderBy'] }
        : { orderBy?: tenantQuoteStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenantQuoteStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantQuoteStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenantQuoteStatus model
   */
  readonly fields: tenantQuoteStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenantQuoteStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenantQuoteStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenantQuoteStatus model
   */
  interface tenantQuoteStatusFieldRefs {
    readonly id: FieldRef<"tenantQuoteStatus", 'String'>
    readonly name: FieldRef<"tenantQuoteStatus", 'String'>
    readonly is_active: FieldRef<"tenantQuoteStatus", 'Boolean'>
    readonly created_at: FieldRef<"tenantQuoteStatus", 'DateTime'>
    readonly updated_at: FieldRef<"tenantQuoteStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tenantQuoteStatus findUnique
   */
  export type tenantQuoteStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantQuoteStatus to fetch.
     */
    where: tenantQuoteStatusWhereUniqueInput
  }

  /**
   * tenantQuoteStatus findUniqueOrThrow
   */
  export type tenantQuoteStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantQuoteStatus to fetch.
     */
    where: tenantQuoteStatusWhereUniqueInput
  }

  /**
   * tenantQuoteStatus findFirst
   */
  export type tenantQuoteStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantQuoteStatus to fetch.
     */
    where?: tenantQuoteStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantQuoteStatuses to fetch.
     */
    orderBy?: tenantQuoteStatusOrderByWithRelationInput | tenantQuoteStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantQuoteStatuses.
     */
    cursor?: tenantQuoteStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantQuoteStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantQuoteStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantQuoteStatuses.
     */
    distinct?: TenantQuoteStatusScalarFieldEnum | TenantQuoteStatusScalarFieldEnum[]
  }

  /**
   * tenantQuoteStatus findFirstOrThrow
   */
  export type tenantQuoteStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantQuoteStatus to fetch.
     */
    where?: tenantQuoteStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantQuoteStatuses to fetch.
     */
    orderBy?: tenantQuoteStatusOrderByWithRelationInput | tenantQuoteStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantQuoteStatuses.
     */
    cursor?: tenantQuoteStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantQuoteStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantQuoteStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantQuoteStatuses.
     */
    distinct?: TenantQuoteStatusScalarFieldEnum | TenantQuoteStatusScalarFieldEnum[]
  }

  /**
   * tenantQuoteStatus findMany
   */
  export type tenantQuoteStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantQuoteStatuses to fetch.
     */
    where?: tenantQuoteStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantQuoteStatuses to fetch.
     */
    orderBy?: tenantQuoteStatusOrderByWithRelationInput | tenantQuoteStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenantQuoteStatuses.
     */
    cursor?: tenantQuoteStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantQuoteStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantQuoteStatuses.
     */
    skip?: number
    distinct?: TenantQuoteStatusScalarFieldEnum | TenantQuoteStatusScalarFieldEnum[]
  }

  /**
   * tenantQuoteStatus create
   */
  export type tenantQuoteStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a tenantQuoteStatus.
     */
    data: XOR<tenantQuoteStatusCreateInput, tenantQuoteStatusUncheckedCreateInput>
  }

  /**
   * tenantQuoteStatus createMany
   */
  export type tenantQuoteStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenantQuoteStatuses.
     */
    data: tenantQuoteStatusCreateManyInput | tenantQuoteStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantQuoteStatus createManyAndReturn
   */
  export type tenantQuoteStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * The data used to create many tenantQuoteStatuses.
     */
    data: tenantQuoteStatusCreateManyInput | tenantQuoteStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantQuoteStatus update
   */
  export type tenantQuoteStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a tenantQuoteStatus.
     */
    data: XOR<tenantQuoteStatusUpdateInput, tenantQuoteStatusUncheckedUpdateInput>
    /**
     * Choose, which tenantQuoteStatus to update.
     */
    where: tenantQuoteStatusWhereUniqueInput
  }

  /**
   * tenantQuoteStatus updateMany
   */
  export type tenantQuoteStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenantQuoteStatuses.
     */
    data: XOR<tenantQuoteStatusUpdateManyMutationInput, tenantQuoteStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantQuoteStatuses to update
     */
    where?: tenantQuoteStatusWhereInput
    /**
     * Limit how many tenantQuoteStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantQuoteStatus updateManyAndReturn
   */
  export type tenantQuoteStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * The data used to update tenantQuoteStatuses.
     */
    data: XOR<tenantQuoteStatusUpdateManyMutationInput, tenantQuoteStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantQuoteStatuses to update
     */
    where?: tenantQuoteStatusWhereInput
    /**
     * Limit how many tenantQuoteStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantQuoteStatus upsert
   */
  export type tenantQuoteStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the tenantQuoteStatus to update in case it exists.
     */
    where: tenantQuoteStatusWhereUniqueInput
    /**
     * In case the tenantQuoteStatus found by the `where` argument doesn't exist, create a new tenantQuoteStatus with this data.
     */
    create: XOR<tenantQuoteStatusCreateInput, tenantQuoteStatusUncheckedCreateInput>
    /**
     * In case the tenantQuoteStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenantQuoteStatusUpdateInput, tenantQuoteStatusUncheckedUpdateInput>
  }

  /**
   * tenantQuoteStatus delete
   */
  export type tenantQuoteStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
    /**
     * Filter which tenantQuoteStatus to delete.
     */
    where: tenantQuoteStatusWhereUniqueInput
  }

  /**
   * tenantQuoteStatus deleteMany
   */
  export type tenantQuoteStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantQuoteStatuses to delete
     */
    where?: tenantQuoteStatusWhereInput
    /**
     * Limit how many tenantQuoteStatuses to delete.
     */
    limit?: number
  }

  /**
   * tenantQuoteStatus without action
   */
  export type tenantQuoteStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantQuoteStatus
     */
    select?: tenantQuoteStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantQuoteStatus
     */
    omit?: tenantQuoteStatusOmit<ExtArgs> | null
  }


  /**
   * Model tenantOrderStatus
   */

  export type AggregateTenantOrderStatus = {
    _count: TenantOrderStatusCountAggregateOutputType | null
    _min: TenantOrderStatusMinAggregateOutputType | null
    _max: TenantOrderStatusMaxAggregateOutputType | null
  }

  export type TenantOrderStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantOrderStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantOrderStatusCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantOrderStatusMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantOrderStatusMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantOrderStatusCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantOrderStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantOrderStatus to aggregate.
     */
    where?: tenantOrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantOrderStatuses to fetch.
     */
    orderBy?: tenantOrderStatusOrderByWithRelationInput | tenantOrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenantOrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantOrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantOrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenantOrderStatuses
    **/
    _count?: true | TenantOrderStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantOrderStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantOrderStatusMaxAggregateInputType
  }

  export type GetTenantOrderStatusAggregateType<T extends TenantOrderStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantOrderStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantOrderStatus[P]>
      : GetScalarType<T[P], AggregateTenantOrderStatus[P]>
  }




  export type tenantOrderStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenantOrderStatusWhereInput
    orderBy?: tenantOrderStatusOrderByWithAggregationInput | tenantOrderStatusOrderByWithAggregationInput[]
    by: TenantOrderStatusScalarFieldEnum[] | TenantOrderStatusScalarFieldEnum
    having?: tenantOrderStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantOrderStatusCountAggregateInputType | true
    _min?: TenantOrderStatusMinAggregateInputType
    _max?: TenantOrderStatusMaxAggregateInputType
  }

  export type TenantOrderStatusGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantOrderStatusCountAggregateOutputType | null
    _min: TenantOrderStatusMinAggregateOutputType | null
    _max: TenantOrderStatusMaxAggregateOutputType | null
  }

  type GetTenantOrderStatusGroupByPayload<T extends tenantOrderStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantOrderStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantOrderStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantOrderStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TenantOrderStatusGroupByOutputType[P]>
        }
      >
    >


  export type tenantOrderStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantOrderStatus"]>

  export type tenantOrderStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantOrderStatus"]>

  export type tenantOrderStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantOrderStatus"]>

  export type tenantOrderStatusSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tenantOrderStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenantOrderStatus"]>

  export type $tenantOrderStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenantOrderStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenantOrderStatus"]>
    composites: {}
  }

  type tenantOrderStatusGetPayload<S extends boolean | null | undefined | tenantOrderStatusDefaultArgs> = $Result.GetResult<Prisma.$tenantOrderStatusPayload, S>

  type tenantOrderStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tenantOrderStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantOrderStatusCountAggregateInputType | true
    }

  export interface tenantOrderStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenantOrderStatus'], meta: { name: 'tenantOrderStatus' } }
    /**
     * Find zero or one TenantOrderStatus that matches the filter.
     * @param {tenantOrderStatusFindUniqueArgs} args - Arguments to find a TenantOrderStatus
     * @example
     * // Get one TenantOrderStatus
     * const tenantOrderStatus = await prisma.tenantOrderStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenantOrderStatusFindUniqueArgs>(args: SelectSubset<T, tenantOrderStatusFindUniqueArgs<ExtArgs>>): Prisma__tenantOrderStatusClient<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantOrderStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tenantOrderStatusFindUniqueOrThrowArgs} args - Arguments to find a TenantOrderStatus
     * @example
     * // Get one TenantOrderStatus
     * const tenantOrderStatus = await prisma.tenantOrderStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenantOrderStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, tenantOrderStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenantOrderStatusClient<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantOrderStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantOrderStatusFindFirstArgs} args - Arguments to find a TenantOrderStatus
     * @example
     * // Get one TenantOrderStatus
     * const tenantOrderStatus = await prisma.tenantOrderStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenantOrderStatusFindFirstArgs>(args?: SelectSubset<T, tenantOrderStatusFindFirstArgs<ExtArgs>>): Prisma__tenantOrderStatusClient<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantOrderStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantOrderStatusFindFirstOrThrowArgs} args - Arguments to find a TenantOrderStatus
     * @example
     * // Get one TenantOrderStatus
     * const tenantOrderStatus = await prisma.tenantOrderStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenantOrderStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, tenantOrderStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenantOrderStatusClient<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantOrderStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantOrderStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantOrderStatuses
     * const tenantOrderStatuses = await prisma.tenantOrderStatus.findMany()
     * 
     * // Get first 10 TenantOrderStatuses
     * const tenantOrderStatuses = await prisma.tenantOrderStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantOrderStatusWithIdOnly = await prisma.tenantOrderStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenantOrderStatusFindManyArgs>(args?: SelectSubset<T, tenantOrderStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantOrderStatus.
     * @param {tenantOrderStatusCreateArgs} args - Arguments to create a TenantOrderStatus.
     * @example
     * // Create one TenantOrderStatus
     * const TenantOrderStatus = await prisma.tenantOrderStatus.create({
     *   data: {
     *     // ... data to create a TenantOrderStatus
     *   }
     * })
     * 
     */
    create<T extends tenantOrderStatusCreateArgs>(args: SelectSubset<T, tenantOrderStatusCreateArgs<ExtArgs>>): Prisma__tenantOrderStatusClient<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantOrderStatuses.
     * @param {tenantOrderStatusCreateManyArgs} args - Arguments to create many TenantOrderStatuses.
     * @example
     * // Create many TenantOrderStatuses
     * const tenantOrderStatus = await prisma.tenantOrderStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenantOrderStatusCreateManyArgs>(args?: SelectSubset<T, tenantOrderStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantOrderStatuses and returns the data saved in the database.
     * @param {tenantOrderStatusCreateManyAndReturnArgs} args - Arguments to create many TenantOrderStatuses.
     * @example
     * // Create many TenantOrderStatuses
     * const tenantOrderStatus = await prisma.tenantOrderStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantOrderStatuses and only return the `id`
     * const tenantOrderStatusWithIdOnly = await prisma.tenantOrderStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenantOrderStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, tenantOrderStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantOrderStatus.
     * @param {tenantOrderStatusDeleteArgs} args - Arguments to delete one TenantOrderStatus.
     * @example
     * // Delete one TenantOrderStatus
     * const TenantOrderStatus = await prisma.tenantOrderStatus.delete({
     *   where: {
     *     // ... filter to delete one TenantOrderStatus
     *   }
     * })
     * 
     */
    delete<T extends tenantOrderStatusDeleteArgs>(args: SelectSubset<T, tenantOrderStatusDeleteArgs<ExtArgs>>): Prisma__tenantOrderStatusClient<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantOrderStatus.
     * @param {tenantOrderStatusUpdateArgs} args - Arguments to update one TenantOrderStatus.
     * @example
     * // Update one TenantOrderStatus
     * const tenantOrderStatus = await prisma.tenantOrderStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenantOrderStatusUpdateArgs>(args: SelectSubset<T, tenantOrderStatusUpdateArgs<ExtArgs>>): Prisma__tenantOrderStatusClient<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantOrderStatuses.
     * @param {tenantOrderStatusDeleteManyArgs} args - Arguments to filter TenantOrderStatuses to delete.
     * @example
     * // Delete a few TenantOrderStatuses
     * const { count } = await prisma.tenantOrderStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenantOrderStatusDeleteManyArgs>(args?: SelectSubset<T, tenantOrderStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantOrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantOrderStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantOrderStatuses
     * const tenantOrderStatus = await prisma.tenantOrderStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenantOrderStatusUpdateManyArgs>(args: SelectSubset<T, tenantOrderStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantOrderStatuses and returns the data updated in the database.
     * @param {tenantOrderStatusUpdateManyAndReturnArgs} args - Arguments to update many TenantOrderStatuses.
     * @example
     * // Update many TenantOrderStatuses
     * const tenantOrderStatus = await prisma.tenantOrderStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantOrderStatuses and only return the `id`
     * const tenantOrderStatusWithIdOnly = await prisma.tenantOrderStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tenantOrderStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, tenantOrderStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantOrderStatus.
     * @param {tenantOrderStatusUpsertArgs} args - Arguments to update or create a TenantOrderStatus.
     * @example
     * // Update or create a TenantOrderStatus
     * const tenantOrderStatus = await prisma.tenantOrderStatus.upsert({
     *   create: {
     *     // ... data to create a TenantOrderStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantOrderStatus we want to update
     *   }
     * })
     */
    upsert<T extends tenantOrderStatusUpsertArgs>(args: SelectSubset<T, tenantOrderStatusUpsertArgs<ExtArgs>>): Prisma__tenantOrderStatusClient<$Result.GetResult<Prisma.$tenantOrderStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantOrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantOrderStatusCountArgs} args - Arguments to filter TenantOrderStatuses to count.
     * @example
     * // Count the number of TenantOrderStatuses
     * const count = await prisma.tenantOrderStatus.count({
     *   where: {
     *     // ... the filter for the TenantOrderStatuses we want to count
     *   }
     * })
    **/
    count<T extends tenantOrderStatusCountArgs>(
      args?: Subset<T, tenantOrderStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantOrderStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantOrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOrderStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantOrderStatusAggregateArgs>(args: Subset<T, TenantOrderStatusAggregateArgs>): Prisma.PrismaPromise<GetTenantOrderStatusAggregateType<T>>

    /**
     * Group by TenantOrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantOrderStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenantOrderStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenantOrderStatusGroupByArgs['orderBy'] }
        : { orderBy?: tenantOrderStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenantOrderStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantOrderStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenantOrderStatus model
   */
  readonly fields: tenantOrderStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenantOrderStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenantOrderStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenantOrderStatus model
   */
  interface tenantOrderStatusFieldRefs {
    readonly id: FieldRef<"tenantOrderStatus", 'String'>
    readonly name: FieldRef<"tenantOrderStatus", 'String'>
    readonly is_active: FieldRef<"tenantOrderStatus", 'Boolean'>
    readonly created_at: FieldRef<"tenantOrderStatus", 'DateTime'>
    readonly updated_at: FieldRef<"tenantOrderStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tenantOrderStatus findUnique
   */
  export type tenantOrderStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantOrderStatus to fetch.
     */
    where: tenantOrderStatusWhereUniqueInput
  }

  /**
   * tenantOrderStatus findUniqueOrThrow
   */
  export type tenantOrderStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantOrderStatus to fetch.
     */
    where: tenantOrderStatusWhereUniqueInput
  }

  /**
   * tenantOrderStatus findFirst
   */
  export type tenantOrderStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantOrderStatus to fetch.
     */
    where?: tenantOrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantOrderStatuses to fetch.
     */
    orderBy?: tenantOrderStatusOrderByWithRelationInput | tenantOrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantOrderStatuses.
     */
    cursor?: tenantOrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantOrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantOrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantOrderStatuses.
     */
    distinct?: TenantOrderStatusScalarFieldEnum | TenantOrderStatusScalarFieldEnum[]
  }

  /**
   * tenantOrderStatus findFirstOrThrow
   */
  export type tenantOrderStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantOrderStatus to fetch.
     */
    where?: tenantOrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantOrderStatuses to fetch.
     */
    orderBy?: tenantOrderStatusOrderByWithRelationInput | tenantOrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantOrderStatuses.
     */
    cursor?: tenantOrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantOrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantOrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantOrderStatuses.
     */
    distinct?: TenantOrderStatusScalarFieldEnum | TenantOrderStatusScalarFieldEnum[]
  }

  /**
   * tenantOrderStatus findMany
   */
  export type tenantOrderStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantOrderStatuses to fetch.
     */
    where?: tenantOrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantOrderStatuses to fetch.
     */
    orderBy?: tenantOrderStatusOrderByWithRelationInput | tenantOrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenantOrderStatuses.
     */
    cursor?: tenantOrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantOrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantOrderStatuses.
     */
    skip?: number
    distinct?: TenantOrderStatusScalarFieldEnum | TenantOrderStatusScalarFieldEnum[]
  }

  /**
   * tenantOrderStatus create
   */
  export type tenantOrderStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a tenantOrderStatus.
     */
    data: XOR<tenantOrderStatusCreateInput, tenantOrderStatusUncheckedCreateInput>
  }

  /**
   * tenantOrderStatus createMany
   */
  export type tenantOrderStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenantOrderStatuses.
     */
    data: tenantOrderStatusCreateManyInput | tenantOrderStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantOrderStatus createManyAndReturn
   */
  export type tenantOrderStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * The data used to create many tenantOrderStatuses.
     */
    data: tenantOrderStatusCreateManyInput | tenantOrderStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantOrderStatus update
   */
  export type tenantOrderStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a tenantOrderStatus.
     */
    data: XOR<tenantOrderStatusUpdateInput, tenantOrderStatusUncheckedUpdateInput>
    /**
     * Choose, which tenantOrderStatus to update.
     */
    where: tenantOrderStatusWhereUniqueInput
  }

  /**
   * tenantOrderStatus updateMany
   */
  export type tenantOrderStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenantOrderStatuses.
     */
    data: XOR<tenantOrderStatusUpdateManyMutationInput, tenantOrderStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantOrderStatuses to update
     */
    where?: tenantOrderStatusWhereInput
    /**
     * Limit how many tenantOrderStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantOrderStatus updateManyAndReturn
   */
  export type tenantOrderStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * The data used to update tenantOrderStatuses.
     */
    data: XOR<tenantOrderStatusUpdateManyMutationInput, tenantOrderStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantOrderStatuses to update
     */
    where?: tenantOrderStatusWhereInput
    /**
     * Limit how many tenantOrderStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantOrderStatus upsert
   */
  export type tenantOrderStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the tenantOrderStatus to update in case it exists.
     */
    where: tenantOrderStatusWhereUniqueInput
    /**
     * In case the tenantOrderStatus found by the `where` argument doesn't exist, create a new tenantOrderStatus with this data.
     */
    create: XOR<tenantOrderStatusCreateInput, tenantOrderStatusUncheckedCreateInput>
    /**
     * In case the tenantOrderStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenantOrderStatusUpdateInput, tenantOrderStatusUncheckedUpdateInput>
  }

  /**
   * tenantOrderStatus delete
   */
  export type tenantOrderStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
    /**
     * Filter which tenantOrderStatus to delete.
     */
    where: tenantOrderStatusWhereUniqueInput
  }

  /**
   * tenantOrderStatus deleteMany
   */
  export type tenantOrderStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantOrderStatuses to delete
     */
    where?: tenantOrderStatusWhereInput
    /**
     * Limit how many tenantOrderStatuses to delete.
     */
    limit?: number
  }

  /**
   * tenantOrderStatus without action
   */
  export type tenantOrderStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantOrderStatus
     */
    select?: tenantOrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantOrderStatus
     */
    omit?: tenantOrderStatusOmit<ExtArgs> | null
  }


  /**
   * Model tenantLogisticsStatus
   */

  export type AggregateTenantLogisticsStatus = {
    _count: TenantLogisticsStatusCountAggregateOutputType | null
    _min: TenantLogisticsStatusMinAggregateOutputType | null
    _max: TenantLogisticsStatusMaxAggregateOutputType | null
  }

  export type TenantLogisticsStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantLogisticsStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantLogisticsStatusCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantLogisticsStatusMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantLogisticsStatusMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantLogisticsStatusCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantLogisticsStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantLogisticsStatus to aggregate.
     */
    where?: tenantLogisticsStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantLogisticsStatuses to fetch.
     */
    orderBy?: tenantLogisticsStatusOrderByWithRelationInput | tenantLogisticsStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenantLogisticsStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantLogisticsStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantLogisticsStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenantLogisticsStatuses
    **/
    _count?: true | TenantLogisticsStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantLogisticsStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantLogisticsStatusMaxAggregateInputType
  }

  export type GetTenantLogisticsStatusAggregateType<T extends TenantLogisticsStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantLogisticsStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantLogisticsStatus[P]>
      : GetScalarType<T[P], AggregateTenantLogisticsStatus[P]>
  }




  export type tenantLogisticsStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenantLogisticsStatusWhereInput
    orderBy?: tenantLogisticsStatusOrderByWithAggregationInput | tenantLogisticsStatusOrderByWithAggregationInput[]
    by: TenantLogisticsStatusScalarFieldEnum[] | TenantLogisticsStatusScalarFieldEnum
    having?: tenantLogisticsStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantLogisticsStatusCountAggregateInputType | true
    _min?: TenantLogisticsStatusMinAggregateInputType
    _max?: TenantLogisticsStatusMaxAggregateInputType
  }

  export type TenantLogisticsStatusGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantLogisticsStatusCountAggregateOutputType | null
    _min: TenantLogisticsStatusMinAggregateOutputType | null
    _max: TenantLogisticsStatusMaxAggregateOutputType | null
  }

  type GetTenantLogisticsStatusGroupByPayload<T extends tenantLogisticsStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantLogisticsStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantLogisticsStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantLogisticsStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TenantLogisticsStatusGroupByOutputType[P]>
        }
      >
    >


  export type tenantLogisticsStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantLogisticsStatus"]>

  export type tenantLogisticsStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantLogisticsStatus"]>

  export type tenantLogisticsStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantLogisticsStatus"]>

  export type tenantLogisticsStatusSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tenantLogisticsStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenantLogisticsStatus"]>

  export type $tenantLogisticsStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenantLogisticsStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenantLogisticsStatus"]>
    composites: {}
  }

  type tenantLogisticsStatusGetPayload<S extends boolean | null | undefined | tenantLogisticsStatusDefaultArgs> = $Result.GetResult<Prisma.$tenantLogisticsStatusPayload, S>

  type tenantLogisticsStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tenantLogisticsStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantLogisticsStatusCountAggregateInputType | true
    }

  export interface tenantLogisticsStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenantLogisticsStatus'], meta: { name: 'tenantLogisticsStatus' } }
    /**
     * Find zero or one TenantLogisticsStatus that matches the filter.
     * @param {tenantLogisticsStatusFindUniqueArgs} args - Arguments to find a TenantLogisticsStatus
     * @example
     * // Get one TenantLogisticsStatus
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenantLogisticsStatusFindUniqueArgs>(args: SelectSubset<T, tenantLogisticsStatusFindUniqueArgs<ExtArgs>>): Prisma__tenantLogisticsStatusClient<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantLogisticsStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tenantLogisticsStatusFindUniqueOrThrowArgs} args - Arguments to find a TenantLogisticsStatus
     * @example
     * // Get one TenantLogisticsStatus
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenantLogisticsStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, tenantLogisticsStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenantLogisticsStatusClient<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantLogisticsStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantLogisticsStatusFindFirstArgs} args - Arguments to find a TenantLogisticsStatus
     * @example
     * // Get one TenantLogisticsStatus
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenantLogisticsStatusFindFirstArgs>(args?: SelectSubset<T, tenantLogisticsStatusFindFirstArgs<ExtArgs>>): Prisma__tenantLogisticsStatusClient<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantLogisticsStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantLogisticsStatusFindFirstOrThrowArgs} args - Arguments to find a TenantLogisticsStatus
     * @example
     * // Get one TenantLogisticsStatus
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenantLogisticsStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, tenantLogisticsStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenantLogisticsStatusClient<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantLogisticsStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantLogisticsStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantLogisticsStatuses
     * const tenantLogisticsStatuses = await prisma.tenantLogisticsStatus.findMany()
     * 
     * // Get first 10 TenantLogisticsStatuses
     * const tenantLogisticsStatuses = await prisma.tenantLogisticsStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantLogisticsStatusWithIdOnly = await prisma.tenantLogisticsStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenantLogisticsStatusFindManyArgs>(args?: SelectSubset<T, tenantLogisticsStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantLogisticsStatus.
     * @param {tenantLogisticsStatusCreateArgs} args - Arguments to create a TenantLogisticsStatus.
     * @example
     * // Create one TenantLogisticsStatus
     * const TenantLogisticsStatus = await prisma.tenantLogisticsStatus.create({
     *   data: {
     *     // ... data to create a TenantLogisticsStatus
     *   }
     * })
     * 
     */
    create<T extends tenantLogisticsStatusCreateArgs>(args: SelectSubset<T, tenantLogisticsStatusCreateArgs<ExtArgs>>): Prisma__tenantLogisticsStatusClient<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantLogisticsStatuses.
     * @param {tenantLogisticsStatusCreateManyArgs} args - Arguments to create many TenantLogisticsStatuses.
     * @example
     * // Create many TenantLogisticsStatuses
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenantLogisticsStatusCreateManyArgs>(args?: SelectSubset<T, tenantLogisticsStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantLogisticsStatuses and returns the data saved in the database.
     * @param {tenantLogisticsStatusCreateManyAndReturnArgs} args - Arguments to create many TenantLogisticsStatuses.
     * @example
     * // Create many TenantLogisticsStatuses
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantLogisticsStatuses and only return the `id`
     * const tenantLogisticsStatusWithIdOnly = await prisma.tenantLogisticsStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenantLogisticsStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, tenantLogisticsStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantLogisticsStatus.
     * @param {tenantLogisticsStatusDeleteArgs} args - Arguments to delete one TenantLogisticsStatus.
     * @example
     * // Delete one TenantLogisticsStatus
     * const TenantLogisticsStatus = await prisma.tenantLogisticsStatus.delete({
     *   where: {
     *     // ... filter to delete one TenantLogisticsStatus
     *   }
     * })
     * 
     */
    delete<T extends tenantLogisticsStatusDeleteArgs>(args: SelectSubset<T, tenantLogisticsStatusDeleteArgs<ExtArgs>>): Prisma__tenantLogisticsStatusClient<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantLogisticsStatus.
     * @param {tenantLogisticsStatusUpdateArgs} args - Arguments to update one TenantLogisticsStatus.
     * @example
     * // Update one TenantLogisticsStatus
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenantLogisticsStatusUpdateArgs>(args: SelectSubset<T, tenantLogisticsStatusUpdateArgs<ExtArgs>>): Prisma__tenantLogisticsStatusClient<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantLogisticsStatuses.
     * @param {tenantLogisticsStatusDeleteManyArgs} args - Arguments to filter TenantLogisticsStatuses to delete.
     * @example
     * // Delete a few TenantLogisticsStatuses
     * const { count } = await prisma.tenantLogisticsStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenantLogisticsStatusDeleteManyArgs>(args?: SelectSubset<T, tenantLogisticsStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantLogisticsStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantLogisticsStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantLogisticsStatuses
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenantLogisticsStatusUpdateManyArgs>(args: SelectSubset<T, tenantLogisticsStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantLogisticsStatuses and returns the data updated in the database.
     * @param {tenantLogisticsStatusUpdateManyAndReturnArgs} args - Arguments to update many TenantLogisticsStatuses.
     * @example
     * // Update many TenantLogisticsStatuses
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantLogisticsStatuses and only return the `id`
     * const tenantLogisticsStatusWithIdOnly = await prisma.tenantLogisticsStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tenantLogisticsStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, tenantLogisticsStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantLogisticsStatus.
     * @param {tenantLogisticsStatusUpsertArgs} args - Arguments to update or create a TenantLogisticsStatus.
     * @example
     * // Update or create a TenantLogisticsStatus
     * const tenantLogisticsStatus = await prisma.tenantLogisticsStatus.upsert({
     *   create: {
     *     // ... data to create a TenantLogisticsStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantLogisticsStatus we want to update
     *   }
     * })
     */
    upsert<T extends tenantLogisticsStatusUpsertArgs>(args: SelectSubset<T, tenantLogisticsStatusUpsertArgs<ExtArgs>>): Prisma__tenantLogisticsStatusClient<$Result.GetResult<Prisma.$tenantLogisticsStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantLogisticsStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantLogisticsStatusCountArgs} args - Arguments to filter TenantLogisticsStatuses to count.
     * @example
     * // Count the number of TenantLogisticsStatuses
     * const count = await prisma.tenantLogisticsStatus.count({
     *   where: {
     *     // ... the filter for the TenantLogisticsStatuses we want to count
     *   }
     * })
    **/
    count<T extends tenantLogisticsStatusCountArgs>(
      args?: Subset<T, tenantLogisticsStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantLogisticsStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantLogisticsStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLogisticsStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantLogisticsStatusAggregateArgs>(args: Subset<T, TenantLogisticsStatusAggregateArgs>): Prisma.PrismaPromise<GetTenantLogisticsStatusAggregateType<T>>

    /**
     * Group by TenantLogisticsStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantLogisticsStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenantLogisticsStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenantLogisticsStatusGroupByArgs['orderBy'] }
        : { orderBy?: tenantLogisticsStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenantLogisticsStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantLogisticsStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenantLogisticsStatus model
   */
  readonly fields: tenantLogisticsStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenantLogisticsStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenantLogisticsStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenantLogisticsStatus model
   */
  interface tenantLogisticsStatusFieldRefs {
    readonly id: FieldRef<"tenantLogisticsStatus", 'String'>
    readonly name: FieldRef<"tenantLogisticsStatus", 'String'>
    readonly is_active: FieldRef<"tenantLogisticsStatus", 'Boolean'>
    readonly created_at: FieldRef<"tenantLogisticsStatus", 'DateTime'>
    readonly updated_at: FieldRef<"tenantLogisticsStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tenantLogisticsStatus findUnique
   */
  export type tenantLogisticsStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantLogisticsStatus to fetch.
     */
    where: tenantLogisticsStatusWhereUniqueInput
  }

  /**
   * tenantLogisticsStatus findUniqueOrThrow
   */
  export type tenantLogisticsStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantLogisticsStatus to fetch.
     */
    where: tenantLogisticsStatusWhereUniqueInput
  }

  /**
   * tenantLogisticsStatus findFirst
   */
  export type tenantLogisticsStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantLogisticsStatus to fetch.
     */
    where?: tenantLogisticsStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantLogisticsStatuses to fetch.
     */
    orderBy?: tenantLogisticsStatusOrderByWithRelationInput | tenantLogisticsStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantLogisticsStatuses.
     */
    cursor?: tenantLogisticsStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantLogisticsStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantLogisticsStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantLogisticsStatuses.
     */
    distinct?: TenantLogisticsStatusScalarFieldEnum | TenantLogisticsStatusScalarFieldEnum[]
  }

  /**
   * tenantLogisticsStatus findFirstOrThrow
   */
  export type tenantLogisticsStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantLogisticsStatus to fetch.
     */
    where?: tenantLogisticsStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantLogisticsStatuses to fetch.
     */
    orderBy?: tenantLogisticsStatusOrderByWithRelationInput | tenantLogisticsStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantLogisticsStatuses.
     */
    cursor?: tenantLogisticsStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantLogisticsStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantLogisticsStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantLogisticsStatuses.
     */
    distinct?: TenantLogisticsStatusScalarFieldEnum | TenantLogisticsStatusScalarFieldEnum[]
  }

  /**
   * tenantLogisticsStatus findMany
   */
  export type tenantLogisticsStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantLogisticsStatuses to fetch.
     */
    where?: tenantLogisticsStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantLogisticsStatuses to fetch.
     */
    orderBy?: tenantLogisticsStatusOrderByWithRelationInput | tenantLogisticsStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenantLogisticsStatuses.
     */
    cursor?: tenantLogisticsStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantLogisticsStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantLogisticsStatuses.
     */
    skip?: number
    distinct?: TenantLogisticsStatusScalarFieldEnum | TenantLogisticsStatusScalarFieldEnum[]
  }

  /**
   * tenantLogisticsStatus create
   */
  export type tenantLogisticsStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a tenantLogisticsStatus.
     */
    data: XOR<tenantLogisticsStatusCreateInput, tenantLogisticsStatusUncheckedCreateInput>
  }

  /**
   * tenantLogisticsStatus createMany
   */
  export type tenantLogisticsStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenantLogisticsStatuses.
     */
    data: tenantLogisticsStatusCreateManyInput | tenantLogisticsStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantLogisticsStatus createManyAndReturn
   */
  export type tenantLogisticsStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * The data used to create many tenantLogisticsStatuses.
     */
    data: tenantLogisticsStatusCreateManyInput | tenantLogisticsStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantLogisticsStatus update
   */
  export type tenantLogisticsStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a tenantLogisticsStatus.
     */
    data: XOR<tenantLogisticsStatusUpdateInput, tenantLogisticsStatusUncheckedUpdateInput>
    /**
     * Choose, which tenantLogisticsStatus to update.
     */
    where: tenantLogisticsStatusWhereUniqueInput
  }

  /**
   * tenantLogisticsStatus updateMany
   */
  export type tenantLogisticsStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenantLogisticsStatuses.
     */
    data: XOR<tenantLogisticsStatusUpdateManyMutationInput, tenantLogisticsStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantLogisticsStatuses to update
     */
    where?: tenantLogisticsStatusWhereInput
    /**
     * Limit how many tenantLogisticsStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantLogisticsStatus updateManyAndReturn
   */
  export type tenantLogisticsStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * The data used to update tenantLogisticsStatuses.
     */
    data: XOR<tenantLogisticsStatusUpdateManyMutationInput, tenantLogisticsStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantLogisticsStatuses to update
     */
    where?: tenantLogisticsStatusWhereInput
    /**
     * Limit how many tenantLogisticsStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantLogisticsStatus upsert
   */
  export type tenantLogisticsStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the tenantLogisticsStatus to update in case it exists.
     */
    where: tenantLogisticsStatusWhereUniqueInput
    /**
     * In case the tenantLogisticsStatus found by the `where` argument doesn't exist, create a new tenantLogisticsStatus with this data.
     */
    create: XOR<tenantLogisticsStatusCreateInput, tenantLogisticsStatusUncheckedCreateInput>
    /**
     * In case the tenantLogisticsStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenantLogisticsStatusUpdateInput, tenantLogisticsStatusUncheckedUpdateInput>
  }

  /**
   * tenantLogisticsStatus delete
   */
  export type tenantLogisticsStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
    /**
     * Filter which tenantLogisticsStatus to delete.
     */
    where: tenantLogisticsStatusWhereUniqueInput
  }

  /**
   * tenantLogisticsStatus deleteMany
   */
  export type tenantLogisticsStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantLogisticsStatuses to delete
     */
    where?: tenantLogisticsStatusWhereInput
    /**
     * Limit how many tenantLogisticsStatuses to delete.
     */
    limit?: number
  }

  /**
   * tenantLogisticsStatus without action
   */
  export type tenantLogisticsStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantLogisticsStatus
     */
    select?: tenantLogisticsStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantLogisticsStatus
     */
    omit?: tenantLogisticsStatusOmit<ExtArgs> | null
  }


  /**
   * Model tenantFinanceStatus
   */

  export type AggregateTenantFinanceStatus = {
    _count: TenantFinanceStatusCountAggregateOutputType | null
    _min: TenantFinanceStatusMinAggregateOutputType | null
    _max: TenantFinanceStatusMaxAggregateOutputType | null
  }

  export type TenantFinanceStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantFinanceStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantFinanceStatusCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantFinanceStatusMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantFinanceStatusMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantFinanceStatusCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantFinanceStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantFinanceStatus to aggregate.
     */
    where?: tenantFinanceStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantFinanceStatuses to fetch.
     */
    orderBy?: tenantFinanceStatusOrderByWithRelationInput | tenantFinanceStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenantFinanceStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantFinanceStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantFinanceStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenantFinanceStatuses
    **/
    _count?: true | TenantFinanceStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantFinanceStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantFinanceStatusMaxAggregateInputType
  }

  export type GetTenantFinanceStatusAggregateType<T extends TenantFinanceStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantFinanceStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantFinanceStatus[P]>
      : GetScalarType<T[P], AggregateTenantFinanceStatus[P]>
  }




  export type tenantFinanceStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenantFinanceStatusWhereInput
    orderBy?: tenantFinanceStatusOrderByWithAggregationInput | tenantFinanceStatusOrderByWithAggregationInput[]
    by: TenantFinanceStatusScalarFieldEnum[] | TenantFinanceStatusScalarFieldEnum
    having?: tenantFinanceStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantFinanceStatusCountAggregateInputType | true
    _min?: TenantFinanceStatusMinAggregateInputType
    _max?: TenantFinanceStatusMaxAggregateInputType
  }

  export type TenantFinanceStatusGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantFinanceStatusCountAggregateOutputType | null
    _min: TenantFinanceStatusMinAggregateOutputType | null
    _max: TenantFinanceStatusMaxAggregateOutputType | null
  }

  type GetTenantFinanceStatusGroupByPayload<T extends tenantFinanceStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantFinanceStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantFinanceStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantFinanceStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TenantFinanceStatusGroupByOutputType[P]>
        }
      >
    >


  export type tenantFinanceStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantFinanceStatus"]>

  export type tenantFinanceStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantFinanceStatus"]>

  export type tenantFinanceStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenantFinanceStatus"]>

  export type tenantFinanceStatusSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tenantFinanceStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenantFinanceStatus"]>

  export type $tenantFinanceStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenantFinanceStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenantFinanceStatus"]>
    composites: {}
  }

  type tenantFinanceStatusGetPayload<S extends boolean | null | undefined | tenantFinanceStatusDefaultArgs> = $Result.GetResult<Prisma.$tenantFinanceStatusPayload, S>

  type tenantFinanceStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tenantFinanceStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantFinanceStatusCountAggregateInputType | true
    }

  export interface tenantFinanceStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenantFinanceStatus'], meta: { name: 'tenantFinanceStatus' } }
    /**
     * Find zero or one TenantFinanceStatus that matches the filter.
     * @param {tenantFinanceStatusFindUniqueArgs} args - Arguments to find a TenantFinanceStatus
     * @example
     * // Get one TenantFinanceStatus
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenantFinanceStatusFindUniqueArgs>(args: SelectSubset<T, tenantFinanceStatusFindUniqueArgs<ExtArgs>>): Prisma__tenantFinanceStatusClient<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantFinanceStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tenantFinanceStatusFindUniqueOrThrowArgs} args - Arguments to find a TenantFinanceStatus
     * @example
     * // Get one TenantFinanceStatus
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenantFinanceStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, tenantFinanceStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenantFinanceStatusClient<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantFinanceStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantFinanceStatusFindFirstArgs} args - Arguments to find a TenantFinanceStatus
     * @example
     * // Get one TenantFinanceStatus
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenantFinanceStatusFindFirstArgs>(args?: SelectSubset<T, tenantFinanceStatusFindFirstArgs<ExtArgs>>): Prisma__tenantFinanceStatusClient<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantFinanceStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantFinanceStatusFindFirstOrThrowArgs} args - Arguments to find a TenantFinanceStatus
     * @example
     * // Get one TenantFinanceStatus
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenantFinanceStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, tenantFinanceStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenantFinanceStatusClient<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantFinanceStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantFinanceStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantFinanceStatuses
     * const tenantFinanceStatuses = await prisma.tenantFinanceStatus.findMany()
     * 
     * // Get first 10 TenantFinanceStatuses
     * const tenantFinanceStatuses = await prisma.tenantFinanceStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantFinanceStatusWithIdOnly = await prisma.tenantFinanceStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenantFinanceStatusFindManyArgs>(args?: SelectSubset<T, tenantFinanceStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantFinanceStatus.
     * @param {tenantFinanceStatusCreateArgs} args - Arguments to create a TenantFinanceStatus.
     * @example
     * // Create one TenantFinanceStatus
     * const TenantFinanceStatus = await prisma.tenantFinanceStatus.create({
     *   data: {
     *     // ... data to create a TenantFinanceStatus
     *   }
     * })
     * 
     */
    create<T extends tenantFinanceStatusCreateArgs>(args: SelectSubset<T, tenantFinanceStatusCreateArgs<ExtArgs>>): Prisma__tenantFinanceStatusClient<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantFinanceStatuses.
     * @param {tenantFinanceStatusCreateManyArgs} args - Arguments to create many TenantFinanceStatuses.
     * @example
     * // Create many TenantFinanceStatuses
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenantFinanceStatusCreateManyArgs>(args?: SelectSubset<T, tenantFinanceStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantFinanceStatuses and returns the data saved in the database.
     * @param {tenantFinanceStatusCreateManyAndReturnArgs} args - Arguments to create many TenantFinanceStatuses.
     * @example
     * // Create many TenantFinanceStatuses
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantFinanceStatuses and only return the `id`
     * const tenantFinanceStatusWithIdOnly = await prisma.tenantFinanceStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenantFinanceStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, tenantFinanceStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantFinanceStatus.
     * @param {tenantFinanceStatusDeleteArgs} args - Arguments to delete one TenantFinanceStatus.
     * @example
     * // Delete one TenantFinanceStatus
     * const TenantFinanceStatus = await prisma.tenantFinanceStatus.delete({
     *   where: {
     *     // ... filter to delete one TenantFinanceStatus
     *   }
     * })
     * 
     */
    delete<T extends tenantFinanceStatusDeleteArgs>(args: SelectSubset<T, tenantFinanceStatusDeleteArgs<ExtArgs>>): Prisma__tenantFinanceStatusClient<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantFinanceStatus.
     * @param {tenantFinanceStatusUpdateArgs} args - Arguments to update one TenantFinanceStatus.
     * @example
     * // Update one TenantFinanceStatus
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenantFinanceStatusUpdateArgs>(args: SelectSubset<T, tenantFinanceStatusUpdateArgs<ExtArgs>>): Prisma__tenantFinanceStatusClient<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantFinanceStatuses.
     * @param {tenantFinanceStatusDeleteManyArgs} args - Arguments to filter TenantFinanceStatuses to delete.
     * @example
     * // Delete a few TenantFinanceStatuses
     * const { count } = await prisma.tenantFinanceStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenantFinanceStatusDeleteManyArgs>(args?: SelectSubset<T, tenantFinanceStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantFinanceStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantFinanceStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantFinanceStatuses
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenantFinanceStatusUpdateManyArgs>(args: SelectSubset<T, tenantFinanceStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantFinanceStatuses and returns the data updated in the database.
     * @param {tenantFinanceStatusUpdateManyAndReturnArgs} args - Arguments to update many TenantFinanceStatuses.
     * @example
     * // Update many TenantFinanceStatuses
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantFinanceStatuses and only return the `id`
     * const tenantFinanceStatusWithIdOnly = await prisma.tenantFinanceStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tenantFinanceStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, tenantFinanceStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantFinanceStatus.
     * @param {tenantFinanceStatusUpsertArgs} args - Arguments to update or create a TenantFinanceStatus.
     * @example
     * // Update or create a TenantFinanceStatus
     * const tenantFinanceStatus = await prisma.tenantFinanceStatus.upsert({
     *   create: {
     *     // ... data to create a TenantFinanceStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantFinanceStatus we want to update
     *   }
     * })
     */
    upsert<T extends tenantFinanceStatusUpsertArgs>(args: SelectSubset<T, tenantFinanceStatusUpsertArgs<ExtArgs>>): Prisma__tenantFinanceStatusClient<$Result.GetResult<Prisma.$tenantFinanceStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantFinanceStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantFinanceStatusCountArgs} args - Arguments to filter TenantFinanceStatuses to count.
     * @example
     * // Count the number of TenantFinanceStatuses
     * const count = await prisma.tenantFinanceStatus.count({
     *   where: {
     *     // ... the filter for the TenantFinanceStatuses we want to count
     *   }
     * })
    **/
    count<T extends tenantFinanceStatusCountArgs>(
      args?: Subset<T, tenantFinanceStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantFinanceStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantFinanceStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFinanceStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantFinanceStatusAggregateArgs>(args: Subset<T, TenantFinanceStatusAggregateArgs>): Prisma.PrismaPromise<GetTenantFinanceStatusAggregateType<T>>

    /**
     * Group by TenantFinanceStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenantFinanceStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenantFinanceStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenantFinanceStatusGroupByArgs['orderBy'] }
        : { orderBy?: tenantFinanceStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenantFinanceStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantFinanceStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenantFinanceStatus model
   */
  readonly fields: tenantFinanceStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenantFinanceStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenantFinanceStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenantFinanceStatus model
   */
  interface tenantFinanceStatusFieldRefs {
    readonly id: FieldRef<"tenantFinanceStatus", 'String'>
    readonly name: FieldRef<"tenantFinanceStatus", 'String'>
    readonly is_active: FieldRef<"tenantFinanceStatus", 'Boolean'>
    readonly created_at: FieldRef<"tenantFinanceStatus", 'DateTime'>
    readonly updated_at: FieldRef<"tenantFinanceStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tenantFinanceStatus findUnique
   */
  export type tenantFinanceStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantFinanceStatus to fetch.
     */
    where: tenantFinanceStatusWhereUniqueInput
  }

  /**
   * tenantFinanceStatus findUniqueOrThrow
   */
  export type tenantFinanceStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantFinanceStatus to fetch.
     */
    where: tenantFinanceStatusWhereUniqueInput
  }

  /**
   * tenantFinanceStatus findFirst
   */
  export type tenantFinanceStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantFinanceStatus to fetch.
     */
    where?: tenantFinanceStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantFinanceStatuses to fetch.
     */
    orderBy?: tenantFinanceStatusOrderByWithRelationInput | tenantFinanceStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantFinanceStatuses.
     */
    cursor?: tenantFinanceStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantFinanceStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantFinanceStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantFinanceStatuses.
     */
    distinct?: TenantFinanceStatusScalarFieldEnum | TenantFinanceStatusScalarFieldEnum[]
  }

  /**
   * tenantFinanceStatus findFirstOrThrow
   */
  export type tenantFinanceStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantFinanceStatus to fetch.
     */
    where?: tenantFinanceStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantFinanceStatuses to fetch.
     */
    orderBy?: tenantFinanceStatusOrderByWithRelationInput | tenantFinanceStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenantFinanceStatuses.
     */
    cursor?: tenantFinanceStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantFinanceStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantFinanceStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenantFinanceStatuses.
     */
    distinct?: TenantFinanceStatusScalarFieldEnum | TenantFinanceStatusScalarFieldEnum[]
  }

  /**
   * tenantFinanceStatus findMany
   */
  export type tenantFinanceStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * Filter, which tenantFinanceStatuses to fetch.
     */
    where?: tenantFinanceStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenantFinanceStatuses to fetch.
     */
    orderBy?: tenantFinanceStatusOrderByWithRelationInput | tenantFinanceStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenantFinanceStatuses.
     */
    cursor?: tenantFinanceStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenantFinanceStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenantFinanceStatuses.
     */
    skip?: number
    distinct?: TenantFinanceStatusScalarFieldEnum | TenantFinanceStatusScalarFieldEnum[]
  }

  /**
   * tenantFinanceStatus create
   */
  export type tenantFinanceStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a tenantFinanceStatus.
     */
    data: XOR<tenantFinanceStatusCreateInput, tenantFinanceStatusUncheckedCreateInput>
  }

  /**
   * tenantFinanceStatus createMany
   */
  export type tenantFinanceStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenantFinanceStatuses.
     */
    data: tenantFinanceStatusCreateManyInput | tenantFinanceStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantFinanceStatus createManyAndReturn
   */
  export type tenantFinanceStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * The data used to create many tenantFinanceStatuses.
     */
    data: tenantFinanceStatusCreateManyInput | tenantFinanceStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenantFinanceStatus update
   */
  export type tenantFinanceStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a tenantFinanceStatus.
     */
    data: XOR<tenantFinanceStatusUpdateInput, tenantFinanceStatusUncheckedUpdateInput>
    /**
     * Choose, which tenantFinanceStatus to update.
     */
    where: tenantFinanceStatusWhereUniqueInput
  }

  /**
   * tenantFinanceStatus updateMany
   */
  export type tenantFinanceStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenantFinanceStatuses.
     */
    data: XOR<tenantFinanceStatusUpdateManyMutationInput, tenantFinanceStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantFinanceStatuses to update
     */
    where?: tenantFinanceStatusWhereInput
    /**
     * Limit how many tenantFinanceStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantFinanceStatus updateManyAndReturn
   */
  export type tenantFinanceStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * The data used to update tenantFinanceStatuses.
     */
    data: XOR<tenantFinanceStatusUpdateManyMutationInput, tenantFinanceStatusUncheckedUpdateManyInput>
    /**
     * Filter which tenantFinanceStatuses to update
     */
    where?: tenantFinanceStatusWhereInput
    /**
     * Limit how many tenantFinanceStatuses to update.
     */
    limit?: number
  }

  /**
   * tenantFinanceStatus upsert
   */
  export type tenantFinanceStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the tenantFinanceStatus to update in case it exists.
     */
    where: tenantFinanceStatusWhereUniqueInput
    /**
     * In case the tenantFinanceStatus found by the `where` argument doesn't exist, create a new tenantFinanceStatus with this data.
     */
    create: XOR<tenantFinanceStatusCreateInput, tenantFinanceStatusUncheckedCreateInput>
    /**
     * In case the tenantFinanceStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenantFinanceStatusUpdateInput, tenantFinanceStatusUncheckedUpdateInput>
  }

  /**
   * tenantFinanceStatus delete
   */
  export type tenantFinanceStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
    /**
     * Filter which tenantFinanceStatus to delete.
     */
    where: tenantFinanceStatusWhereUniqueInput
  }

  /**
   * tenantFinanceStatus deleteMany
   */
  export type tenantFinanceStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenantFinanceStatuses to delete
     */
    where?: tenantFinanceStatusWhereInput
    /**
     * Limit how many tenantFinanceStatuses to delete.
     */
    limit?: number
  }

  /**
   * tenantFinanceStatus without action
   */
  export type tenantFinanceStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenantFinanceStatus
     */
    select?: tenantFinanceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tenantFinanceStatus
     */
    omit?: tenantFinanceStatusOmit<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    customer_id: number | null
    sorting: number | null
  }

  export type CustomerSumAggregateOutputType = {
    customer_id: number | null
    sorting: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    customer_id: number | null
    first_name: string | null
    last_name: string | null
    customer_name: string | null
    company_name: string | null
    email: string | null
    password: string | null
    phone: string | null
    type: string | null
    website: string | null
    is_active: string | null
    notes: string | null
    sorting: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    user_id: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    customer_id: number | null
    first_name: string | null
    last_name: string | null
    customer_name: string | null
    company_name: string | null
    email: string | null
    password: string | null
    phone: string | null
    type: string | null
    website: string | null
    is_active: string | null
    notes: string | null
    sorting: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    user_id: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    customer_id: number
    first_name: number
    last_name: number
    customer_name: number
    company_name: number
    email: number
    password: number
    phone: number
    type: number
    website: number
    is_active: number
    notes: number
    sorting: number
    created_at: number
    updated_at: number
    deleted_at: number
    user_id: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    customer_id?: true
    sorting?: true
  }

  export type CustomerSumAggregateInputType = {
    customer_id?: true
    sorting?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    customer_id?: true
    first_name?: true
    last_name?: true
    customer_name?: true
    company_name?: true
    email?: true
    password?: true
    phone?: true
    type?: true
    website?: true
    is_active?: true
    notes?: true
    sorting?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    user_id?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    customer_id?: true
    first_name?: true
    last_name?: true
    customer_name?: true
    company_name?: true
    email?: true
    password?: true
    phone?: true
    type?: true
    website?: true
    is_active?: true
    notes?: true
    sorting?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    user_id?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    customer_id?: true
    first_name?: true
    last_name?: true
    customer_name?: true
    company_name?: true
    email?: true
    password?: true
    phone?: true
    type?: true
    website?: true
    is_active?: true
    notes?: true
    sorting?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    user_id?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    customer_id: number
    first_name: string
    last_name: string
    customer_name: string
    company_name: string | null
    email: string
    password: string
    phone: string | null
    type: string | null
    website: string | null
    is_active: string
    notes: string | null
    sorting: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    user_id: string | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    first_name?: boolean
    last_name?: boolean
    customer_name?: boolean
    company_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    type?: boolean
    website?: boolean
    is_active?: boolean
    notes?: boolean
    sorting?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_id?: boolean
    user?: boolean | Customer$userArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    tax_info?: boolean | Customer$tax_infoArgs<ExtArgs>
    contacts?: boolean | Customer$contactsArgs<ExtArgs>
    operational?: boolean | Customer$operationalArgs<ExtArgs>
    attachments?: boolean | Customer$attachmentsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    first_name?: boolean
    last_name?: boolean
    customer_name?: boolean
    company_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    type?: boolean
    website?: boolean
    is_active?: boolean
    notes?: boolean
    sorting?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_id?: boolean
    user?: boolean | Customer$userArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    first_name?: boolean
    last_name?: boolean
    customer_name?: boolean
    company_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    type?: boolean
    website?: boolean
    is_active?: boolean
    notes?: boolean
    sorting?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_id?: boolean
    user?: boolean | Customer$userArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    customer_id?: boolean
    first_name?: boolean
    last_name?: boolean
    customer_name?: boolean
    company_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    type?: boolean
    website?: boolean
    is_active?: boolean
    notes?: boolean
    sorting?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_id?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "first_name" | "last_name" | "customer_name" | "company_name" | "email" | "password" | "phone" | "type" | "website" | "is_active" | "notes" | "sorting" | "created_at" | "updated_at" | "deleted_at" | "user_id", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Customer$userArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    tax_info?: boolean | Customer$tax_infoArgs<ExtArgs>
    contacts?: boolean | Customer$contactsArgs<ExtArgs>
    operational?: boolean | Customer$operationalArgs<ExtArgs>
    attachments?: boolean | Customer$attachmentsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Customer$userArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Customer$userArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      addresses: Prisma.$CustomerAddressPayload<ExtArgs>[]
      tax_info: Prisma.$CustomerTaxInfoPayload<ExtArgs> | null
      contacts: Prisma.$CustomerContactPayload<ExtArgs>[]
      operational: Prisma.$CustomerOperationalInfoPayload<ExtArgs> | null
      attachments: Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: number
      first_name: string
      last_name: string
      customer_name: string
      company_name: string | null
      email: string
      password: string
      phone: string | null
      type: string | null
      website: string | null
      is_active: string
      notes: string | null
      sorting: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      user_id: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Customer$userArgs<ExtArgs> = {}>(args?: Subset<T, Customer$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    addresses<T extends Customer$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tax_info<T extends Customer$tax_infoArgs<ExtArgs> = {}>(args?: Subset<T, Customer$tax_infoArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contacts<T extends Customer$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operational<T extends Customer$operationalArgs<ExtArgs> = {}>(args?: Subset<T, Customer$operationalArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Customer$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly customer_id: FieldRef<"Customer", 'Int'>
    readonly first_name: FieldRef<"Customer", 'String'>
    readonly last_name: FieldRef<"Customer", 'String'>
    readonly customer_name: FieldRef<"Customer", 'String'>
    readonly company_name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly type: FieldRef<"Customer", 'String'>
    readonly website: FieldRef<"Customer", 'String'>
    readonly is_active: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly sorting: FieldRef<"Customer", 'Int'>
    readonly created_at: FieldRef<"Customer", 'DateTime'>
    readonly updated_at: FieldRef<"Customer", 'DateTime'>
    readonly deleted_at: FieldRef<"Customer", 'DateTime'>
    readonly user_id: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.user
   */
  export type Customer$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Customer.addresses
   */
  export type Customer$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    cursor?: CustomerAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * Customer.tax_info
   */
  export type Customer$tax_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    where?: CustomerTaxInfoWhereInput
  }

  /**
   * Customer.contacts
   */
  export type Customer$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    where?: CustomerContactWhereInput
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    cursor?: CustomerContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerContactScalarFieldEnum | CustomerContactScalarFieldEnum[]
  }

  /**
   * Customer.operational
   */
  export type Customer$operationalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    where?: CustomerOperationalInfoWhereInput
  }

  /**
   * Customer.attachments
   */
  export type Customer$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    where?: CustomerNotesAndAttachmentsWhereInput
    orderBy?: CustomerNotesAndAttachmentsOrderByWithRelationInput | CustomerNotesAndAttachmentsOrderByWithRelationInput[]
    cursor?: CustomerNotesAndAttachmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerNotesAndAttachmentsScalarFieldEnum | CustomerNotesAndAttachmentsScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model companyService
   */

  export type AggregateCompanyService = {
    _count: CompanyServiceCountAggregateOutputType | null
    _min: CompanyServiceMinAggregateOutputType | null
    _max: CompanyServiceMaxAggregateOutputType | null
  }

  export type CompanyServiceMinAggregateOutputType = {
    id: string | null
    exclude_inspection: boolean | null
    invoice50: boolean | null
    fob_china: boolean | null
    require_deposit_invoice: boolean | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompanyServiceMaxAggregateOutputType = {
    id: string | null
    exclude_inspection: boolean | null
    invoice50: boolean | null
    fob_china: boolean | null
    require_deposit_invoice: boolean | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompanyServiceCountAggregateOutputType = {
    id: number
    exclude_inspection: number
    invoice50: number
    fob_china: number
    require_deposit_invoice: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CompanyServiceMinAggregateInputType = {
    id?: true
    exclude_inspection?: true
    invoice50?: true
    fob_china?: true
    require_deposit_invoice?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CompanyServiceMaxAggregateInputType = {
    id?: true
    exclude_inspection?: true
    invoice50?: true
    fob_china?: true
    require_deposit_invoice?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CompanyServiceCountAggregateInputType = {
    id?: true
    exclude_inspection?: true
    invoice50?: true
    fob_china?: true
    require_deposit_invoice?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CompanyServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyService to aggregate.
     */
    where?: companyServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyServices to fetch.
     */
    orderBy?: companyServiceOrderByWithRelationInput | companyServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companyServices
    **/
    _count?: true | CompanyServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyServiceMaxAggregateInputType
  }

  export type GetCompanyServiceAggregateType<T extends CompanyServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyService[P]>
      : GetScalarType<T[P], AggregateCompanyService[P]>
  }




  export type companyServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyServiceWhereInput
    orderBy?: companyServiceOrderByWithAggregationInput | companyServiceOrderByWithAggregationInput[]
    by: CompanyServiceScalarFieldEnum[] | CompanyServiceScalarFieldEnum
    having?: companyServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyServiceCountAggregateInputType | true
    _min?: CompanyServiceMinAggregateInputType
    _max?: CompanyServiceMaxAggregateInputType
  }

  export type CompanyServiceGroupByOutputType = {
    id: string
    exclude_inspection: boolean
    invoice50: boolean
    fob_china: boolean
    require_deposit_invoice: boolean
    name: string
    created_at: Date
    updated_at: Date
    _count: CompanyServiceCountAggregateOutputType | null
    _min: CompanyServiceMinAggregateOutputType | null
    _max: CompanyServiceMaxAggregateOutputType | null
  }

  type GetCompanyServiceGroupByPayload<T extends companyServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyServiceGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyServiceGroupByOutputType[P]>
        }
      >
    >


  export type companyServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    materials?: boolean | companyService$materialsArgs<ExtArgs>
    finishes?: boolean | companyService$finishesArgs<ExtArgs>
    _count?: boolean | CompanyServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyService"]>

  export type companyServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["companyService"]>

  export type companyServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["companyService"]>

  export type companyServiceSelectScalar = {
    id?: boolean
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type companyServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exclude_inspection" | "invoice50" | "fob_china" | "require_deposit_invoice" | "name" | "created_at" | "updated_at", ExtArgs["result"]["companyService"]>
  export type companyServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | companyService$materialsArgs<ExtArgs>
    finishes?: boolean | companyService$finishesArgs<ExtArgs>
    _count?: boolean | CompanyServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companyServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type companyServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $companyServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companyService"
    objects: {
      materials: Prisma.$companyMaterialPayload<ExtArgs>[]
      finishes: Prisma.$companyFinishPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      exclude_inspection: boolean
      invoice50: boolean
      fob_china: boolean
      require_deposit_invoice: boolean
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["companyService"]>
    composites: {}
  }

  type companyServiceGetPayload<S extends boolean | null | undefined | companyServiceDefaultArgs> = $Result.GetResult<Prisma.$companyServicePayload, S>

  type companyServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companyServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyServiceCountAggregateInputType | true
    }

  export interface companyServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companyService'], meta: { name: 'companyService' } }
    /**
     * Find zero or one CompanyService that matches the filter.
     * @param {companyServiceFindUniqueArgs} args - Arguments to find a CompanyService
     * @example
     * // Get one CompanyService
     * const companyService = await prisma.companyService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companyServiceFindUniqueArgs>(args: SelectSubset<T, companyServiceFindUniqueArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companyServiceFindUniqueOrThrowArgs} args - Arguments to find a CompanyService
     * @example
     * // Get one CompanyService
     * const companyService = await prisma.companyService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companyServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, companyServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyServiceFindFirstArgs} args - Arguments to find a CompanyService
     * @example
     * // Get one CompanyService
     * const companyService = await prisma.companyService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companyServiceFindFirstArgs>(args?: SelectSubset<T, companyServiceFindFirstArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyServiceFindFirstOrThrowArgs} args - Arguments to find a CompanyService
     * @example
     * // Get one CompanyService
     * const companyService = await prisma.companyService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companyServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, companyServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyServices
     * const companyServices = await prisma.companyService.findMany()
     * 
     * // Get first 10 CompanyServices
     * const companyServices = await prisma.companyService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyServiceWithIdOnly = await prisma.companyService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companyServiceFindManyArgs>(args?: SelectSubset<T, companyServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyService.
     * @param {companyServiceCreateArgs} args - Arguments to create a CompanyService.
     * @example
     * // Create one CompanyService
     * const CompanyService = await prisma.companyService.create({
     *   data: {
     *     // ... data to create a CompanyService
     *   }
     * })
     * 
     */
    create<T extends companyServiceCreateArgs>(args: SelectSubset<T, companyServiceCreateArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyServices.
     * @param {companyServiceCreateManyArgs} args - Arguments to create many CompanyServices.
     * @example
     * // Create many CompanyServices
     * const companyService = await prisma.companyService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companyServiceCreateManyArgs>(args?: SelectSubset<T, companyServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyServices and returns the data saved in the database.
     * @param {companyServiceCreateManyAndReturnArgs} args - Arguments to create many CompanyServices.
     * @example
     * // Create many CompanyServices
     * const companyService = await prisma.companyService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyServices and only return the `id`
     * const companyServiceWithIdOnly = await prisma.companyService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companyServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, companyServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyService.
     * @param {companyServiceDeleteArgs} args - Arguments to delete one CompanyService.
     * @example
     * // Delete one CompanyService
     * const CompanyService = await prisma.companyService.delete({
     *   where: {
     *     // ... filter to delete one CompanyService
     *   }
     * })
     * 
     */
    delete<T extends companyServiceDeleteArgs>(args: SelectSubset<T, companyServiceDeleteArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyService.
     * @param {companyServiceUpdateArgs} args - Arguments to update one CompanyService.
     * @example
     * // Update one CompanyService
     * const companyService = await prisma.companyService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companyServiceUpdateArgs>(args: SelectSubset<T, companyServiceUpdateArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyServices.
     * @param {companyServiceDeleteManyArgs} args - Arguments to filter CompanyServices to delete.
     * @example
     * // Delete a few CompanyServices
     * const { count } = await prisma.companyService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companyServiceDeleteManyArgs>(args?: SelectSubset<T, companyServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyServices
     * const companyService = await prisma.companyService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companyServiceUpdateManyArgs>(args: SelectSubset<T, companyServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyServices and returns the data updated in the database.
     * @param {companyServiceUpdateManyAndReturnArgs} args - Arguments to update many CompanyServices.
     * @example
     * // Update many CompanyServices
     * const companyService = await prisma.companyService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyServices and only return the `id`
     * const companyServiceWithIdOnly = await prisma.companyService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companyServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, companyServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyService.
     * @param {companyServiceUpsertArgs} args - Arguments to update or create a CompanyService.
     * @example
     * // Update or create a CompanyService
     * const companyService = await prisma.companyService.upsert({
     *   create: {
     *     // ... data to create a CompanyService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyService we want to update
     *   }
     * })
     */
    upsert<T extends companyServiceUpsertArgs>(args: SelectSubset<T, companyServiceUpsertArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyServiceCountArgs} args - Arguments to filter CompanyServices to count.
     * @example
     * // Count the number of CompanyServices
     * const count = await prisma.companyService.count({
     *   where: {
     *     // ... the filter for the CompanyServices we want to count
     *   }
     * })
    **/
    count<T extends companyServiceCountArgs>(
      args?: Subset<T, companyServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyServiceAggregateArgs>(args: Subset<T, CompanyServiceAggregateArgs>): Prisma.PrismaPromise<GetCompanyServiceAggregateType<T>>

    /**
     * Group by CompanyService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyServiceGroupByArgs['orderBy'] }
        : { orderBy?: companyServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companyService model
   */
  readonly fields: companyServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companyService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materials<T extends companyService$materialsArgs<ExtArgs> = {}>(args?: Subset<T, companyService$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    finishes<T extends companyService$finishesArgs<ExtArgs> = {}>(args?: Subset<T, companyService$finishesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companyService model
   */
  interface companyServiceFieldRefs {
    readonly id: FieldRef<"companyService", 'String'>
    readonly exclude_inspection: FieldRef<"companyService", 'Boolean'>
    readonly invoice50: FieldRef<"companyService", 'Boolean'>
    readonly fob_china: FieldRef<"companyService", 'Boolean'>
    readonly require_deposit_invoice: FieldRef<"companyService", 'Boolean'>
    readonly name: FieldRef<"companyService", 'String'>
    readonly created_at: FieldRef<"companyService", 'DateTime'>
    readonly updated_at: FieldRef<"companyService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * companyService findUnique
   */
  export type companyServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * Filter, which companyService to fetch.
     */
    where: companyServiceWhereUniqueInput
  }

  /**
   * companyService findUniqueOrThrow
   */
  export type companyServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * Filter, which companyService to fetch.
     */
    where: companyServiceWhereUniqueInput
  }

  /**
   * companyService findFirst
   */
  export type companyServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * Filter, which companyService to fetch.
     */
    where?: companyServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyServices to fetch.
     */
    orderBy?: companyServiceOrderByWithRelationInput | companyServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyServices.
     */
    cursor?: companyServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyServices.
     */
    distinct?: CompanyServiceScalarFieldEnum | CompanyServiceScalarFieldEnum[]
  }

  /**
   * companyService findFirstOrThrow
   */
  export type companyServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * Filter, which companyService to fetch.
     */
    where?: companyServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyServices to fetch.
     */
    orderBy?: companyServiceOrderByWithRelationInput | companyServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyServices.
     */
    cursor?: companyServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyServices.
     */
    distinct?: CompanyServiceScalarFieldEnum | CompanyServiceScalarFieldEnum[]
  }

  /**
   * companyService findMany
   */
  export type companyServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * Filter, which companyServices to fetch.
     */
    where?: companyServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyServices to fetch.
     */
    orderBy?: companyServiceOrderByWithRelationInput | companyServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companyServices.
     */
    cursor?: companyServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyServices.
     */
    skip?: number
    distinct?: CompanyServiceScalarFieldEnum | CompanyServiceScalarFieldEnum[]
  }

  /**
   * companyService create
   */
  export type companyServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a companyService.
     */
    data: XOR<companyServiceCreateInput, companyServiceUncheckedCreateInput>
  }

  /**
   * companyService createMany
   */
  export type companyServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companyServices.
     */
    data: companyServiceCreateManyInput | companyServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companyService createManyAndReturn
   */
  export type companyServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * The data used to create many companyServices.
     */
    data: companyServiceCreateManyInput | companyServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companyService update
   */
  export type companyServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a companyService.
     */
    data: XOR<companyServiceUpdateInput, companyServiceUncheckedUpdateInput>
    /**
     * Choose, which companyService to update.
     */
    where: companyServiceWhereUniqueInput
  }

  /**
   * companyService updateMany
   */
  export type companyServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companyServices.
     */
    data: XOR<companyServiceUpdateManyMutationInput, companyServiceUncheckedUpdateManyInput>
    /**
     * Filter which companyServices to update
     */
    where?: companyServiceWhereInput
    /**
     * Limit how many companyServices to update.
     */
    limit?: number
  }

  /**
   * companyService updateManyAndReturn
   */
  export type companyServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * The data used to update companyServices.
     */
    data: XOR<companyServiceUpdateManyMutationInput, companyServiceUncheckedUpdateManyInput>
    /**
     * Filter which companyServices to update
     */
    where?: companyServiceWhereInput
    /**
     * Limit how many companyServices to update.
     */
    limit?: number
  }

  /**
   * companyService upsert
   */
  export type companyServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the companyService to update in case it exists.
     */
    where: companyServiceWhereUniqueInput
    /**
     * In case the companyService found by the `where` argument doesn't exist, create a new companyService with this data.
     */
    create: XOR<companyServiceCreateInput, companyServiceUncheckedCreateInput>
    /**
     * In case the companyService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyServiceUpdateInput, companyServiceUncheckedUpdateInput>
  }

  /**
   * companyService delete
   */
  export type companyServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
    /**
     * Filter which companyService to delete.
     */
    where: companyServiceWhereUniqueInput
  }

  /**
   * companyService deleteMany
   */
  export type companyServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyServices to delete
     */
    where?: companyServiceWhereInput
    /**
     * Limit how many companyServices to delete.
     */
    limit?: number
  }

  /**
   * companyService.materials
   */
  export type companyService$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    where?: companyMaterialWhereInput
    orderBy?: companyMaterialOrderByWithRelationInput | companyMaterialOrderByWithRelationInput[]
    cursor?: companyMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyMaterialScalarFieldEnum | CompanyMaterialScalarFieldEnum[]
  }

  /**
   * companyService.finishes
   */
  export type companyService$finishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    where?: companyFinishWhereInput
    orderBy?: companyFinishOrderByWithRelationInput | companyFinishOrderByWithRelationInput[]
    cursor?: companyFinishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFinishScalarFieldEnum | CompanyFinishScalarFieldEnum[]
  }

  /**
   * companyService without action
   */
  export type companyServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyService
     */
    select?: companyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyService
     */
    omit?: companyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyServiceInclude<ExtArgs> | null
  }


  /**
   * Model companyMaterial
   */

  export type AggregateCompanyMaterial = {
    _count: CompanyMaterialCountAggregateOutputType | null
    _min: CompanyMaterialMinAggregateOutputType | null
    _max: CompanyMaterialMaxAggregateOutputType | null
  }

  export type CompanyMaterialMinAggregateOutputType = {
    id: string | null
    service_id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompanyMaterialMaxAggregateOutputType = {
    id: string | null
    service_id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompanyMaterialCountAggregateOutputType = {
    id: number
    service_id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CompanyMaterialMinAggregateInputType = {
    id?: true
    service_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CompanyMaterialMaxAggregateInputType = {
    id?: true
    service_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CompanyMaterialCountAggregateInputType = {
    id?: true
    service_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CompanyMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyMaterial to aggregate.
     */
    where?: companyMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyMaterials to fetch.
     */
    orderBy?: companyMaterialOrderByWithRelationInput | companyMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companyMaterials
    **/
    _count?: true | CompanyMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaterialMaxAggregateInputType
  }

  export type GetCompanyMaterialAggregateType<T extends CompanyMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyMaterial[P]>
      : GetScalarType<T[P], AggregateCompanyMaterial[P]>
  }




  export type companyMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyMaterialWhereInput
    orderBy?: companyMaterialOrderByWithAggregationInput | companyMaterialOrderByWithAggregationInput[]
    by: CompanyMaterialScalarFieldEnum[] | CompanyMaterialScalarFieldEnum
    having?: companyMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyMaterialCountAggregateInputType | true
    _min?: CompanyMaterialMinAggregateInputType
    _max?: CompanyMaterialMaxAggregateInputType
  }

  export type CompanyMaterialGroupByOutputType = {
    id: string
    service_id: string
    name: string | null
    created_at: Date
    updated_at: Date
    _count: CompanyMaterialCountAggregateOutputType | null
    _min: CompanyMaterialMinAggregateOutputType | null
    _max: CompanyMaterialMaxAggregateOutputType | null
  }

  type GetCompanyMaterialGroupByPayload<T extends companyMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyMaterialGroupByOutputType[P]>
        }
      >
    >


  export type companyMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyMaterial"]>

  export type companyMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyMaterial"]>

  export type companyMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyMaterial"]>

  export type companyMaterialSelectScalar = {
    id?: boolean
    service_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type companyMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_id" | "name" | "created_at" | "updated_at", ExtArgs["result"]["companyMaterial"]>
  export type companyMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }
  export type companyMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }
  export type companyMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }

  export type $companyMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companyMaterial"
    objects: {
      service: Prisma.$companyServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_id: string
      name: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["companyMaterial"]>
    composites: {}
  }

  type companyMaterialGetPayload<S extends boolean | null | undefined | companyMaterialDefaultArgs> = $Result.GetResult<Prisma.$companyMaterialPayload, S>

  type companyMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companyMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyMaterialCountAggregateInputType | true
    }

  export interface companyMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companyMaterial'], meta: { name: 'companyMaterial' } }
    /**
     * Find zero or one CompanyMaterial that matches the filter.
     * @param {companyMaterialFindUniqueArgs} args - Arguments to find a CompanyMaterial
     * @example
     * // Get one CompanyMaterial
     * const companyMaterial = await prisma.companyMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companyMaterialFindUniqueArgs>(args: SelectSubset<T, companyMaterialFindUniqueArgs<ExtArgs>>): Prisma__companyMaterialClient<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companyMaterialFindUniqueOrThrowArgs} args - Arguments to find a CompanyMaterial
     * @example
     * // Get one CompanyMaterial
     * const companyMaterial = await prisma.companyMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companyMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, companyMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companyMaterialClient<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyMaterialFindFirstArgs} args - Arguments to find a CompanyMaterial
     * @example
     * // Get one CompanyMaterial
     * const companyMaterial = await prisma.companyMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companyMaterialFindFirstArgs>(args?: SelectSubset<T, companyMaterialFindFirstArgs<ExtArgs>>): Prisma__companyMaterialClient<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyMaterialFindFirstOrThrowArgs} args - Arguments to find a CompanyMaterial
     * @example
     * // Get one CompanyMaterial
     * const companyMaterial = await prisma.companyMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companyMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, companyMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__companyMaterialClient<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyMaterials
     * const companyMaterials = await prisma.companyMaterial.findMany()
     * 
     * // Get first 10 CompanyMaterials
     * const companyMaterials = await prisma.companyMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyMaterialWithIdOnly = await prisma.companyMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companyMaterialFindManyArgs>(args?: SelectSubset<T, companyMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyMaterial.
     * @param {companyMaterialCreateArgs} args - Arguments to create a CompanyMaterial.
     * @example
     * // Create one CompanyMaterial
     * const CompanyMaterial = await prisma.companyMaterial.create({
     *   data: {
     *     // ... data to create a CompanyMaterial
     *   }
     * })
     * 
     */
    create<T extends companyMaterialCreateArgs>(args: SelectSubset<T, companyMaterialCreateArgs<ExtArgs>>): Prisma__companyMaterialClient<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyMaterials.
     * @param {companyMaterialCreateManyArgs} args - Arguments to create many CompanyMaterials.
     * @example
     * // Create many CompanyMaterials
     * const companyMaterial = await prisma.companyMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companyMaterialCreateManyArgs>(args?: SelectSubset<T, companyMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyMaterials and returns the data saved in the database.
     * @param {companyMaterialCreateManyAndReturnArgs} args - Arguments to create many CompanyMaterials.
     * @example
     * // Create many CompanyMaterials
     * const companyMaterial = await prisma.companyMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyMaterials and only return the `id`
     * const companyMaterialWithIdOnly = await prisma.companyMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companyMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, companyMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyMaterial.
     * @param {companyMaterialDeleteArgs} args - Arguments to delete one CompanyMaterial.
     * @example
     * // Delete one CompanyMaterial
     * const CompanyMaterial = await prisma.companyMaterial.delete({
     *   where: {
     *     // ... filter to delete one CompanyMaterial
     *   }
     * })
     * 
     */
    delete<T extends companyMaterialDeleteArgs>(args: SelectSubset<T, companyMaterialDeleteArgs<ExtArgs>>): Prisma__companyMaterialClient<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyMaterial.
     * @param {companyMaterialUpdateArgs} args - Arguments to update one CompanyMaterial.
     * @example
     * // Update one CompanyMaterial
     * const companyMaterial = await prisma.companyMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companyMaterialUpdateArgs>(args: SelectSubset<T, companyMaterialUpdateArgs<ExtArgs>>): Prisma__companyMaterialClient<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyMaterials.
     * @param {companyMaterialDeleteManyArgs} args - Arguments to filter CompanyMaterials to delete.
     * @example
     * // Delete a few CompanyMaterials
     * const { count } = await prisma.companyMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companyMaterialDeleteManyArgs>(args?: SelectSubset<T, companyMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyMaterials
     * const companyMaterial = await prisma.companyMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companyMaterialUpdateManyArgs>(args: SelectSubset<T, companyMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyMaterials and returns the data updated in the database.
     * @param {companyMaterialUpdateManyAndReturnArgs} args - Arguments to update many CompanyMaterials.
     * @example
     * // Update many CompanyMaterials
     * const companyMaterial = await prisma.companyMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyMaterials and only return the `id`
     * const companyMaterialWithIdOnly = await prisma.companyMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companyMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, companyMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyMaterial.
     * @param {companyMaterialUpsertArgs} args - Arguments to update or create a CompanyMaterial.
     * @example
     * // Update or create a CompanyMaterial
     * const companyMaterial = await prisma.companyMaterial.upsert({
     *   create: {
     *     // ... data to create a CompanyMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyMaterial we want to update
     *   }
     * })
     */
    upsert<T extends companyMaterialUpsertArgs>(args: SelectSubset<T, companyMaterialUpsertArgs<ExtArgs>>): Prisma__companyMaterialClient<$Result.GetResult<Prisma.$companyMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyMaterialCountArgs} args - Arguments to filter CompanyMaterials to count.
     * @example
     * // Count the number of CompanyMaterials
     * const count = await prisma.companyMaterial.count({
     *   where: {
     *     // ... the filter for the CompanyMaterials we want to count
     *   }
     * })
    **/
    count<T extends companyMaterialCountArgs>(
      args?: Subset<T, companyMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyMaterialAggregateArgs>(args: Subset<T, CompanyMaterialAggregateArgs>): Prisma.PrismaPromise<GetCompanyMaterialAggregateType<T>>

    /**
     * Group by CompanyMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyMaterialGroupByArgs['orderBy'] }
        : { orderBy?: companyMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companyMaterial model
   */
  readonly fields: companyMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companyMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends companyServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companyServiceDefaultArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companyMaterial model
   */
  interface companyMaterialFieldRefs {
    readonly id: FieldRef<"companyMaterial", 'String'>
    readonly service_id: FieldRef<"companyMaterial", 'String'>
    readonly name: FieldRef<"companyMaterial", 'String'>
    readonly created_at: FieldRef<"companyMaterial", 'DateTime'>
    readonly updated_at: FieldRef<"companyMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * companyMaterial findUnique
   */
  export type companyMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which companyMaterial to fetch.
     */
    where: companyMaterialWhereUniqueInput
  }

  /**
   * companyMaterial findUniqueOrThrow
   */
  export type companyMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which companyMaterial to fetch.
     */
    where: companyMaterialWhereUniqueInput
  }

  /**
   * companyMaterial findFirst
   */
  export type companyMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which companyMaterial to fetch.
     */
    where?: companyMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyMaterials to fetch.
     */
    orderBy?: companyMaterialOrderByWithRelationInput | companyMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyMaterials.
     */
    cursor?: companyMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyMaterials.
     */
    distinct?: CompanyMaterialScalarFieldEnum | CompanyMaterialScalarFieldEnum[]
  }

  /**
   * companyMaterial findFirstOrThrow
   */
  export type companyMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which companyMaterial to fetch.
     */
    where?: companyMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyMaterials to fetch.
     */
    orderBy?: companyMaterialOrderByWithRelationInput | companyMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyMaterials.
     */
    cursor?: companyMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyMaterials.
     */
    distinct?: CompanyMaterialScalarFieldEnum | CompanyMaterialScalarFieldEnum[]
  }

  /**
   * companyMaterial findMany
   */
  export type companyMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which companyMaterials to fetch.
     */
    where?: companyMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyMaterials to fetch.
     */
    orderBy?: companyMaterialOrderByWithRelationInput | companyMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companyMaterials.
     */
    cursor?: companyMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyMaterials.
     */
    skip?: number
    distinct?: CompanyMaterialScalarFieldEnum | CompanyMaterialScalarFieldEnum[]
  }

  /**
   * companyMaterial create
   */
  export type companyMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a companyMaterial.
     */
    data: XOR<companyMaterialCreateInput, companyMaterialUncheckedCreateInput>
  }

  /**
   * companyMaterial createMany
   */
  export type companyMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companyMaterials.
     */
    data: companyMaterialCreateManyInput | companyMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companyMaterial createManyAndReturn
   */
  export type companyMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many companyMaterials.
     */
    data: companyMaterialCreateManyInput | companyMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * companyMaterial update
   */
  export type companyMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a companyMaterial.
     */
    data: XOR<companyMaterialUpdateInput, companyMaterialUncheckedUpdateInput>
    /**
     * Choose, which companyMaterial to update.
     */
    where: companyMaterialWhereUniqueInput
  }

  /**
   * companyMaterial updateMany
   */
  export type companyMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companyMaterials.
     */
    data: XOR<companyMaterialUpdateManyMutationInput, companyMaterialUncheckedUpdateManyInput>
    /**
     * Filter which companyMaterials to update
     */
    where?: companyMaterialWhereInput
    /**
     * Limit how many companyMaterials to update.
     */
    limit?: number
  }

  /**
   * companyMaterial updateManyAndReturn
   */
  export type companyMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * The data used to update companyMaterials.
     */
    data: XOR<companyMaterialUpdateManyMutationInput, companyMaterialUncheckedUpdateManyInput>
    /**
     * Filter which companyMaterials to update
     */
    where?: companyMaterialWhereInput
    /**
     * Limit how many companyMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * companyMaterial upsert
   */
  export type companyMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the companyMaterial to update in case it exists.
     */
    where: companyMaterialWhereUniqueInput
    /**
     * In case the companyMaterial found by the `where` argument doesn't exist, create a new companyMaterial with this data.
     */
    create: XOR<companyMaterialCreateInput, companyMaterialUncheckedCreateInput>
    /**
     * In case the companyMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyMaterialUpdateInput, companyMaterialUncheckedUpdateInput>
  }

  /**
   * companyMaterial delete
   */
  export type companyMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
    /**
     * Filter which companyMaterial to delete.
     */
    where: companyMaterialWhereUniqueInput
  }

  /**
   * companyMaterial deleteMany
   */
  export type companyMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyMaterials to delete
     */
    where?: companyMaterialWhereInput
    /**
     * Limit how many companyMaterials to delete.
     */
    limit?: number
  }

  /**
   * companyMaterial without action
   */
  export type companyMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyMaterial
     */
    select?: companyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyMaterial
     */
    omit?: companyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyMaterialInclude<ExtArgs> | null
  }


  /**
   * Model companyFinish
   */

  export type AggregateCompanyFinish = {
    _count: CompanyFinishCountAggregateOutputType | null
    _min: CompanyFinishMinAggregateOutputType | null
    _max: CompanyFinishMaxAggregateOutputType | null
  }

  export type CompanyFinishMinAggregateOutputType = {
    id: string | null
    service_id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompanyFinishMaxAggregateOutputType = {
    id: string | null
    service_id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompanyFinishCountAggregateOutputType = {
    id: number
    service_id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CompanyFinishMinAggregateInputType = {
    id?: true
    service_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CompanyFinishMaxAggregateInputType = {
    id?: true
    service_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CompanyFinishCountAggregateInputType = {
    id?: true
    service_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CompanyFinishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyFinish to aggregate.
     */
    where?: companyFinishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyFinishes to fetch.
     */
    orderBy?: companyFinishOrderByWithRelationInput | companyFinishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyFinishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyFinishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyFinishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companyFinishes
    **/
    _count?: true | CompanyFinishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyFinishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyFinishMaxAggregateInputType
  }

  export type GetCompanyFinishAggregateType<T extends CompanyFinishAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyFinish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyFinish[P]>
      : GetScalarType<T[P], AggregateCompanyFinish[P]>
  }




  export type companyFinishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyFinishWhereInput
    orderBy?: companyFinishOrderByWithAggregationInput | companyFinishOrderByWithAggregationInput[]
    by: CompanyFinishScalarFieldEnum[] | CompanyFinishScalarFieldEnum
    having?: companyFinishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyFinishCountAggregateInputType | true
    _min?: CompanyFinishMinAggregateInputType
    _max?: CompanyFinishMaxAggregateInputType
  }

  export type CompanyFinishGroupByOutputType = {
    id: string
    service_id: string
    name: string | null
    created_at: Date
    updated_at: Date
    _count: CompanyFinishCountAggregateOutputType | null
    _min: CompanyFinishMinAggregateOutputType | null
    _max: CompanyFinishMaxAggregateOutputType | null
  }

  type GetCompanyFinishGroupByPayload<T extends companyFinishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyFinishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyFinishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyFinishGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyFinishGroupByOutputType[P]>
        }
      >
    >


  export type companyFinishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinish"]>

  export type companyFinishSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinish"]>

  export type companyFinishSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyFinish"]>

  export type companyFinishSelectScalar = {
    id?: boolean
    service_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type companyFinishOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_id" | "name" | "created_at" | "updated_at", ExtArgs["result"]["companyFinish"]>
  export type companyFinishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }
  export type companyFinishIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }
  export type companyFinishIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | companyServiceDefaultArgs<ExtArgs>
  }

  export type $companyFinishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companyFinish"
    objects: {
      service: Prisma.$companyServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_id: string
      name: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["companyFinish"]>
    composites: {}
  }

  type companyFinishGetPayload<S extends boolean | null | undefined | companyFinishDefaultArgs> = $Result.GetResult<Prisma.$companyFinishPayload, S>

  type companyFinishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companyFinishFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyFinishCountAggregateInputType | true
    }

  export interface companyFinishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companyFinish'], meta: { name: 'companyFinish' } }
    /**
     * Find zero or one CompanyFinish that matches the filter.
     * @param {companyFinishFindUniqueArgs} args - Arguments to find a CompanyFinish
     * @example
     * // Get one CompanyFinish
     * const companyFinish = await prisma.companyFinish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companyFinishFindUniqueArgs>(args: SelectSubset<T, companyFinishFindUniqueArgs<ExtArgs>>): Prisma__companyFinishClient<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyFinish that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companyFinishFindUniqueOrThrowArgs} args - Arguments to find a CompanyFinish
     * @example
     * // Get one CompanyFinish
     * const companyFinish = await prisma.companyFinish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companyFinishFindUniqueOrThrowArgs>(args: SelectSubset<T, companyFinishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companyFinishClient<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFinish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFinishFindFirstArgs} args - Arguments to find a CompanyFinish
     * @example
     * // Get one CompanyFinish
     * const companyFinish = await prisma.companyFinish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companyFinishFindFirstArgs>(args?: SelectSubset<T, companyFinishFindFirstArgs<ExtArgs>>): Prisma__companyFinishClient<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFinish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFinishFindFirstOrThrowArgs} args - Arguments to find a CompanyFinish
     * @example
     * // Get one CompanyFinish
     * const companyFinish = await prisma.companyFinish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companyFinishFindFirstOrThrowArgs>(args?: SelectSubset<T, companyFinishFindFirstOrThrowArgs<ExtArgs>>): Prisma__companyFinishClient<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyFinishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFinishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyFinishes
     * const companyFinishes = await prisma.companyFinish.findMany()
     * 
     * // Get first 10 CompanyFinishes
     * const companyFinishes = await prisma.companyFinish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyFinishWithIdOnly = await prisma.companyFinish.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companyFinishFindManyArgs>(args?: SelectSubset<T, companyFinishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyFinish.
     * @param {companyFinishCreateArgs} args - Arguments to create a CompanyFinish.
     * @example
     * // Create one CompanyFinish
     * const CompanyFinish = await prisma.companyFinish.create({
     *   data: {
     *     // ... data to create a CompanyFinish
     *   }
     * })
     * 
     */
    create<T extends companyFinishCreateArgs>(args: SelectSubset<T, companyFinishCreateArgs<ExtArgs>>): Prisma__companyFinishClient<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyFinishes.
     * @param {companyFinishCreateManyArgs} args - Arguments to create many CompanyFinishes.
     * @example
     * // Create many CompanyFinishes
     * const companyFinish = await prisma.companyFinish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companyFinishCreateManyArgs>(args?: SelectSubset<T, companyFinishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyFinishes and returns the data saved in the database.
     * @param {companyFinishCreateManyAndReturnArgs} args - Arguments to create many CompanyFinishes.
     * @example
     * // Create many CompanyFinishes
     * const companyFinish = await prisma.companyFinish.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyFinishes and only return the `id`
     * const companyFinishWithIdOnly = await prisma.companyFinish.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companyFinishCreateManyAndReturnArgs>(args?: SelectSubset<T, companyFinishCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyFinish.
     * @param {companyFinishDeleteArgs} args - Arguments to delete one CompanyFinish.
     * @example
     * // Delete one CompanyFinish
     * const CompanyFinish = await prisma.companyFinish.delete({
     *   where: {
     *     // ... filter to delete one CompanyFinish
     *   }
     * })
     * 
     */
    delete<T extends companyFinishDeleteArgs>(args: SelectSubset<T, companyFinishDeleteArgs<ExtArgs>>): Prisma__companyFinishClient<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyFinish.
     * @param {companyFinishUpdateArgs} args - Arguments to update one CompanyFinish.
     * @example
     * // Update one CompanyFinish
     * const companyFinish = await prisma.companyFinish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companyFinishUpdateArgs>(args: SelectSubset<T, companyFinishUpdateArgs<ExtArgs>>): Prisma__companyFinishClient<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyFinishes.
     * @param {companyFinishDeleteManyArgs} args - Arguments to filter CompanyFinishes to delete.
     * @example
     * // Delete a few CompanyFinishes
     * const { count } = await prisma.companyFinish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companyFinishDeleteManyArgs>(args?: SelectSubset<T, companyFinishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFinishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFinishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyFinishes
     * const companyFinish = await prisma.companyFinish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companyFinishUpdateManyArgs>(args: SelectSubset<T, companyFinishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFinishes and returns the data updated in the database.
     * @param {companyFinishUpdateManyAndReturnArgs} args - Arguments to update many CompanyFinishes.
     * @example
     * // Update many CompanyFinishes
     * const companyFinish = await prisma.companyFinish.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyFinishes and only return the `id`
     * const companyFinishWithIdOnly = await prisma.companyFinish.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companyFinishUpdateManyAndReturnArgs>(args: SelectSubset<T, companyFinishUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyFinish.
     * @param {companyFinishUpsertArgs} args - Arguments to update or create a CompanyFinish.
     * @example
     * // Update or create a CompanyFinish
     * const companyFinish = await prisma.companyFinish.upsert({
     *   create: {
     *     // ... data to create a CompanyFinish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyFinish we want to update
     *   }
     * })
     */
    upsert<T extends companyFinishUpsertArgs>(args: SelectSubset<T, companyFinishUpsertArgs<ExtArgs>>): Prisma__companyFinishClient<$Result.GetResult<Prisma.$companyFinishPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyFinishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFinishCountArgs} args - Arguments to filter CompanyFinishes to count.
     * @example
     * // Count the number of CompanyFinishes
     * const count = await prisma.companyFinish.count({
     *   where: {
     *     // ... the filter for the CompanyFinishes we want to count
     *   }
     * })
    **/
    count<T extends companyFinishCountArgs>(
      args?: Subset<T, companyFinishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyFinishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyFinish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFinishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyFinishAggregateArgs>(args: Subset<T, CompanyFinishAggregateArgs>): Prisma.PrismaPromise<GetCompanyFinishAggregateType<T>>

    /**
     * Group by CompanyFinish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFinishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyFinishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyFinishGroupByArgs['orderBy'] }
        : { orderBy?: companyFinishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyFinishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyFinishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companyFinish model
   */
  readonly fields: companyFinishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companyFinish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyFinishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends companyServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companyServiceDefaultArgs<ExtArgs>>): Prisma__companyServiceClient<$Result.GetResult<Prisma.$companyServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companyFinish model
   */
  interface companyFinishFieldRefs {
    readonly id: FieldRef<"companyFinish", 'String'>
    readonly service_id: FieldRef<"companyFinish", 'String'>
    readonly name: FieldRef<"companyFinish", 'String'>
    readonly created_at: FieldRef<"companyFinish", 'DateTime'>
    readonly updated_at: FieldRef<"companyFinish", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * companyFinish findUnique
   */
  export type companyFinishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * Filter, which companyFinish to fetch.
     */
    where: companyFinishWhereUniqueInput
  }

  /**
   * companyFinish findUniqueOrThrow
   */
  export type companyFinishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * Filter, which companyFinish to fetch.
     */
    where: companyFinishWhereUniqueInput
  }

  /**
   * companyFinish findFirst
   */
  export type companyFinishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * Filter, which companyFinish to fetch.
     */
    where?: companyFinishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyFinishes to fetch.
     */
    orderBy?: companyFinishOrderByWithRelationInput | companyFinishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyFinishes.
     */
    cursor?: companyFinishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyFinishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyFinishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyFinishes.
     */
    distinct?: CompanyFinishScalarFieldEnum | CompanyFinishScalarFieldEnum[]
  }

  /**
   * companyFinish findFirstOrThrow
   */
  export type companyFinishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * Filter, which companyFinish to fetch.
     */
    where?: companyFinishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyFinishes to fetch.
     */
    orderBy?: companyFinishOrderByWithRelationInput | companyFinishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyFinishes.
     */
    cursor?: companyFinishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyFinishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyFinishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyFinishes.
     */
    distinct?: CompanyFinishScalarFieldEnum | CompanyFinishScalarFieldEnum[]
  }

  /**
   * companyFinish findMany
   */
  export type companyFinishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * Filter, which companyFinishes to fetch.
     */
    where?: companyFinishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyFinishes to fetch.
     */
    orderBy?: companyFinishOrderByWithRelationInput | companyFinishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companyFinishes.
     */
    cursor?: companyFinishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyFinishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyFinishes.
     */
    skip?: number
    distinct?: CompanyFinishScalarFieldEnum | CompanyFinishScalarFieldEnum[]
  }

  /**
   * companyFinish create
   */
  export type companyFinishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * The data needed to create a companyFinish.
     */
    data: XOR<companyFinishCreateInput, companyFinishUncheckedCreateInput>
  }

  /**
   * companyFinish createMany
   */
  export type companyFinishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companyFinishes.
     */
    data: companyFinishCreateManyInput | companyFinishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companyFinish createManyAndReturn
   */
  export type companyFinishCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * The data used to create many companyFinishes.
     */
    data: companyFinishCreateManyInput | companyFinishCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * companyFinish update
   */
  export type companyFinishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * The data needed to update a companyFinish.
     */
    data: XOR<companyFinishUpdateInput, companyFinishUncheckedUpdateInput>
    /**
     * Choose, which companyFinish to update.
     */
    where: companyFinishWhereUniqueInput
  }

  /**
   * companyFinish updateMany
   */
  export type companyFinishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companyFinishes.
     */
    data: XOR<companyFinishUpdateManyMutationInput, companyFinishUncheckedUpdateManyInput>
    /**
     * Filter which companyFinishes to update
     */
    where?: companyFinishWhereInput
    /**
     * Limit how many companyFinishes to update.
     */
    limit?: number
  }

  /**
   * companyFinish updateManyAndReturn
   */
  export type companyFinishUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * The data used to update companyFinishes.
     */
    data: XOR<companyFinishUpdateManyMutationInput, companyFinishUncheckedUpdateManyInput>
    /**
     * Filter which companyFinishes to update
     */
    where?: companyFinishWhereInput
    /**
     * Limit how many companyFinishes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * companyFinish upsert
   */
  export type companyFinishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * The filter to search for the companyFinish to update in case it exists.
     */
    where: companyFinishWhereUniqueInput
    /**
     * In case the companyFinish found by the `where` argument doesn't exist, create a new companyFinish with this data.
     */
    create: XOR<companyFinishCreateInput, companyFinishUncheckedCreateInput>
    /**
     * In case the companyFinish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyFinishUpdateInput, companyFinishUncheckedUpdateInput>
  }

  /**
   * companyFinish delete
   */
  export type companyFinishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
    /**
     * Filter which companyFinish to delete.
     */
    where: companyFinishWhereUniqueInput
  }

  /**
   * companyFinish deleteMany
   */
  export type companyFinishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyFinishes to delete
     */
    where?: companyFinishWhereInput
    /**
     * Limit how many companyFinishes to delete.
     */
    limit?: number
  }

  /**
   * companyFinish without action
   */
  export type companyFinishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyFinish
     */
    select?: companyFinishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyFinish
     */
    omit?: companyFinishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyFinishInclude<ExtArgs> | null
  }


  /**
   * Model CustomerAddress
   */

  export type AggregateCustomerAddress = {
    _count: CustomerAddressCountAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  export type CustomerAddressMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    billing_address: string | null
    billing_address2: string | null
    billing_city: string | null
    billing_state: string | null
    billing_zip: string | null
    billing_country: string | null
    shipping_address: string | null
    shipping_address2: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_zip: string | null
    shipping_country: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerAddressMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    billing_address: string | null
    billing_address2: string | null
    billing_city: string | null
    billing_state: string | null
    billing_zip: string | null
    billing_country: string | null
    shipping_address: string | null
    shipping_address2: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_zip: string | null
    shipping_country: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerAddressCountAggregateOutputType = {
    id: number
    customer_id: number
    billing_address: number
    billing_address2: number
    billing_city: number
    billing_state: number
    billing_zip: number
    billing_country: number
    shipping_address: number
    shipping_address2: number
    shipping_city: number
    shipping_state: number
    shipping_zip: number
    shipping_country: number
    is_default: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomerAddressMinAggregateInputType = {
    id?: true
    customer_id?: true
    billing_address?: true
    billing_address2?: true
    billing_city?: true
    billing_state?: true
    billing_zip?: true
    billing_country?: true
    shipping_address?: true
    shipping_address2?: true
    shipping_city?: true
    shipping_state?: true
    shipping_zip?: true
    shipping_country?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerAddressMaxAggregateInputType = {
    id?: true
    customer_id?: true
    billing_address?: true
    billing_address2?: true
    billing_city?: true
    billing_state?: true
    billing_zip?: true
    billing_country?: true
    shipping_address?: true
    shipping_address2?: true
    shipping_city?: true
    shipping_state?: true
    shipping_zip?: true
    shipping_country?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerAddressCountAggregateInputType = {
    id?: true
    customer_id?: true
    billing_address?: true
    billing_address2?: true
    billing_city?: true
    billing_state?: true
    billing_zip?: true
    billing_country?: true
    shipping_address?: true
    shipping_address2?: true
    shipping_city?: true
    shipping_state?: true
    shipping_zip?: true
    shipping_country?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomerAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddress to aggregate.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerAddresses
    **/
    _count?: true | CustomerAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type GetCustomerAddressAggregateType<T extends CustomerAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerAddress[P]>
      : GetScalarType<T[P], AggregateCustomerAddress[P]>
  }




  export type CustomerAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithAggregationInput | CustomerAddressOrderByWithAggregationInput[]
    by: CustomerAddressScalarFieldEnum[] | CustomerAddressScalarFieldEnum
    having?: CustomerAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerAddressCountAggregateInputType | true
    _min?: CustomerAddressMinAggregateInputType
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type CustomerAddressGroupByOutputType = {
    id: string
    customer_id: string
    billing_address: string
    billing_address2: string | null
    billing_city: string
    billing_state: string
    billing_zip: string
    billing_country: string
    shipping_address: string
    shipping_address2: string | null
    shipping_city: string
    shipping_state: string
    shipping_zip: string
    shipping_country: string
    is_default: boolean
    created_at: Date
    updated_at: Date
    _count: CustomerAddressCountAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  type GetCustomerAddressGroupByPayload<T extends CustomerAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
        }
      >
    >


  export type CustomerAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    billing_address?: boolean
    billing_address2?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_zip?: boolean
    billing_country?: boolean
    shipping_address?: boolean
    shipping_address2?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_zip?: boolean
    shipping_country?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    billing_address?: boolean
    billing_address2?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_zip?: boolean
    billing_country?: boolean
    shipping_address?: boolean
    shipping_address2?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_zip?: boolean
    shipping_country?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    billing_address?: boolean
    billing_address2?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_zip?: boolean
    billing_country?: boolean
    shipping_address?: boolean
    shipping_address2?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_zip?: boolean
    shipping_country?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectScalar = {
    id?: boolean
    customer_id?: boolean
    billing_address?: boolean
    billing_address2?: boolean
    billing_city?: boolean
    billing_state?: boolean
    billing_zip?: boolean
    billing_country?: boolean
    shipping_address?: boolean
    shipping_address2?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_zip?: boolean
    shipping_country?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomerAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "billing_address" | "billing_address2" | "billing_city" | "billing_state" | "billing_zip" | "billing_country" | "shipping_address" | "shipping_address2" | "shipping_city" | "shipping_state" | "shipping_zip" | "shipping_country" | "is_default" | "created_at" | "updated_at", ExtArgs["result"]["customerAddress"]>
  export type CustomerAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerAddress"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      billing_address: string
      billing_address2: string | null
      billing_city: string
      billing_state: string
      billing_zip: string
      billing_country: string
      shipping_address: string
      shipping_address2: string | null
      shipping_city: string
      shipping_state: string
      shipping_zip: string
      shipping_country: string
      is_default: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["customerAddress"]>
    composites: {}
  }

  type CustomerAddressGetPayload<S extends boolean | null | undefined | CustomerAddressDefaultArgs> = $Result.GetResult<Prisma.$CustomerAddressPayload, S>

  type CustomerAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerAddressCountAggregateInputType | true
    }

  export interface CustomerAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerAddress'], meta: { name: 'CustomerAddress' } }
    /**
     * Find zero or one CustomerAddress that matches the filter.
     * @param {CustomerAddressFindUniqueArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerAddressFindUniqueArgs>(args: SelectSubset<T, CustomerAddressFindUniqueArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerAddressFindUniqueOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerAddressFindFirstArgs>(args?: SelectSubset<T, CustomerAddressFindFirstArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany()
     * 
     * // Get first 10 CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerAddressFindManyArgs>(args?: SelectSubset<T, CustomerAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerAddress.
     * @param {CustomerAddressCreateArgs} args - Arguments to create a CustomerAddress.
     * @example
     * // Create one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.create({
     *   data: {
     *     // ... data to create a CustomerAddress
     *   }
     * })
     * 
     */
    create<T extends CustomerAddressCreateArgs>(args: SelectSubset<T, CustomerAddressCreateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerAddresses.
     * @param {CustomerAddressCreateManyArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerAddressCreateManyArgs>(args?: SelectSubset<T, CustomerAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerAddresses and returns the data saved in the database.
     * @param {CustomerAddressCreateManyAndReturnArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerAddress.
     * @param {CustomerAddressDeleteArgs} args - Arguments to delete one CustomerAddress.
     * @example
     * // Delete one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.delete({
     *   where: {
     *     // ... filter to delete one CustomerAddress
     *   }
     * })
     * 
     */
    delete<T extends CustomerAddressDeleteArgs>(args: SelectSubset<T, CustomerAddressDeleteArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerAddress.
     * @param {CustomerAddressUpdateArgs} args - Arguments to update one CustomerAddress.
     * @example
     * // Update one CustomerAddress
     * const customerAddress = await prisma.customerAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerAddressUpdateArgs>(args: SelectSubset<T, CustomerAddressUpdateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerAddresses.
     * @param {CustomerAddressDeleteManyArgs} args - Arguments to filter CustomerAddresses to delete.
     * @example
     * // Delete a few CustomerAddresses
     * const { count } = await prisma.customerAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerAddressDeleteManyArgs>(args?: SelectSubset<T, CustomerAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerAddressUpdateManyArgs>(args: SelectSubset<T, CustomerAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses and returns the data updated in the database.
     * @param {CustomerAddressUpdateManyAndReturnArgs} args - Arguments to update many CustomerAddresses.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerAddress.
     * @param {CustomerAddressUpsertArgs} args - Arguments to update or create a CustomerAddress.
     * @example
     * // Update or create a CustomerAddress
     * const customerAddress = await prisma.customerAddress.upsert({
     *   create: {
     *     // ... data to create a CustomerAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerAddress we want to update
     *   }
     * })
     */
    upsert<T extends CustomerAddressUpsertArgs>(args: SelectSubset<T, CustomerAddressUpsertArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressCountArgs} args - Arguments to filter CustomerAddresses to count.
     * @example
     * // Count the number of CustomerAddresses
     * const count = await prisma.customerAddress.count({
     *   where: {
     *     // ... the filter for the CustomerAddresses we want to count
     *   }
     * })
    **/
    count<T extends CustomerAddressCountArgs>(
      args?: Subset<T, CustomerAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAddressAggregateArgs>(args: Subset<T, CustomerAddressAggregateArgs>): Prisma.PrismaPromise<GetCustomerAddressAggregateType<T>>

    /**
     * Group by CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerAddressGroupByArgs['orderBy'] }
        : { orderBy?: CustomerAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerAddress model
   */
  readonly fields: CustomerAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerAddress model
   */
  interface CustomerAddressFieldRefs {
    readonly id: FieldRef<"CustomerAddress", 'String'>
    readonly customer_id: FieldRef<"CustomerAddress", 'String'>
    readonly billing_address: FieldRef<"CustomerAddress", 'String'>
    readonly billing_address2: FieldRef<"CustomerAddress", 'String'>
    readonly billing_city: FieldRef<"CustomerAddress", 'String'>
    readonly billing_state: FieldRef<"CustomerAddress", 'String'>
    readonly billing_zip: FieldRef<"CustomerAddress", 'String'>
    readonly billing_country: FieldRef<"CustomerAddress", 'String'>
    readonly shipping_address: FieldRef<"CustomerAddress", 'String'>
    readonly shipping_address2: FieldRef<"CustomerAddress", 'String'>
    readonly shipping_city: FieldRef<"CustomerAddress", 'String'>
    readonly shipping_state: FieldRef<"CustomerAddress", 'String'>
    readonly shipping_zip: FieldRef<"CustomerAddress", 'String'>
    readonly shipping_country: FieldRef<"CustomerAddress", 'String'>
    readonly is_default: FieldRef<"CustomerAddress", 'Boolean'>
    readonly created_at: FieldRef<"CustomerAddress", 'DateTime'>
    readonly updated_at: FieldRef<"CustomerAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerAddress findUnique
   */
  export type CustomerAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findUniqueOrThrow
   */
  export type CustomerAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findFirst
   */
  export type CustomerAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findFirstOrThrow
   */
  export type CustomerAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findMany
   */
  export type CustomerAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddresses to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress create
   */
  export type CustomerAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerAddress.
     */
    data: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
  }

  /**
   * CustomerAddress createMany
   */
  export type CustomerAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerAddress createManyAndReturn
   */
  export type CustomerAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress update
   */
  export type CustomerAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerAddress.
     */
    data: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
    /**
     * Choose, which CustomerAddress to update.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress updateMany
   */
  export type CustomerAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
  }

  /**
   * CustomerAddress updateManyAndReturn
   */
  export type CustomerAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress upsert
   */
  export type CustomerAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerAddress to update in case it exists.
     */
    where: CustomerAddressWhereUniqueInput
    /**
     * In case the CustomerAddress found by the `where` argument doesn't exist, create a new CustomerAddress with this data.
     */
    create: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
    /**
     * In case the CustomerAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
  }

  /**
   * CustomerAddress delete
   */
  export type CustomerAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter which CustomerAddress to delete.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress deleteMany
   */
  export type CustomerAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddresses to delete
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to delete.
     */
    limit?: number
  }

  /**
   * CustomerAddress without action
   */
  export type CustomerAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
  }


  /**
   * Model CustomerTaxInfo
   */

  export type AggregateCustomerTaxInfo = {
    _count: CustomerTaxInfoCountAggregateOutputType | null
    _avg: CustomerTaxInfoAvgAggregateOutputType | null
    _sum: CustomerTaxInfoSumAggregateOutputType | null
    _min: CustomerTaxInfoMinAggregateOutputType | null
    _max: CustomerTaxInfoMaxAggregateOutputType | null
  }

  export type CustomerTaxInfoAvgAggregateOutputType = {
    default_tax: number | null
    credit_limit: number | null
  }

  export type CustomerTaxInfoSumAggregateOutputType = {
    default_tax: number | null
    credit_limit: number | null
  }

  export type CustomerTaxInfoMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    tax_number: string | null
    default_tax: number | null
    currency: string | null
    payment_terms: string | null
    credit_limit: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerTaxInfoMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    tax_number: string | null
    default_tax: number | null
    currency: string | null
    payment_terms: string | null
    credit_limit: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerTaxInfoCountAggregateOutputType = {
    id: number
    customer_id: number
    tax_number: number
    default_tax: number
    currency: number
    payment_terms: number
    credit_limit: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomerTaxInfoAvgAggregateInputType = {
    default_tax?: true
    credit_limit?: true
  }

  export type CustomerTaxInfoSumAggregateInputType = {
    default_tax?: true
    credit_limit?: true
  }

  export type CustomerTaxInfoMinAggregateInputType = {
    id?: true
    customer_id?: true
    tax_number?: true
    default_tax?: true
    currency?: true
    payment_terms?: true
    credit_limit?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerTaxInfoMaxAggregateInputType = {
    id?: true
    customer_id?: true
    tax_number?: true
    default_tax?: true
    currency?: true
    payment_terms?: true
    credit_limit?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerTaxInfoCountAggregateInputType = {
    id?: true
    customer_id?: true
    tax_number?: true
    default_tax?: true
    currency?: true
    payment_terms?: true
    credit_limit?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomerTaxInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerTaxInfo to aggregate.
     */
    where?: CustomerTaxInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTaxInfos to fetch.
     */
    orderBy?: CustomerTaxInfoOrderByWithRelationInput | CustomerTaxInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerTaxInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTaxInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTaxInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerTaxInfos
    **/
    _count?: true | CustomerTaxInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerTaxInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerTaxInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerTaxInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerTaxInfoMaxAggregateInputType
  }

  export type GetCustomerTaxInfoAggregateType<T extends CustomerTaxInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerTaxInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerTaxInfo[P]>
      : GetScalarType<T[P], AggregateCustomerTaxInfo[P]>
  }




  export type CustomerTaxInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerTaxInfoWhereInput
    orderBy?: CustomerTaxInfoOrderByWithAggregationInput | CustomerTaxInfoOrderByWithAggregationInput[]
    by: CustomerTaxInfoScalarFieldEnum[] | CustomerTaxInfoScalarFieldEnum
    having?: CustomerTaxInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerTaxInfoCountAggregateInputType | true
    _avg?: CustomerTaxInfoAvgAggregateInputType
    _sum?: CustomerTaxInfoSumAggregateInputType
    _min?: CustomerTaxInfoMinAggregateInputType
    _max?: CustomerTaxInfoMaxAggregateInputType
  }

  export type CustomerTaxInfoGroupByOutputType = {
    id: string
    customer_id: string
    tax_number: string | null
    default_tax: number | null
    currency: string
    payment_terms: string
    credit_limit: number | null
    created_at: Date
    updated_at: Date
    _count: CustomerTaxInfoCountAggregateOutputType | null
    _avg: CustomerTaxInfoAvgAggregateOutputType | null
    _sum: CustomerTaxInfoSumAggregateOutputType | null
    _min: CustomerTaxInfoMinAggregateOutputType | null
    _max: CustomerTaxInfoMaxAggregateOutputType | null
  }

  type GetCustomerTaxInfoGroupByPayload<T extends CustomerTaxInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerTaxInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerTaxInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerTaxInfoGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerTaxInfoGroupByOutputType[P]>
        }
      >
    >


  export type CustomerTaxInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    tax_number?: boolean
    default_tax?: boolean
    currency?: boolean
    payment_terms?: boolean
    credit_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerTaxInfo"]>

  export type CustomerTaxInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    tax_number?: boolean
    default_tax?: boolean
    currency?: boolean
    payment_terms?: boolean
    credit_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerTaxInfo"]>

  export type CustomerTaxInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    tax_number?: boolean
    default_tax?: boolean
    currency?: boolean
    payment_terms?: boolean
    credit_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerTaxInfo"]>

  export type CustomerTaxInfoSelectScalar = {
    id?: boolean
    customer_id?: boolean
    tax_number?: boolean
    default_tax?: boolean
    currency?: boolean
    payment_terms?: boolean
    credit_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomerTaxInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "tax_number" | "default_tax" | "currency" | "payment_terms" | "credit_limit" | "created_at" | "updated_at", ExtArgs["result"]["customerTaxInfo"]>
  export type CustomerTaxInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerTaxInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerTaxInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerTaxInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerTaxInfo"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      tax_number: string | null
      default_tax: number | null
      currency: string
      payment_terms: string
      credit_limit: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["customerTaxInfo"]>
    composites: {}
  }

  type CustomerTaxInfoGetPayload<S extends boolean | null | undefined | CustomerTaxInfoDefaultArgs> = $Result.GetResult<Prisma.$CustomerTaxInfoPayload, S>

  type CustomerTaxInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerTaxInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerTaxInfoCountAggregateInputType | true
    }

  export interface CustomerTaxInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerTaxInfo'], meta: { name: 'CustomerTaxInfo' } }
    /**
     * Find zero or one CustomerTaxInfo that matches the filter.
     * @param {CustomerTaxInfoFindUniqueArgs} args - Arguments to find a CustomerTaxInfo
     * @example
     * // Get one CustomerTaxInfo
     * const customerTaxInfo = await prisma.customerTaxInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerTaxInfoFindUniqueArgs>(args: SelectSubset<T, CustomerTaxInfoFindUniqueArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerTaxInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerTaxInfoFindUniqueOrThrowArgs} args - Arguments to find a CustomerTaxInfo
     * @example
     * // Get one CustomerTaxInfo
     * const customerTaxInfo = await prisma.customerTaxInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerTaxInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerTaxInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerTaxInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaxInfoFindFirstArgs} args - Arguments to find a CustomerTaxInfo
     * @example
     * // Get one CustomerTaxInfo
     * const customerTaxInfo = await prisma.customerTaxInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerTaxInfoFindFirstArgs>(args?: SelectSubset<T, CustomerTaxInfoFindFirstArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerTaxInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaxInfoFindFirstOrThrowArgs} args - Arguments to find a CustomerTaxInfo
     * @example
     * // Get one CustomerTaxInfo
     * const customerTaxInfo = await prisma.customerTaxInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerTaxInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerTaxInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerTaxInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaxInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerTaxInfos
     * const customerTaxInfos = await prisma.customerTaxInfo.findMany()
     * 
     * // Get first 10 CustomerTaxInfos
     * const customerTaxInfos = await prisma.customerTaxInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerTaxInfoWithIdOnly = await prisma.customerTaxInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerTaxInfoFindManyArgs>(args?: SelectSubset<T, CustomerTaxInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerTaxInfo.
     * @param {CustomerTaxInfoCreateArgs} args - Arguments to create a CustomerTaxInfo.
     * @example
     * // Create one CustomerTaxInfo
     * const CustomerTaxInfo = await prisma.customerTaxInfo.create({
     *   data: {
     *     // ... data to create a CustomerTaxInfo
     *   }
     * })
     * 
     */
    create<T extends CustomerTaxInfoCreateArgs>(args: SelectSubset<T, CustomerTaxInfoCreateArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerTaxInfos.
     * @param {CustomerTaxInfoCreateManyArgs} args - Arguments to create many CustomerTaxInfos.
     * @example
     * // Create many CustomerTaxInfos
     * const customerTaxInfo = await prisma.customerTaxInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerTaxInfoCreateManyArgs>(args?: SelectSubset<T, CustomerTaxInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerTaxInfos and returns the data saved in the database.
     * @param {CustomerTaxInfoCreateManyAndReturnArgs} args - Arguments to create many CustomerTaxInfos.
     * @example
     * // Create many CustomerTaxInfos
     * const customerTaxInfo = await prisma.customerTaxInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerTaxInfos and only return the `id`
     * const customerTaxInfoWithIdOnly = await prisma.customerTaxInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerTaxInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerTaxInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerTaxInfo.
     * @param {CustomerTaxInfoDeleteArgs} args - Arguments to delete one CustomerTaxInfo.
     * @example
     * // Delete one CustomerTaxInfo
     * const CustomerTaxInfo = await prisma.customerTaxInfo.delete({
     *   where: {
     *     // ... filter to delete one CustomerTaxInfo
     *   }
     * })
     * 
     */
    delete<T extends CustomerTaxInfoDeleteArgs>(args: SelectSubset<T, CustomerTaxInfoDeleteArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerTaxInfo.
     * @param {CustomerTaxInfoUpdateArgs} args - Arguments to update one CustomerTaxInfo.
     * @example
     * // Update one CustomerTaxInfo
     * const customerTaxInfo = await prisma.customerTaxInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerTaxInfoUpdateArgs>(args: SelectSubset<T, CustomerTaxInfoUpdateArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerTaxInfos.
     * @param {CustomerTaxInfoDeleteManyArgs} args - Arguments to filter CustomerTaxInfos to delete.
     * @example
     * // Delete a few CustomerTaxInfos
     * const { count } = await prisma.customerTaxInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerTaxInfoDeleteManyArgs>(args?: SelectSubset<T, CustomerTaxInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerTaxInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaxInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerTaxInfos
     * const customerTaxInfo = await prisma.customerTaxInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerTaxInfoUpdateManyArgs>(args: SelectSubset<T, CustomerTaxInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerTaxInfos and returns the data updated in the database.
     * @param {CustomerTaxInfoUpdateManyAndReturnArgs} args - Arguments to update many CustomerTaxInfos.
     * @example
     * // Update many CustomerTaxInfos
     * const customerTaxInfo = await prisma.customerTaxInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerTaxInfos and only return the `id`
     * const customerTaxInfoWithIdOnly = await prisma.customerTaxInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerTaxInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerTaxInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerTaxInfo.
     * @param {CustomerTaxInfoUpsertArgs} args - Arguments to update or create a CustomerTaxInfo.
     * @example
     * // Update or create a CustomerTaxInfo
     * const customerTaxInfo = await prisma.customerTaxInfo.upsert({
     *   create: {
     *     // ... data to create a CustomerTaxInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerTaxInfo we want to update
     *   }
     * })
     */
    upsert<T extends CustomerTaxInfoUpsertArgs>(args: SelectSubset<T, CustomerTaxInfoUpsertArgs<ExtArgs>>): Prisma__CustomerTaxInfoClient<$Result.GetResult<Prisma.$CustomerTaxInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerTaxInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaxInfoCountArgs} args - Arguments to filter CustomerTaxInfos to count.
     * @example
     * // Count the number of CustomerTaxInfos
     * const count = await prisma.customerTaxInfo.count({
     *   where: {
     *     // ... the filter for the CustomerTaxInfos we want to count
     *   }
     * })
    **/
    count<T extends CustomerTaxInfoCountArgs>(
      args?: Subset<T, CustomerTaxInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerTaxInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerTaxInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaxInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerTaxInfoAggregateArgs>(args: Subset<T, CustomerTaxInfoAggregateArgs>): Prisma.PrismaPromise<GetCustomerTaxInfoAggregateType<T>>

    /**
     * Group by CustomerTaxInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTaxInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerTaxInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerTaxInfoGroupByArgs['orderBy'] }
        : { orderBy?: CustomerTaxInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerTaxInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerTaxInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerTaxInfo model
   */
  readonly fields: CustomerTaxInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerTaxInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerTaxInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerTaxInfo model
   */
  interface CustomerTaxInfoFieldRefs {
    readonly id: FieldRef<"CustomerTaxInfo", 'String'>
    readonly customer_id: FieldRef<"CustomerTaxInfo", 'String'>
    readonly tax_number: FieldRef<"CustomerTaxInfo", 'String'>
    readonly default_tax: FieldRef<"CustomerTaxInfo", 'Float'>
    readonly currency: FieldRef<"CustomerTaxInfo", 'String'>
    readonly payment_terms: FieldRef<"CustomerTaxInfo", 'String'>
    readonly credit_limit: FieldRef<"CustomerTaxInfo", 'Float'>
    readonly created_at: FieldRef<"CustomerTaxInfo", 'DateTime'>
    readonly updated_at: FieldRef<"CustomerTaxInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerTaxInfo findUnique
   */
  export type CustomerTaxInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTaxInfo to fetch.
     */
    where: CustomerTaxInfoWhereUniqueInput
  }

  /**
   * CustomerTaxInfo findUniqueOrThrow
   */
  export type CustomerTaxInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTaxInfo to fetch.
     */
    where: CustomerTaxInfoWhereUniqueInput
  }

  /**
   * CustomerTaxInfo findFirst
   */
  export type CustomerTaxInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTaxInfo to fetch.
     */
    where?: CustomerTaxInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTaxInfos to fetch.
     */
    orderBy?: CustomerTaxInfoOrderByWithRelationInput | CustomerTaxInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTaxInfos.
     */
    cursor?: CustomerTaxInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTaxInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTaxInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTaxInfos.
     */
    distinct?: CustomerTaxInfoScalarFieldEnum | CustomerTaxInfoScalarFieldEnum[]
  }

  /**
   * CustomerTaxInfo findFirstOrThrow
   */
  export type CustomerTaxInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTaxInfo to fetch.
     */
    where?: CustomerTaxInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTaxInfos to fetch.
     */
    orderBy?: CustomerTaxInfoOrderByWithRelationInput | CustomerTaxInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTaxInfos.
     */
    cursor?: CustomerTaxInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTaxInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTaxInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTaxInfos.
     */
    distinct?: CustomerTaxInfoScalarFieldEnum | CustomerTaxInfoScalarFieldEnum[]
  }

  /**
   * CustomerTaxInfo findMany
   */
  export type CustomerTaxInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTaxInfos to fetch.
     */
    where?: CustomerTaxInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTaxInfos to fetch.
     */
    orderBy?: CustomerTaxInfoOrderByWithRelationInput | CustomerTaxInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerTaxInfos.
     */
    cursor?: CustomerTaxInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTaxInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTaxInfos.
     */
    skip?: number
    distinct?: CustomerTaxInfoScalarFieldEnum | CustomerTaxInfoScalarFieldEnum[]
  }

  /**
   * CustomerTaxInfo create
   */
  export type CustomerTaxInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerTaxInfo.
     */
    data: XOR<CustomerTaxInfoCreateInput, CustomerTaxInfoUncheckedCreateInput>
  }

  /**
   * CustomerTaxInfo createMany
   */
  export type CustomerTaxInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerTaxInfos.
     */
    data: CustomerTaxInfoCreateManyInput | CustomerTaxInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerTaxInfo createManyAndReturn
   */
  export type CustomerTaxInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerTaxInfos.
     */
    data: CustomerTaxInfoCreateManyInput | CustomerTaxInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerTaxInfo update
   */
  export type CustomerTaxInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerTaxInfo.
     */
    data: XOR<CustomerTaxInfoUpdateInput, CustomerTaxInfoUncheckedUpdateInput>
    /**
     * Choose, which CustomerTaxInfo to update.
     */
    where: CustomerTaxInfoWhereUniqueInput
  }

  /**
   * CustomerTaxInfo updateMany
   */
  export type CustomerTaxInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerTaxInfos.
     */
    data: XOR<CustomerTaxInfoUpdateManyMutationInput, CustomerTaxInfoUncheckedUpdateManyInput>
    /**
     * Filter which CustomerTaxInfos to update
     */
    where?: CustomerTaxInfoWhereInput
    /**
     * Limit how many CustomerTaxInfos to update.
     */
    limit?: number
  }

  /**
   * CustomerTaxInfo updateManyAndReturn
   */
  export type CustomerTaxInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * The data used to update CustomerTaxInfos.
     */
    data: XOR<CustomerTaxInfoUpdateManyMutationInput, CustomerTaxInfoUncheckedUpdateManyInput>
    /**
     * Filter which CustomerTaxInfos to update
     */
    where?: CustomerTaxInfoWhereInput
    /**
     * Limit how many CustomerTaxInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerTaxInfo upsert
   */
  export type CustomerTaxInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerTaxInfo to update in case it exists.
     */
    where: CustomerTaxInfoWhereUniqueInput
    /**
     * In case the CustomerTaxInfo found by the `where` argument doesn't exist, create a new CustomerTaxInfo with this data.
     */
    create: XOR<CustomerTaxInfoCreateInput, CustomerTaxInfoUncheckedCreateInput>
    /**
     * In case the CustomerTaxInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerTaxInfoUpdateInput, CustomerTaxInfoUncheckedUpdateInput>
  }

  /**
   * CustomerTaxInfo delete
   */
  export type CustomerTaxInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
    /**
     * Filter which CustomerTaxInfo to delete.
     */
    where: CustomerTaxInfoWhereUniqueInput
  }

  /**
   * CustomerTaxInfo deleteMany
   */
  export type CustomerTaxInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerTaxInfos to delete
     */
    where?: CustomerTaxInfoWhereInput
    /**
     * Limit how many CustomerTaxInfos to delete.
     */
    limit?: number
  }

  /**
   * CustomerTaxInfo without action
   */
  export type CustomerTaxInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTaxInfo
     */
    select?: CustomerTaxInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTaxInfo
     */
    omit?: CustomerTaxInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTaxInfoInclude<ExtArgs> | null
  }


  /**
   * Model CustomerContact
   */

  export type AggregateCustomerContact = {
    _count: CustomerContactCountAggregateOutputType | null
    _min: CustomerContactMinAggregateOutputType | null
    _max: CustomerContactMaxAggregateOutputType | null
  }

  export type CustomerContactMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    contact_name: string | null
    job_title: string | null
    contact_email: string | null
    contact_phone: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerContactMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    contact_name: string | null
    job_title: string | null
    contact_email: string | null
    contact_phone: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerContactCountAggregateOutputType = {
    id: number
    customer_id: number
    customer_name: number
    contact_name: number
    job_title: number
    contact_email: number
    contact_phone: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomerContactMinAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    contact_name?: true
    job_title?: true
    contact_email?: true
    contact_phone?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerContactMaxAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    contact_name?: true
    job_title?: true
    contact_email?: true
    contact_phone?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerContactCountAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    contact_name?: true
    job_title?: true
    contact_email?: true
    contact_phone?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomerContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerContact to aggregate.
     */
    where?: CustomerContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerContacts to fetch.
     */
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerContacts
    **/
    _count?: true | CustomerContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerContactMaxAggregateInputType
  }

  export type GetCustomerContactAggregateType<T extends CustomerContactAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerContact[P]>
      : GetScalarType<T[P], AggregateCustomerContact[P]>
  }




  export type CustomerContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerContactWhereInput
    orderBy?: CustomerContactOrderByWithAggregationInput | CustomerContactOrderByWithAggregationInput[]
    by: CustomerContactScalarFieldEnum[] | CustomerContactScalarFieldEnum
    having?: CustomerContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerContactCountAggregateInputType | true
    _min?: CustomerContactMinAggregateInputType
    _max?: CustomerContactMaxAggregateInputType
  }

  export type CustomerContactGroupByOutputType = {
    id: string
    customer_id: string
    customer_name: string
    contact_name: string | null
    job_title: string | null
    contact_email: string | null
    contact_phone: string | null
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: CustomerContactCountAggregateOutputType | null
    _min: CustomerContactMinAggregateOutputType | null
    _max: CustomerContactMaxAggregateOutputType | null
  }

  type GetCustomerContactGroupByPayload<T extends CustomerContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerContactGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerContactGroupByOutputType[P]>
        }
      >
    >


  export type CustomerContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    contact_name?: boolean
    job_title?: boolean
    contact_email?: boolean
    contact_phone?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerContact"]>

  export type CustomerContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    contact_name?: boolean
    job_title?: boolean
    contact_email?: boolean
    contact_phone?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerContact"]>

  export type CustomerContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    contact_name?: boolean
    job_title?: boolean
    contact_email?: boolean
    contact_phone?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerContact"]>

  export type CustomerContactSelectScalar = {
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    contact_name?: boolean
    job_title?: boolean
    contact_email?: boolean
    contact_phone?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomerContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "customer_name" | "contact_name" | "job_title" | "contact_email" | "contact_phone" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["customerContact"]>
  export type CustomerContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerContact"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      customer_name: string
      contact_name: string | null
      job_title: string | null
      contact_email: string | null
      contact_phone: string | null
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["customerContact"]>
    composites: {}
  }

  type CustomerContactGetPayload<S extends boolean | null | undefined | CustomerContactDefaultArgs> = $Result.GetResult<Prisma.$CustomerContactPayload, S>

  type CustomerContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerContactCountAggregateInputType | true
    }

  export interface CustomerContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerContact'], meta: { name: 'CustomerContact' } }
    /**
     * Find zero or one CustomerContact that matches the filter.
     * @param {CustomerContactFindUniqueArgs} args - Arguments to find a CustomerContact
     * @example
     * // Get one CustomerContact
     * const customerContact = await prisma.customerContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerContactFindUniqueArgs>(args: SelectSubset<T, CustomerContactFindUniqueArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerContactFindUniqueOrThrowArgs} args - Arguments to find a CustomerContact
     * @example
     * // Get one CustomerContact
     * const customerContact = await prisma.customerContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerContactFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactFindFirstArgs} args - Arguments to find a CustomerContact
     * @example
     * // Get one CustomerContact
     * const customerContact = await prisma.customerContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerContactFindFirstArgs>(args?: SelectSubset<T, CustomerContactFindFirstArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactFindFirstOrThrowArgs} args - Arguments to find a CustomerContact
     * @example
     * // Get one CustomerContact
     * const customerContact = await prisma.customerContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerContactFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerContacts
     * const customerContacts = await prisma.customerContact.findMany()
     * 
     * // Get first 10 CustomerContacts
     * const customerContacts = await prisma.customerContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerContactWithIdOnly = await prisma.customerContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerContactFindManyArgs>(args?: SelectSubset<T, CustomerContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerContact.
     * @param {CustomerContactCreateArgs} args - Arguments to create a CustomerContact.
     * @example
     * // Create one CustomerContact
     * const CustomerContact = await prisma.customerContact.create({
     *   data: {
     *     // ... data to create a CustomerContact
     *   }
     * })
     * 
     */
    create<T extends CustomerContactCreateArgs>(args: SelectSubset<T, CustomerContactCreateArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerContacts.
     * @param {CustomerContactCreateManyArgs} args - Arguments to create many CustomerContacts.
     * @example
     * // Create many CustomerContacts
     * const customerContact = await prisma.customerContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerContactCreateManyArgs>(args?: SelectSubset<T, CustomerContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerContacts and returns the data saved in the database.
     * @param {CustomerContactCreateManyAndReturnArgs} args - Arguments to create many CustomerContacts.
     * @example
     * // Create many CustomerContacts
     * const customerContact = await prisma.customerContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerContacts and only return the `id`
     * const customerContactWithIdOnly = await prisma.customerContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerContactCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerContact.
     * @param {CustomerContactDeleteArgs} args - Arguments to delete one CustomerContact.
     * @example
     * // Delete one CustomerContact
     * const CustomerContact = await prisma.customerContact.delete({
     *   where: {
     *     // ... filter to delete one CustomerContact
     *   }
     * })
     * 
     */
    delete<T extends CustomerContactDeleteArgs>(args: SelectSubset<T, CustomerContactDeleteArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerContact.
     * @param {CustomerContactUpdateArgs} args - Arguments to update one CustomerContact.
     * @example
     * // Update one CustomerContact
     * const customerContact = await prisma.customerContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerContactUpdateArgs>(args: SelectSubset<T, CustomerContactUpdateArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerContacts.
     * @param {CustomerContactDeleteManyArgs} args - Arguments to filter CustomerContacts to delete.
     * @example
     * // Delete a few CustomerContacts
     * const { count } = await prisma.customerContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerContactDeleteManyArgs>(args?: SelectSubset<T, CustomerContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerContacts
     * const customerContact = await prisma.customerContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerContactUpdateManyArgs>(args: SelectSubset<T, CustomerContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerContacts and returns the data updated in the database.
     * @param {CustomerContactUpdateManyAndReturnArgs} args - Arguments to update many CustomerContacts.
     * @example
     * // Update many CustomerContacts
     * const customerContact = await prisma.customerContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerContacts and only return the `id`
     * const customerContactWithIdOnly = await prisma.customerContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerContactUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerContact.
     * @param {CustomerContactUpsertArgs} args - Arguments to update or create a CustomerContact.
     * @example
     * // Update or create a CustomerContact
     * const customerContact = await prisma.customerContact.upsert({
     *   create: {
     *     // ... data to create a CustomerContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerContact we want to update
     *   }
     * })
     */
    upsert<T extends CustomerContactUpsertArgs>(args: SelectSubset<T, CustomerContactUpsertArgs<ExtArgs>>): Prisma__CustomerContactClient<$Result.GetResult<Prisma.$CustomerContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactCountArgs} args - Arguments to filter CustomerContacts to count.
     * @example
     * // Count the number of CustomerContacts
     * const count = await prisma.customerContact.count({
     *   where: {
     *     // ... the filter for the CustomerContacts we want to count
     *   }
     * })
    **/
    count<T extends CustomerContactCountArgs>(
      args?: Subset<T, CustomerContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerContactAggregateArgs>(args: Subset<T, CustomerContactAggregateArgs>): Prisma.PrismaPromise<GetCustomerContactAggregateType<T>>

    /**
     * Group by CustomerContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerContactGroupByArgs['orderBy'] }
        : { orderBy?: CustomerContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerContact model
   */
  readonly fields: CustomerContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerContact model
   */
  interface CustomerContactFieldRefs {
    readonly id: FieldRef<"CustomerContact", 'String'>
    readonly customer_id: FieldRef<"CustomerContact", 'String'>
    readonly customer_name: FieldRef<"CustomerContact", 'String'>
    readonly contact_name: FieldRef<"CustomerContact", 'String'>
    readonly job_title: FieldRef<"CustomerContact", 'String'>
    readonly contact_email: FieldRef<"CustomerContact", 'String'>
    readonly contact_phone: FieldRef<"CustomerContact", 'String'>
    readonly is_primary: FieldRef<"CustomerContact", 'Boolean'>
    readonly created_at: FieldRef<"CustomerContact", 'DateTime'>
    readonly updated_at: FieldRef<"CustomerContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerContact findUnique
   */
  export type CustomerContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContact to fetch.
     */
    where: CustomerContactWhereUniqueInput
  }

  /**
   * CustomerContact findUniqueOrThrow
   */
  export type CustomerContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContact to fetch.
     */
    where: CustomerContactWhereUniqueInput
  }

  /**
   * CustomerContact findFirst
   */
  export type CustomerContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContact to fetch.
     */
    where?: CustomerContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerContacts to fetch.
     */
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerContacts.
     */
    cursor?: CustomerContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerContacts.
     */
    distinct?: CustomerContactScalarFieldEnum | CustomerContactScalarFieldEnum[]
  }

  /**
   * CustomerContact findFirstOrThrow
   */
  export type CustomerContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContact to fetch.
     */
    where?: CustomerContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerContacts to fetch.
     */
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerContacts.
     */
    cursor?: CustomerContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerContacts.
     */
    distinct?: CustomerContactScalarFieldEnum | CustomerContactScalarFieldEnum[]
  }

  /**
   * CustomerContact findMany
   */
  export type CustomerContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter, which CustomerContacts to fetch.
     */
    where?: CustomerContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerContacts to fetch.
     */
    orderBy?: CustomerContactOrderByWithRelationInput | CustomerContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerContacts.
     */
    cursor?: CustomerContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerContacts.
     */
    skip?: number
    distinct?: CustomerContactScalarFieldEnum | CustomerContactScalarFieldEnum[]
  }

  /**
   * CustomerContact create
   */
  export type CustomerContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerContact.
     */
    data: XOR<CustomerContactCreateInput, CustomerContactUncheckedCreateInput>
  }

  /**
   * CustomerContact createMany
   */
  export type CustomerContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerContacts.
     */
    data: CustomerContactCreateManyInput | CustomerContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerContact createManyAndReturn
   */
  export type CustomerContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerContacts.
     */
    data: CustomerContactCreateManyInput | CustomerContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerContact update
   */
  export type CustomerContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerContact.
     */
    data: XOR<CustomerContactUpdateInput, CustomerContactUncheckedUpdateInput>
    /**
     * Choose, which CustomerContact to update.
     */
    where: CustomerContactWhereUniqueInput
  }

  /**
   * CustomerContact updateMany
   */
  export type CustomerContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerContacts.
     */
    data: XOR<CustomerContactUpdateManyMutationInput, CustomerContactUncheckedUpdateManyInput>
    /**
     * Filter which CustomerContacts to update
     */
    where?: CustomerContactWhereInput
    /**
     * Limit how many CustomerContacts to update.
     */
    limit?: number
  }

  /**
   * CustomerContact updateManyAndReturn
   */
  export type CustomerContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * The data used to update CustomerContacts.
     */
    data: XOR<CustomerContactUpdateManyMutationInput, CustomerContactUncheckedUpdateManyInput>
    /**
     * Filter which CustomerContacts to update
     */
    where?: CustomerContactWhereInput
    /**
     * Limit how many CustomerContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerContact upsert
   */
  export type CustomerContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerContact to update in case it exists.
     */
    where: CustomerContactWhereUniqueInput
    /**
     * In case the CustomerContact found by the `where` argument doesn't exist, create a new CustomerContact with this data.
     */
    create: XOR<CustomerContactCreateInput, CustomerContactUncheckedCreateInput>
    /**
     * In case the CustomerContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerContactUpdateInput, CustomerContactUncheckedUpdateInput>
  }

  /**
   * CustomerContact delete
   */
  export type CustomerContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
    /**
     * Filter which CustomerContact to delete.
     */
    where: CustomerContactWhereUniqueInput
  }

  /**
   * CustomerContact deleteMany
   */
  export type CustomerContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerContacts to delete
     */
    where?: CustomerContactWhereInput
    /**
     * Limit how many CustomerContacts to delete.
     */
    limit?: number
  }

  /**
   * CustomerContact without action
   */
  export type CustomerContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerContact
     */
    select?: CustomerContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerContact
     */
    omit?: CustomerContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerContactInclude<ExtArgs> | null
  }


  /**
   * Model CustomerOperationalInfo
   */

  export type AggregateCustomerOperationalInfo = {
    _count: CustomerOperationalInfoCountAggregateOutputType | null
    _min: CustomerOperationalInfoMinAggregateOutputType | null
    _max: CustomerOperationalInfoMaxAggregateOutputType | null
  }

  export type CustomerOperationalInfoMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    delivery_method: string | null
    quote_format: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerOperationalInfoMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    delivery_method: string | null
    quote_format: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerOperationalInfoCountAggregateOutputType = {
    id: number
    customer_id: number
    delivery_method: number
    quote_format: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomerOperationalInfoMinAggregateInputType = {
    id?: true
    customer_id?: true
    delivery_method?: true
    quote_format?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerOperationalInfoMaxAggregateInputType = {
    id?: true
    customer_id?: true
    delivery_method?: true
    quote_format?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerOperationalInfoCountAggregateInputType = {
    id?: true
    customer_id?: true
    delivery_method?: true
    quote_format?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomerOperationalInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerOperationalInfo to aggregate.
     */
    where?: CustomerOperationalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerOperationalInfos to fetch.
     */
    orderBy?: CustomerOperationalInfoOrderByWithRelationInput | CustomerOperationalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerOperationalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerOperationalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerOperationalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerOperationalInfos
    **/
    _count?: true | CustomerOperationalInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerOperationalInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerOperationalInfoMaxAggregateInputType
  }

  export type GetCustomerOperationalInfoAggregateType<T extends CustomerOperationalInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerOperationalInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerOperationalInfo[P]>
      : GetScalarType<T[P], AggregateCustomerOperationalInfo[P]>
  }




  export type CustomerOperationalInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerOperationalInfoWhereInput
    orderBy?: CustomerOperationalInfoOrderByWithAggregationInput | CustomerOperationalInfoOrderByWithAggregationInput[]
    by: CustomerOperationalInfoScalarFieldEnum[] | CustomerOperationalInfoScalarFieldEnum
    having?: CustomerOperationalInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerOperationalInfoCountAggregateInputType | true
    _min?: CustomerOperationalInfoMinAggregateInputType
    _max?: CustomerOperationalInfoMaxAggregateInputType
  }

  export type CustomerOperationalInfoGroupByOutputType = {
    id: string
    customer_id: string
    delivery_method: string | null
    quote_format: string | null
    created_at: Date
    updated_at: Date
    _count: CustomerOperationalInfoCountAggregateOutputType | null
    _min: CustomerOperationalInfoMinAggregateOutputType | null
    _max: CustomerOperationalInfoMaxAggregateOutputType | null
  }

  type GetCustomerOperationalInfoGroupByPayload<T extends CustomerOperationalInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerOperationalInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerOperationalInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerOperationalInfoGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerOperationalInfoGroupByOutputType[P]>
        }
      >
    >


  export type CustomerOperationalInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    delivery_method?: boolean
    quote_format?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerOperationalInfo"]>

  export type CustomerOperationalInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    delivery_method?: boolean
    quote_format?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerOperationalInfo"]>

  export type CustomerOperationalInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    delivery_method?: boolean
    quote_format?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerOperationalInfo"]>

  export type CustomerOperationalInfoSelectScalar = {
    id?: boolean
    customer_id?: boolean
    delivery_method?: boolean
    quote_format?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomerOperationalInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "delivery_method" | "quote_format" | "created_at" | "updated_at", ExtArgs["result"]["customerOperationalInfo"]>
  export type CustomerOperationalInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerOperationalInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerOperationalInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerOperationalInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerOperationalInfo"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      delivery_method: string | null
      quote_format: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["customerOperationalInfo"]>
    composites: {}
  }

  type CustomerOperationalInfoGetPayload<S extends boolean | null | undefined | CustomerOperationalInfoDefaultArgs> = $Result.GetResult<Prisma.$CustomerOperationalInfoPayload, S>

  type CustomerOperationalInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerOperationalInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerOperationalInfoCountAggregateInputType | true
    }

  export interface CustomerOperationalInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerOperationalInfo'], meta: { name: 'CustomerOperationalInfo' } }
    /**
     * Find zero or one CustomerOperationalInfo that matches the filter.
     * @param {CustomerOperationalInfoFindUniqueArgs} args - Arguments to find a CustomerOperationalInfo
     * @example
     * // Get one CustomerOperationalInfo
     * const customerOperationalInfo = await prisma.customerOperationalInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerOperationalInfoFindUniqueArgs>(args: SelectSubset<T, CustomerOperationalInfoFindUniqueArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerOperationalInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerOperationalInfoFindUniqueOrThrowArgs} args - Arguments to find a CustomerOperationalInfo
     * @example
     * // Get one CustomerOperationalInfo
     * const customerOperationalInfo = await prisma.customerOperationalInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerOperationalInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerOperationalInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerOperationalInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOperationalInfoFindFirstArgs} args - Arguments to find a CustomerOperationalInfo
     * @example
     * // Get one CustomerOperationalInfo
     * const customerOperationalInfo = await prisma.customerOperationalInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerOperationalInfoFindFirstArgs>(args?: SelectSubset<T, CustomerOperationalInfoFindFirstArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerOperationalInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOperationalInfoFindFirstOrThrowArgs} args - Arguments to find a CustomerOperationalInfo
     * @example
     * // Get one CustomerOperationalInfo
     * const customerOperationalInfo = await prisma.customerOperationalInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerOperationalInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerOperationalInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerOperationalInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOperationalInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerOperationalInfos
     * const customerOperationalInfos = await prisma.customerOperationalInfo.findMany()
     * 
     * // Get first 10 CustomerOperationalInfos
     * const customerOperationalInfos = await prisma.customerOperationalInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerOperationalInfoWithIdOnly = await prisma.customerOperationalInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerOperationalInfoFindManyArgs>(args?: SelectSubset<T, CustomerOperationalInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerOperationalInfo.
     * @param {CustomerOperationalInfoCreateArgs} args - Arguments to create a CustomerOperationalInfo.
     * @example
     * // Create one CustomerOperationalInfo
     * const CustomerOperationalInfo = await prisma.customerOperationalInfo.create({
     *   data: {
     *     // ... data to create a CustomerOperationalInfo
     *   }
     * })
     * 
     */
    create<T extends CustomerOperationalInfoCreateArgs>(args: SelectSubset<T, CustomerOperationalInfoCreateArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerOperationalInfos.
     * @param {CustomerOperationalInfoCreateManyArgs} args - Arguments to create many CustomerOperationalInfos.
     * @example
     * // Create many CustomerOperationalInfos
     * const customerOperationalInfo = await prisma.customerOperationalInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerOperationalInfoCreateManyArgs>(args?: SelectSubset<T, CustomerOperationalInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerOperationalInfos and returns the data saved in the database.
     * @param {CustomerOperationalInfoCreateManyAndReturnArgs} args - Arguments to create many CustomerOperationalInfos.
     * @example
     * // Create many CustomerOperationalInfos
     * const customerOperationalInfo = await prisma.customerOperationalInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerOperationalInfos and only return the `id`
     * const customerOperationalInfoWithIdOnly = await prisma.customerOperationalInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerOperationalInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerOperationalInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerOperationalInfo.
     * @param {CustomerOperationalInfoDeleteArgs} args - Arguments to delete one CustomerOperationalInfo.
     * @example
     * // Delete one CustomerOperationalInfo
     * const CustomerOperationalInfo = await prisma.customerOperationalInfo.delete({
     *   where: {
     *     // ... filter to delete one CustomerOperationalInfo
     *   }
     * })
     * 
     */
    delete<T extends CustomerOperationalInfoDeleteArgs>(args: SelectSubset<T, CustomerOperationalInfoDeleteArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerOperationalInfo.
     * @param {CustomerOperationalInfoUpdateArgs} args - Arguments to update one CustomerOperationalInfo.
     * @example
     * // Update one CustomerOperationalInfo
     * const customerOperationalInfo = await prisma.customerOperationalInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerOperationalInfoUpdateArgs>(args: SelectSubset<T, CustomerOperationalInfoUpdateArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerOperationalInfos.
     * @param {CustomerOperationalInfoDeleteManyArgs} args - Arguments to filter CustomerOperationalInfos to delete.
     * @example
     * // Delete a few CustomerOperationalInfos
     * const { count } = await prisma.customerOperationalInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerOperationalInfoDeleteManyArgs>(args?: SelectSubset<T, CustomerOperationalInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerOperationalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOperationalInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerOperationalInfos
     * const customerOperationalInfo = await prisma.customerOperationalInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerOperationalInfoUpdateManyArgs>(args: SelectSubset<T, CustomerOperationalInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerOperationalInfos and returns the data updated in the database.
     * @param {CustomerOperationalInfoUpdateManyAndReturnArgs} args - Arguments to update many CustomerOperationalInfos.
     * @example
     * // Update many CustomerOperationalInfos
     * const customerOperationalInfo = await prisma.customerOperationalInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerOperationalInfos and only return the `id`
     * const customerOperationalInfoWithIdOnly = await prisma.customerOperationalInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerOperationalInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerOperationalInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerOperationalInfo.
     * @param {CustomerOperationalInfoUpsertArgs} args - Arguments to update or create a CustomerOperationalInfo.
     * @example
     * // Update or create a CustomerOperationalInfo
     * const customerOperationalInfo = await prisma.customerOperationalInfo.upsert({
     *   create: {
     *     // ... data to create a CustomerOperationalInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerOperationalInfo we want to update
     *   }
     * })
     */
    upsert<T extends CustomerOperationalInfoUpsertArgs>(args: SelectSubset<T, CustomerOperationalInfoUpsertArgs<ExtArgs>>): Prisma__CustomerOperationalInfoClient<$Result.GetResult<Prisma.$CustomerOperationalInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerOperationalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOperationalInfoCountArgs} args - Arguments to filter CustomerOperationalInfos to count.
     * @example
     * // Count the number of CustomerOperationalInfos
     * const count = await prisma.customerOperationalInfo.count({
     *   where: {
     *     // ... the filter for the CustomerOperationalInfos we want to count
     *   }
     * })
    **/
    count<T extends CustomerOperationalInfoCountArgs>(
      args?: Subset<T, CustomerOperationalInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerOperationalInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerOperationalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOperationalInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerOperationalInfoAggregateArgs>(args: Subset<T, CustomerOperationalInfoAggregateArgs>): Prisma.PrismaPromise<GetCustomerOperationalInfoAggregateType<T>>

    /**
     * Group by CustomerOperationalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOperationalInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerOperationalInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerOperationalInfoGroupByArgs['orderBy'] }
        : { orderBy?: CustomerOperationalInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerOperationalInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerOperationalInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerOperationalInfo model
   */
  readonly fields: CustomerOperationalInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerOperationalInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerOperationalInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerOperationalInfo model
   */
  interface CustomerOperationalInfoFieldRefs {
    readonly id: FieldRef<"CustomerOperationalInfo", 'String'>
    readonly customer_id: FieldRef<"CustomerOperationalInfo", 'String'>
    readonly delivery_method: FieldRef<"CustomerOperationalInfo", 'String'>
    readonly quote_format: FieldRef<"CustomerOperationalInfo", 'String'>
    readonly created_at: FieldRef<"CustomerOperationalInfo", 'DateTime'>
    readonly updated_at: FieldRef<"CustomerOperationalInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerOperationalInfo findUnique
   */
  export type CustomerOperationalInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerOperationalInfo to fetch.
     */
    where: CustomerOperationalInfoWhereUniqueInput
  }

  /**
   * CustomerOperationalInfo findUniqueOrThrow
   */
  export type CustomerOperationalInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerOperationalInfo to fetch.
     */
    where: CustomerOperationalInfoWhereUniqueInput
  }

  /**
   * CustomerOperationalInfo findFirst
   */
  export type CustomerOperationalInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerOperationalInfo to fetch.
     */
    where?: CustomerOperationalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerOperationalInfos to fetch.
     */
    orderBy?: CustomerOperationalInfoOrderByWithRelationInput | CustomerOperationalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerOperationalInfos.
     */
    cursor?: CustomerOperationalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerOperationalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerOperationalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerOperationalInfos.
     */
    distinct?: CustomerOperationalInfoScalarFieldEnum | CustomerOperationalInfoScalarFieldEnum[]
  }

  /**
   * CustomerOperationalInfo findFirstOrThrow
   */
  export type CustomerOperationalInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerOperationalInfo to fetch.
     */
    where?: CustomerOperationalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerOperationalInfos to fetch.
     */
    orderBy?: CustomerOperationalInfoOrderByWithRelationInput | CustomerOperationalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerOperationalInfos.
     */
    cursor?: CustomerOperationalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerOperationalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerOperationalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerOperationalInfos.
     */
    distinct?: CustomerOperationalInfoScalarFieldEnum | CustomerOperationalInfoScalarFieldEnum[]
  }

  /**
   * CustomerOperationalInfo findMany
   */
  export type CustomerOperationalInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * Filter, which CustomerOperationalInfos to fetch.
     */
    where?: CustomerOperationalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerOperationalInfos to fetch.
     */
    orderBy?: CustomerOperationalInfoOrderByWithRelationInput | CustomerOperationalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerOperationalInfos.
     */
    cursor?: CustomerOperationalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerOperationalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerOperationalInfos.
     */
    skip?: number
    distinct?: CustomerOperationalInfoScalarFieldEnum | CustomerOperationalInfoScalarFieldEnum[]
  }

  /**
   * CustomerOperationalInfo create
   */
  export type CustomerOperationalInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerOperationalInfo.
     */
    data: XOR<CustomerOperationalInfoCreateInput, CustomerOperationalInfoUncheckedCreateInput>
  }

  /**
   * CustomerOperationalInfo createMany
   */
  export type CustomerOperationalInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerOperationalInfos.
     */
    data: CustomerOperationalInfoCreateManyInput | CustomerOperationalInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerOperationalInfo createManyAndReturn
   */
  export type CustomerOperationalInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerOperationalInfos.
     */
    data: CustomerOperationalInfoCreateManyInput | CustomerOperationalInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerOperationalInfo update
   */
  export type CustomerOperationalInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerOperationalInfo.
     */
    data: XOR<CustomerOperationalInfoUpdateInput, CustomerOperationalInfoUncheckedUpdateInput>
    /**
     * Choose, which CustomerOperationalInfo to update.
     */
    where: CustomerOperationalInfoWhereUniqueInput
  }

  /**
   * CustomerOperationalInfo updateMany
   */
  export type CustomerOperationalInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerOperationalInfos.
     */
    data: XOR<CustomerOperationalInfoUpdateManyMutationInput, CustomerOperationalInfoUncheckedUpdateManyInput>
    /**
     * Filter which CustomerOperationalInfos to update
     */
    where?: CustomerOperationalInfoWhereInput
    /**
     * Limit how many CustomerOperationalInfos to update.
     */
    limit?: number
  }

  /**
   * CustomerOperationalInfo updateManyAndReturn
   */
  export type CustomerOperationalInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * The data used to update CustomerOperationalInfos.
     */
    data: XOR<CustomerOperationalInfoUpdateManyMutationInput, CustomerOperationalInfoUncheckedUpdateManyInput>
    /**
     * Filter which CustomerOperationalInfos to update
     */
    where?: CustomerOperationalInfoWhereInput
    /**
     * Limit how many CustomerOperationalInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerOperationalInfo upsert
   */
  export type CustomerOperationalInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerOperationalInfo to update in case it exists.
     */
    where: CustomerOperationalInfoWhereUniqueInput
    /**
     * In case the CustomerOperationalInfo found by the `where` argument doesn't exist, create a new CustomerOperationalInfo with this data.
     */
    create: XOR<CustomerOperationalInfoCreateInput, CustomerOperationalInfoUncheckedCreateInput>
    /**
     * In case the CustomerOperationalInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerOperationalInfoUpdateInput, CustomerOperationalInfoUncheckedUpdateInput>
  }

  /**
   * CustomerOperationalInfo delete
   */
  export type CustomerOperationalInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
    /**
     * Filter which CustomerOperationalInfo to delete.
     */
    where: CustomerOperationalInfoWhereUniqueInput
  }

  /**
   * CustomerOperationalInfo deleteMany
   */
  export type CustomerOperationalInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerOperationalInfos to delete
     */
    where?: CustomerOperationalInfoWhereInput
    /**
     * Limit how many CustomerOperationalInfos to delete.
     */
    limit?: number
  }

  /**
   * CustomerOperationalInfo without action
   */
  export type CustomerOperationalInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOperationalInfo
     */
    select?: CustomerOperationalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOperationalInfo
     */
    omit?: CustomerOperationalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerOperationalInfoInclude<ExtArgs> | null
  }


  /**
   * Model CustomerNotesAndAttachments
   */

  export type AggregateCustomerNotesAndAttachments = {
    _count: CustomerNotesAndAttachmentsCountAggregateOutputType | null
    _min: CustomerNotesAndAttachmentsMinAggregateOutputType | null
    _max: CustomerNotesAndAttachmentsMaxAggregateOutputType | null
  }

  export type CustomerNotesAndAttachmentsMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    internal_notes: string | null
    file_url: string | null
    file_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerNotesAndAttachmentsMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    internal_notes: string | null
    file_url: string | null
    file_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerNotesAndAttachmentsCountAggregateOutputType = {
    id: number
    customer_id: number
    internal_notes: number
    tags: number
    file_url: number
    file_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomerNotesAndAttachmentsMinAggregateInputType = {
    id?: true
    customer_id?: true
    internal_notes?: true
    file_url?: true
    file_name?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerNotesAndAttachmentsMaxAggregateInputType = {
    id?: true
    customer_id?: true
    internal_notes?: true
    file_url?: true
    file_name?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerNotesAndAttachmentsCountAggregateInputType = {
    id?: true
    customer_id?: true
    internal_notes?: true
    tags?: true
    file_url?: true
    file_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomerNotesAndAttachmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerNotesAndAttachments to aggregate.
     */
    where?: CustomerNotesAndAttachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNotesAndAttachments to fetch.
     */
    orderBy?: CustomerNotesAndAttachmentsOrderByWithRelationInput | CustomerNotesAndAttachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerNotesAndAttachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNotesAndAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNotesAndAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerNotesAndAttachments
    **/
    _count?: true | CustomerNotesAndAttachmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerNotesAndAttachmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerNotesAndAttachmentsMaxAggregateInputType
  }

  export type GetCustomerNotesAndAttachmentsAggregateType<T extends CustomerNotesAndAttachmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerNotesAndAttachments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerNotesAndAttachments[P]>
      : GetScalarType<T[P], AggregateCustomerNotesAndAttachments[P]>
  }




  export type CustomerNotesAndAttachmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerNotesAndAttachmentsWhereInput
    orderBy?: CustomerNotesAndAttachmentsOrderByWithAggregationInput | CustomerNotesAndAttachmentsOrderByWithAggregationInput[]
    by: CustomerNotesAndAttachmentsScalarFieldEnum[] | CustomerNotesAndAttachmentsScalarFieldEnum
    having?: CustomerNotesAndAttachmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerNotesAndAttachmentsCountAggregateInputType | true
    _min?: CustomerNotesAndAttachmentsMinAggregateInputType
    _max?: CustomerNotesAndAttachmentsMaxAggregateInputType
  }

  export type CustomerNotesAndAttachmentsGroupByOutputType = {
    id: string
    customer_id: string
    internal_notes: string | null
    tags: string[]
    file_url: string | null
    file_name: string | null
    created_at: Date
    updated_at: Date
    _count: CustomerNotesAndAttachmentsCountAggregateOutputType | null
    _min: CustomerNotesAndAttachmentsMinAggregateOutputType | null
    _max: CustomerNotesAndAttachmentsMaxAggregateOutputType | null
  }

  type GetCustomerNotesAndAttachmentsGroupByPayload<T extends CustomerNotesAndAttachmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerNotesAndAttachmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerNotesAndAttachmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerNotesAndAttachmentsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerNotesAndAttachmentsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerNotesAndAttachmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    internal_notes?: boolean
    tags?: boolean
    file_url?: boolean
    file_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerNotesAndAttachments"]>

  export type CustomerNotesAndAttachmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    internal_notes?: boolean
    tags?: boolean
    file_url?: boolean
    file_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerNotesAndAttachments"]>

  export type CustomerNotesAndAttachmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    internal_notes?: boolean
    tags?: boolean
    file_url?: boolean
    file_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerNotesAndAttachments"]>

  export type CustomerNotesAndAttachmentsSelectScalar = {
    id?: boolean
    customer_id?: boolean
    internal_notes?: boolean
    tags?: boolean
    file_url?: boolean
    file_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomerNotesAndAttachmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "internal_notes" | "tags" | "file_url" | "file_name" | "created_at" | "updated_at", ExtArgs["result"]["customerNotesAndAttachments"]>
  export type CustomerNotesAndAttachmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerNotesAndAttachmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerNotesAndAttachmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerNotesAndAttachmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerNotesAndAttachments"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      internal_notes: string | null
      tags: string[]
      file_url: string | null
      file_name: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["customerNotesAndAttachments"]>
    composites: {}
  }

  type CustomerNotesAndAttachmentsGetPayload<S extends boolean | null | undefined | CustomerNotesAndAttachmentsDefaultArgs> = $Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload, S>

  type CustomerNotesAndAttachmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerNotesAndAttachmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerNotesAndAttachmentsCountAggregateInputType | true
    }

  export interface CustomerNotesAndAttachmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerNotesAndAttachments'], meta: { name: 'CustomerNotesAndAttachments' } }
    /**
     * Find zero or one CustomerNotesAndAttachments that matches the filter.
     * @param {CustomerNotesAndAttachmentsFindUniqueArgs} args - Arguments to find a CustomerNotesAndAttachments
     * @example
     * // Get one CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerNotesAndAttachmentsFindUniqueArgs>(args: SelectSubset<T, CustomerNotesAndAttachmentsFindUniqueArgs<ExtArgs>>): Prisma__CustomerNotesAndAttachmentsClient<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerNotesAndAttachments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerNotesAndAttachmentsFindUniqueOrThrowArgs} args - Arguments to find a CustomerNotesAndAttachments
     * @example
     * // Get one CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerNotesAndAttachmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerNotesAndAttachmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerNotesAndAttachmentsClient<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerNotesAndAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNotesAndAttachmentsFindFirstArgs} args - Arguments to find a CustomerNotesAndAttachments
     * @example
     * // Get one CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerNotesAndAttachmentsFindFirstArgs>(args?: SelectSubset<T, CustomerNotesAndAttachmentsFindFirstArgs<ExtArgs>>): Prisma__CustomerNotesAndAttachmentsClient<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerNotesAndAttachments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNotesAndAttachmentsFindFirstOrThrowArgs} args - Arguments to find a CustomerNotesAndAttachments
     * @example
     * // Get one CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerNotesAndAttachmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerNotesAndAttachmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerNotesAndAttachmentsClient<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerNotesAndAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNotesAndAttachmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.findMany()
     * 
     * // Get first 10 CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerNotesAndAttachmentsWithIdOnly = await prisma.customerNotesAndAttachments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerNotesAndAttachmentsFindManyArgs>(args?: SelectSubset<T, CustomerNotesAndAttachmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerNotesAndAttachments.
     * @param {CustomerNotesAndAttachmentsCreateArgs} args - Arguments to create a CustomerNotesAndAttachments.
     * @example
     * // Create one CustomerNotesAndAttachments
     * const CustomerNotesAndAttachments = await prisma.customerNotesAndAttachments.create({
     *   data: {
     *     // ... data to create a CustomerNotesAndAttachments
     *   }
     * })
     * 
     */
    create<T extends CustomerNotesAndAttachmentsCreateArgs>(args: SelectSubset<T, CustomerNotesAndAttachmentsCreateArgs<ExtArgs>>): Prisma__CustomerNotesAndAttachmentsClient<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerNotesAndAttachments.
     * @param {CustomerNotesAndAttachmentsCreateManyArgs} args - Arguments to create many CustomerNotesAndAttachments.
     * @example
     * // Create many CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerNotesAndAttachmentsCreateManyArgs>(args?: SelectSubset<T, CustomerNotesAndAttachmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerNotesAndAttachments and returns the data saved in the database.
     * @param {CustomerNotesAndAttachmentsCreateManyAndReturnArgs} args - Arguments to create many CustomerNotesAndAttachments.
     * @example
     * // Create many CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerNotesAndAttachments and only return the `id`
     * const customerNotesAndAttachmentsWithIdOnly = await prisma.customerNotesAndAttachments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerNotesAndAttachmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerNotesAndAttachmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerNotesAndAttachments.
     * @param {CustomerNotesAndAttachmentsDeleteArgs} args - Arguments to delete one CustomerNotesAndAttachments.
     * @example
     * // Delete one CustomerNotesAndAttachments
     * const CustomerNotesAndAttachments = await prisma.customerNotesAndAttachments.delete({
     *   where: {
     *     // ... filter to delete one CustomerNotesAndAttachments
     *   }
     * })
     * 
     */
    delete<T extends CustomerNotesAndAttachmentsDeleteArgs>(args: SelectSubset<T, CustomerNotesAndAttachmentsDeleteArgs<ExtArgs>>): Prisma__CustomerNotesAndAttachmentsClient<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerNotesAndAttachments.
     * @param {CustomerNotesAndAttachmentsUpdateArgs} args - Arguments to update one CustomerNotesAndAttachments.
     * @example
     * // Update one CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerNotesAndAttachmentsUpdateArgs>(args: SelectSubset<T, CustomerNotesAndAttachmentsUpdateArgs<ExtArgs>>): Prisma__CustomerNotesAndAttachmentsClient<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerNotesAndAttachments.
     * @param {CustomerNotesAndAttachmentsDeleteManyArgs} args - Arguments to filter CustomerNotesAndAttachments to delete.
     * @example
     * // Delete a few CustomerNotesAndAttachments
     * const { count } = await prisma.customerNotesAndAttachments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerNotesAndAttachmentsDeleteManyArgs>(args?: SelectSubset<T, CustomerNotesAndAttachmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerNotesAndAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNotesAndAttachmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerNotesAndAttachmentsUpdateManyArgs>(args: SelectSubset<T, CustomerNotesAndAttachmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerNotesAndAttachments and returns the data updated in the database.
     * @param {CustomerNotesAndAttachmentsUpdateManyAndReturnArgs} args - Arguments to update many CustomerNotesAndAttachments.
     * @example
     * // Update many CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerNotesAndAttachments and only return the `id`
     * const customerNotesAndAttachmentsWithIdOnly = await prisma.customerNotesAndAttachments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerNotesAndAttachmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerNotesAndAttachmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerNotesAndAttachments.
     * @param {CustomerNotesAndAttachmentsUpsertArgs} args - Arguments to update or create a CustomerNotesAndAttachments.
     * @example
     * // Update or create a CustomerNotesAndAttachments
     * const customerNotesAndAttachments = await prisma.customerNotesAndAttachments.upsert({
     *   create: {
     *     // ... data to create a CustomerNotesAndAttachments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerNotesAndAttachments we want to update
     *   }
     * })
     */
    upsert<T extends CustomerNotesAndAttachmentsUpsertArgs>(args: SelectSubset<T, CustomerNotesAndAttachmentsUpsertArgs<ExtArgs>>): Prisma__CustomerNotesAndAttachmentsClient<$Result.GetResult<Prisma.$CustomerNotesAndAttachmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerNotesAndAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNotesAndAttachmentsCountArgs} args - Arguments to filter CustomerNotesAndAttachments to count.
     * @example
     * // Count the number of CustomerNotesAndAttachments
     * const count = await prisma.customerNotesAndAttachments.count({
     *   where: {
     *     // ... the filter for the CustomerNotesAndAttachments we want to count
     *   }
     * })
    **/
    count<T extends CustomerNotesAndAttachmentsCountArgs>(
      args?: Subset<T, CustomerNotesAndAttachmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerNotesAndAttachmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerNotesAndAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNotesAndAttachmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerNotesAndAttachmentsAggregateArgs>(args: Subset<T, CustomerNotesAndAttachmentsAggregateArgs>): Prisma.PrismaPromise<GetCustomerNotesAndAttachmentsAggregateType<T>>

    /**
     * Group by CustomerNotesAndAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNotesAndAttachmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerNotesAndAttachmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerNotesAndAttachmentsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerNotesAndAttachmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerNotesAndAttachmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerNotesAndAttachmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerNotesAndAttachments model
   */
  readonly fields: CustomerNotesAndAttachmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerNotesAndAttachments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerNotesAndAttachmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerNotesAndAttachments model
   */
  interface CustomerNotesAndAttachmentsFieldRefs {
    readonly id: FieldRef<"CustomerNotesAndAttachments", 'String'>
    readonly customer_id: FieldRef<"CustomerNotesAndAttachments", 'String'>
    readonly internal_notes: FieldRef<"CustomerNotesAndAttachments", 'String'>
    readonly tags: FieldRef<"CustomerNotesAndAttachments", 'String[]'>
    readonly file_url: FieldRef<"CustomerNotesAndAttachments", 'String'>
    readonly file_name: FieldRef<"CustomerNotesAndAttachments", 'String'>
    readonly created_at: FieldRef<"CustomerNotesAndAttachments", 'DateTime'>
    readonly updated_at: FieldRef<"CustomerNotesAndAttachments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerNotesAndAttachments findUnique
   */
  export type CustomerNotesAndAttachmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNotesAndAttachments to fetch.
     */
    where: CustomerNotesAndAttachmentsWhereUniqueInput
  }

  /**
   * CustomerNotesAndAttachments findUniqueOrThrow
   */
  export type CustomerNotesAndAttachmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNotesAndAttachments to fetch.
     */
    where: CustomerNotesAndAttachmentsWhereUniqueInput
  }

  /**
   * CustomerNotesAndAttachments findFirst
   */
  export type CustomerNotesAndAttachmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNotesAndAttachments to fetch.
     */
    where?: CustomerNotesAndAttachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNotesAndAttachments to fetch.
     */
    orderBy?: CustomerNotesAndAttachmentsOrderByWithRelationInput | CustomerNotesAndAttachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerNotesAndAttachments.
     */
    cursor?: CustomerNotesAndAttachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNotesAndAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNotesAndAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerNotesAndAttachments.
     */
    distinct?: CustomerNotesAndAttachmentsScalarFieldEnum | CustomerNotesAndAttachmentsScalarFieldEnum[]
  }

  /**
   * CustomerNotesAndAttachments findFirstOrThrow
   */
  export type CustomerNotesAndAttachmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNotesAndAttachments to fetch.
     */
    where?: CustomerNotesAndAttachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNotesAndAttachments to fetch.
     */
    orderBy?: CustomerNotesAndAttachmentsOrderByWithRelationInput | CustomerNotesAndAttachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerNotesAndAttachments.
     */
    cursor?: CustomerNotesAndAttachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNotesAndAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNotesAndAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerNotesAndAttachments.
     */
    distinct?: CustomerNotesAndAttachmentsScalarFieldEnum | CustomerNotesAndAttachmentsScalarFieldEnum[]
  }

  /**
   * CustomerNotesAndAttachments findMany
   */
  export type CustomerNotesAndAttachmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNotesAndAttachments to fetch.
     */
    where?: CustomerNotesAndAttachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNotesAndAttachments to fetch.
     */
    orderBy?: CustomerNotesAndAttachmentsOrderByWithRelationInput | CustomerNotesAndAttachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerNotesAndAttachments.
     */
    cursor?: CustomerNotesAndAttachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNotesAndAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNotesAndAttachments.
     */
    skip?: number
    distinct?: CustomerNotesAndAttachmentsScalarFieldEnum | CustomerNotesAndAttachmentsScalarFieldEnum[]
  }

  /**
   * CustomerNotesAndAttachments create
   */
  export type CustomerNotesAndAttachmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerNotesAndAttachments.
     */
    data: XOR<CustomerNotesAndAttachmentsCreateInput, CustomerNotesAndAttachmentsUncheckedCreateInput>
  }

  /**
   * CustomerNotesAndAttachments createMany
   */
  export type CustomerNotesAndAttachmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerNotesAndAttachments.
     */
    data: CustomerNotesAndAttachmentsCreateManyInput | CustomerNotesAndAttachmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerNotesAndAttachments createManyAndReturn
   */
  export type CustomerNotesAndAttachmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerNotesAndAttachments.
     */
    data: CustomerNotesAndAttachmentsCreateManyInput | CustomerNotesAndAttachmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerNotesAndAttachments update
   */
  export type CustomerNotesAndAttachmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerNotesAndAttachments.
     */
    data: XOR<CustomerNotesAndAttachmentsUpdateInput, CustomerNotesAndAttachmentsUncheckedUpdateInput>
    /**
     * Choose, which CustomerNotesAndAttachments to update.
     */
    where: CustomerNotesAndAttachmentsWhereUniqueInput
  }

  /**
   * CustomerNotesAndAttachments updateMany
   */
  export type CustomerNotesAndAttachmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerNotesAndAttachments.
     */
    data: XOR<CustomerNotesAndAttachmentsUpdateManyMutationInput, CustomerNotesAndAttachmentsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerNotesAndAttachments to update
     */
    where?: CustomerNotesAndAttachmentsWhereInput
    /**
     * Limit how many CustomerNotesAndAttachments to update.
     */
    limit?: number
  }

  /**
   * CustomerNotesAndAttachments updateManyAndReturn
   */
  export type CustomerNotesAndAttachmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * The data used to update CustomerNotesAndAttachments.
     */
    data: XOR<CustomerNotesAndAttachmentsUpdateManyMutationInput, CustomerNotesAndAttachmentsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerNotesAndAttachments to update
     */
    where?: CustomerNotesAndAttachmentsWhereInput
    /**
     * Limit how many CustomerNotesAndAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerNotesAndAttachments upsert
   */
  export type CustomerNotesAndAttachmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerNotesAndAttachments to update in case it exists.
     */
    where: CustomerNotesAndAttachmentsWhereUniqueInput
    /**
     * In case the CustomerNotesAndAttachments found by the `where` argument doesn't exist, create a new CustomerNotesAndAttachments with this data.
     */
    create: XOR<CustomerNotesAndAttachmentsCreateInput, CustomerNotesAndAttachmentsUncheckedCreateInput>
    /**
     * In case the CustomerNotesAndAttachments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerNotesAndAttachmentsUpdateInput, CustomerNotesAndAttachmentsUncheckedUpdateInput>
  }

  /**
   * CustomerNotesAndAttachments delete
   */
  export type CustomerNotesAndAttachmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
    /**
     * Filter which CustomerNotesAndAttachments to delete.
     */
    where: CustomerNotesAndAttachmentsWhereUniqueInput
  }

  /**
   * CustomerNotesAndAttachments deleteMany
   */
  export type CustomerNotesAndAttachmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerNotesAndAttachments to delete
     */
    where?: CustomerNotesAndAttachmentsWhereInput
    /**
     * Limit how many CustomerNotesAndAttachments to delete.
     */
    limit?: number
  }

  /**
   * CustomerNotesAndAttachments without action
   */
  export type CustomerNotesAndAttachmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNotesAndAttachments
     */
    select?: CustomerNotesAndAttachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNotesAndAttachments
     */
    omit?: CustomerNotesAndAttachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNotesAndAttachmentsInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    vendor_id: number | null
  }

  export type VendorSumAggregateOutputType = {
    vendor_id: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    vendor_id: number | null
    first_name: string | null
    last_name: string | null
    vendor_name: string | null
    vendor_type: string | null
    email: string | null
    password: string | null
    phone: string | null
    website: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    user_id: string | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    vendor_id: number | null
    first_name: string | null
    last_name: string | null
    vendor_name: string | null
    vendor_type: string | null
    email: string | null
    password: string | null
    phone: string | null
    website: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    user_id: string | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    vendor_id: number
    first_name: number
    last_name: number
    vendor_name: number
    vendor_type: number
    email: number
    password: number
    phone: number
    website: number
    created_at: number
    updated_at: number
    deleted_at: number
    user_id: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    vendor_id?: true
  }

  export type VendorSumAggregateInputType = {
    vendor_id?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    vendor_id?: true
    first_name?: true
    last_name?: true
    vendor_name?: true
    vendor_type?: true
    email?: true
    password?: true
    phone?: true
    website?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    user_id?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    vendor_id?: true
    first_name?: true
    last_name?: true
    vendor_name?: true
    vendor_type?: true
    email?: true
    password?: true
    phone?: true
    website?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    user_id?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    vendor_id?: true
    first_name?: true
    last_name?: true
    vendor_name?: true
    vendor_type?: true
    email?: true
    password?: true
    phone?: true
    website?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    user_id?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    vendor_id: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type: string | null
    email: string | null
    password: string
    phone: string | null
    website: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    user_id: string | null
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    vendor_name?: boolean
    vendor_type?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_id?: boolean
    user?: boolean | Vendor$userArgs<ExtArgs>
    contacts?: boolean | Vendor$contactsArgs<ExtArgs>
    addresses?: boolean | Vendor$addressesArgs<ExtArgs>
    taxCompliances?: boolean | Vendor$taxCompliancesArgs<ExtArgs>
    financials?: boolean | Vendor$financialsArgs<ExtArgs>
    operationalSetting?: boolean | Vendor$operationalSettingArgs<ExtArgs>
    metadata?: boolean | Vendor$metadataArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    vendor_name?: boolean
    vendor_type?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_id?: boolean
    user?: boolean | Vendor$userArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    vendor_name?: boolean
    vendor_type?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_id?: boolean
    user?: boolean | Vendor$userArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    vendor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    vendor_name?: boolean
    vendor_type?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_id?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_id" | "first_name" | "last_name" | "vendor_name" | "vendor_type" | "email" | "password" | "phone" | "website" | "created_at" | "updated_at" | "deleted_at" | "user_id", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Vendor$userArgs<ExtArgs>
    contacts?: boolean | Vendor$contactsArgs<ExtArgs>
    addresses?: boolean | Vendor$addressesArgs<ExtArgs>
    taxCompliances?: boolean | Vendor$taxCompliancesArgs<ExtArgs>
    financials?: boolean | Vendor$financialsArgs<ExtArgs>
    operationalSetting?: boolean | Vendor$operationalSettingArgs<ExtArgs>
    metadata?: boolean | Vendor$metadataArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Vendor$userArgs<ExtArgs>
  }
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Vendor$userArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      contacts: Prisma.$VendorContactPayload<ExtArgs> | null
      addresses: Prisma.$VendorAddressPayload<ExtArgs> | null
      taxCompliances: Prisma.$VendorTaxCompliancePayload<ExtArgs> | null
      financials: Prisma.$VendorFinancialPayload<ExtArgs> | null
      operationalSetting: Prisma.$VendorOperationalSettingPayload<ExtArgs> | null
      metadata: Prisma.$VendorMetadataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_id: number
      first_name: string
      last_name: string
      vendor_name: string
      vendor_type: string | null
      email: string | null
      password: string
      phone: string | null
      website: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      user_id: string | null
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Vendor$userArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contacts<T extends Vendor$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$contactsArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    addresses<T extends Vendor$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$addressesArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    taxCompliances<T extends Vendor$taxCompliancesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$taxCompliancesArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    financials<T extends Vendor$financialsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$financialsArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    operationalSetting<T extends Vendor$operationalSettingArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$operationalSettingArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    metadata<T extends Vendor$metadataArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$metadataArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly vendor_id: FieldRef<"Vendor", 'Int'>
    readonly first_name: FieldRef<"Vendor", 'String'>
    readonly last_name: FieldRef<"Vendor", 'String'>
    readonly vendor_name: FieldRef<"Vendor", 'String'>
    readonly vendor_type: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly password: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly website: FieldRef<"Vendor", 'String'>
    readonly created_at: FieldRef<"Vendor", 'DateTime'>
    readonly updated_at: FieldRef<"Vendor", 'DateTime'>
    readonly deleted_at: FieldRef<"Vendor", 'DateTime'>
    readonly user_id: FieldRef<"Vendor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.user
   */
  export type Vendor$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Vendor.contacts
   */
  export type Vendor$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    where?: VendorContactWhereInput
  }

  /**
   * Vendor.addresses
   */
  export type Vendor$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    where?: VendorAddressWhereInput
  }

  /**
   * Vendor.taxCompliances
   */
  export type Vendor$taxCompliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    where?: VendorTaxComplianceWhereInput
  }

  /**
   * Vendor.financials
   */
  export type Vendor$financialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    where?: VendorFinancialWhereInput
  }

  /**
   * Vendor.operationalSetting
   */
  export type Vendor$operationalSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    where?: VendorOperationalSettingWhereInput
  }

  /**
   * Vendor.metadata
   */
  export type Vendor$metadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    where?: VendorMetadataWhereInput
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model VendorContact
   */

  export type AggregateVendorContact = {
    _count: VendorContactCountAggregateOutputType | null
    _min: VendorContactMinAggregateOutputType | null
    _max: VendorContactMaxAggregateOutputType | null
  }

  export type VendorContactMinAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    contact_name: string | null
    job_title: string | null
    email: string | null
    phone: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorContactMaxAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    contact_name: string | null
    job_title: string | null
    email: string | null
    phone: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorContactCountAggregateOutputType = {
    id: number
    vendor_id: number
    contact_name: number
    job_title: number
    email: number
    phone: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorContactMinAggregateInputType = {
    id?: true
    vendor_id?: true
    contact_name?: true
    job_title?: true
    email?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorContactMaxAggregateInputType = {
    id?: true
    vendor_id?: true
    contact_name?: true
    job_title?: true
    email?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorContactCountAggregateInputType = {
    id?: true
    vendor_id?: true
    contact_name?: true
    job_title?: true
    email?: true
    phone?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorContact to aggregate.
     */
    where?: VendorContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorContacts to fetch.
     */
    orderBy?: VendorContactOrderByWithRelationInput | VendorContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorContacts
    **/
    _count?: true | VendorContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorContactMaxAggregateInputType
  }

  export type GetVendorContactAggregateType<T extends VendorContactAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorContact[P]>
      : GetScalarType<T[P], AggregateVendorContact[P]>
  }




  export type VendorContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorContactWhereInput
    orderBy?: VendorContactOrderByWithAggregationInput | VendorContactOrderByWithAggregationInput[]
    by: VendorContactScalarFieldEnum[] | VendorContactScalarFieldEnum
    having?: VendorContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorContactCountAggregateInputType | true
    _min?: VendorContactMinAggregateInputType
    _max?: VendorContactMaxAggregateInputType
  }

  export type VendorContactGroupByOutputType = {
    id: string
    vendor_id: string
    contact_name: string
    job_title: string | null
    email: string | null
    phone: string | null
    created_at: Date
    updated_at: Date
    _count: VendorContactCountAggregateOutputType | null
    _min: VendorContactMinAggregateOutputType | null
    _max: VendorContactMaxAggregateOutputType | null
  }

  type GetVendorContactGroupByPayload<T extends VendorContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorContactGroupByOutputType[P]>
            : GetScalarType<T[P], VendorContactGroupByOutputType[P]>
        }
      >
    >


  export type VendorContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    contact_name?: boolean
    job_title?: boolean
    email?: boolean
    phone?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorContact"]>

  export type VendorContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    contact_name?: boolean
    job_title?: boolean
    email?: boolean
    phone?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorContact"]>

  export type VendorContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    contact_name?: boolean
    job_title?: boolean
    email?: boolean
    phone?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorContact"]>

  export type VendorContactSelectScalar = {
    id?: boolean
    vendor_id?: boolean
    contact_name?: boolean
    job_title?: boolean
    email?: boolean
    phone?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_id" | "contact_name" | "job_title" | "email" | "phone" | "created_at" | "updated_at", ExtArgs["result"]["vendorContact"]>
  export type VendorContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorContact"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_id: string
      contact_name: string
      job_title: string | null
      email: string | null
      phone: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendorContact"]>
    composites: {}
  }

  type VendorContactGetPayload<S extends boolean | null | undefined | VendorContactDefaultArgs> = $Result.GetResult<Prisma.$VendorContactPayload, S>

  type VendorContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorContactCountAggregateInputType | true
    }

  export interface VendorContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorContact'], meta: { name: 'VendorContact' } }
    /**
     * Find zero or one VendorContact that matches the filter.
     * @param {VendorContactFindUniqueArgs} args - Arguments to find a VendorContact
     * @example
     * // Get one VendorContact
     * const vendorContact = await prisma.vendorContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorContactFindUniqueArgs>(args: SelectSubset<T, VendorContactFindUniqueArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorContactFindUniqueOrThrowArgs} args - Arguments to find a VendorContact
     * @example
     * // Get one VendorContact
     * const vendorContact = await prisma.vendorContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorContactFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorContactFindFirstArgs} args - Arguments to find a VendorContact
     * @example
     * // Get one VendorContact
     * const vendorContact = await prisma.vendorContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorContactFindFirstArgs>(args?: SelectSubset<T, VendorContactFindFirstArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorContactFindFirstOrThrowArgs} args - Arguments to find a VendorContact
     * @example
     * // Get one VendorContact
     * const vendorContact = await prisma.vendorContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorContactFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorContacts
     * const vendorContacts = await prisma.vendorContact.findMany()
     * 
     * // Get first 10 VendorContacts
     * const vendorContacts = await prisma.vendorContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorContactWithIdOnly = await prisma.vendorContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorContactFindManyArgs>(args?: SelectSubset<T, VendorContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorContact.
     * @param {VendorContactCreateArgs} args - Arguments to create a VendorContact.
     * @example
     * // Create one VendorContact
     * const VendorContact = await prisma.vendorContact.create({
     *   data: {
     *     // ... data to create a VendorContact
     *   }
     * })
     * 
     */
    create<T extends VendorContactCreateArgs>(args: SelectSubset<T, VendorContactCreateArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorContacts.
     * @param {VendorContactCreateManyArgs} args - Arguments to create many VendorContacts.
     * @example
     * // Create many VendorContacts
     * const vendorContact = await prisma.vendorContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorContactCreateManyArgs>(args?: SelectSubset<T, VendorContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorContacts and returns the data saved in the database.
     * @param {VendorContactCreateManyAndReturnArgs} args - Arguments to create many VendorContacts.
     * @example
     * // Create many VendorContacts
     * const vendorContact = await prisma.vendorContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorContacts and only return the `id`
     * const vendorContactWithIdOnly = await prisma.vendorContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorContactCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorContact.
     * @param {VendorContactDeleteArgs} args - Arguments to delete one VendorContact.
     * @example
     * // Delete one VendorContact
     * const VendorContact = await prisma.vendorContact.delete({
     *   where: {
     *     // ... filter to delete one VendorContact
     *   }
     * })
     * 
     */
    delete<T extends VendorContactDeleteArgs>(args: SelectSubset<T, VendorContactDeleteArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorContact.
     * @param {VendorContactUpdateArgs} args - Arguments to update one VendorContact.
     * @example
     * // Update one VendorContact
     * const vendorContact = await prisma.vendorContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorContactUpdateArgs>(args: SelectSubset<T, VendorContactUpdateArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorContacts.
     * @param {VendorContactDeleteManyArgs} args - Arguments to filter VendorContacts to delete.
     * @example
     * // Delete a few VendorContacts
     * const { count } = await prisma.vendorContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorContactDeleteManyArgs>(args?: SelectSubset<T, VendorContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorContacts
     * const vendorContact = await prisma.vendorContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorContactUpdateManyArgs>(args: SelectSubset<T, VendorContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorContacts and returns the data updated in the database.
     * @param {VendorContactUpdateManyAndReturnArgs} args - Arguments to update many VendorContacts.
     * @example
     * // Update many VendorContacts
     * const vendorContact = await prisma.vendorContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorContacts and only return the `id`
     * const vendorContactWithIdOnly = await prisma.vendorContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorContactUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorContact.
     * @param {VendorContactUpsertArgs} args - Arguments to update or create a VendorContact.
     * @example
     * // Update or create a VendorContact
     * const vendorContact = await prisma.vendorContact.upsert({
     *   create: {
     *     // ... data to create a VendorContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorContact we want to update
     *   }
     * })
     */
    upsert<T extends VendorContactUpsertArgs>(args: SelectSubset<T, VendorContactUpsertArgs<ExtArgs>>): Prisma__VendorContactClient<$Result.GetResult<Prisma.$VendorContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorContactCountArgs} args - Arguments to filter VendorContacts to count.
     * @example
     * // Count the number of VendorContacts
     * const count = await prisma.vendorContact.count({
     *   where: {
     *     // ... the filter for the VendorContacts we want to count
     *   }
     * })
    **/
    count<T extends VendorContactCountArgs>(
      args?: Subset<T, VendorContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorContactAggregateArgs>(args: Subset<T, VendorContactAggregateArgs>): Prisma.PrismaPromise<GetVendorContactAggregateType<T>>

    /**
     * Group by VendorContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorContactGroupByArgs['orderBy'] }
        : { orderBy?: VendorContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorContact model
   */
  readonly fields: VendorContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorContact model
   */
  interface VendorContactFieldRefs {
    readonly id: FieldRef<"VendorContact", 'String'>
    readonly vendor_id: FieldRef<"VendorContact", 'String'>
    readonly contact_name: FieldRef<"VendorContact", 'String'>
    readonly job_title: FieldRef<"VendorContact", 'String'>
    readonly email: FieldRef<"VendorContact", 'String'>
    readonly phone: FieldRef<"VendorContact", 'String'>
    readonly created_at: FieldRef<"VendorContact", 'DateTime'>
    readonly updated_at: FieldRef<"VendorContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorContact findUnique
   */
  export type VendorContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * Filter, which VendorContact to fetch.
     */
    where: VendorContactWhereUniqueInput
  }

  /**
   * VendorContact findUniqueOrThrow
   */
  export type VendorContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * Filter, which VendorContact to fetch.
     */
    where: VendorContactWhereUniqueInput
  }

  /**
   * VendorContact findFirst
   */
  export type VendorContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * Filter, which VendorContact to fetch.
     */
    where?: VendorContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorContacts to fetch.
     */
    orderBy?: VendorContactOrderByWithRelationInput | VendorContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorContacts.
     */
    cursor?: VendorContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorContacts.
     */
    distinct?: VendorContactScalarFieldEnum | VendorContactScalarFieldEnum[]
  }

  /**
   * VendorContact findFirstOrThrow
   */
  export type VendorContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * Filter, which VendorContact to fetch.
     */
    where?: VendorContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorContacts to fetch.
     */
    orderBy?: VendorContactOrderByWithRelationInput | VendorContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorContacts.
     */
    cursor?: VendorContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorContacts.
     */
    distinct?: VendorContactScalarFieldEnum | VendorContactScalarFieldEnum[]
  }

  /**
   * VendorContact findMany
   */
  export type VendorContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * Filter, which VendorContacts to fetch.
     */
    where?: VendorContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorContacts to fetch.
     */
    orderBy?: VendorContactOrderByWithRelationInput | VendorContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorContacts.
     */
    cursor?: VendorContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorContacts.
     */
    skip?: number
    distinct?: VendorContactScalarFieldEnum | VendorContactScalarFieldEnum[]
  }

  /**
   * VendorContact create
   */
  export type VendorContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorContact.
     */
    data: XOR<VendorContactCreateInput, VendorContactUncheckedCreateInput>
  }

  /**
   * VendorContact createMany
   */
  export type VendorContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorContacts.
     */
    data: VendorContactCreateManyInput | VendorContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorContact createManyAndReturn
   */
  export type VendorContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * The data used to create many VendorContacts.
     */
    data: VendorContactCreateManyInput | VendorContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorContact update
   */
  export type VendorContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorContact.
     */
    data: XOR<VendorContactUpdateInput, VendorContactUncheckedUpdateInput>
    /**
     * Choose, which VendorContact to update.
     */
    where: VendorContactWhereUniqueInput
  }

  /**
   * VendorContact updateMany
   */
  export type VendorContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorContacts.
     */
    data: XOR<VendorContactUpdateManyMutationInput, VendorContactUncheckedUpdateManyInput>
    /**
     * Filter which VendorContacts to update
     */
    where?: VendorContactWhereInput
    /**
     * Limit how many VendorContacts to update.
     */
    limit?: number
  }

  /**
   * VendorContact updateManyAndReturn
   */
  export type VendorContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * The data used to update VendorContacts.
     */
    data: XOR<VendorContactUpdateManyMutationInput, VendorContactUncheckedUpdateManyInput>
    /**
     * Filter which VendorContacts to update
     */
    where?: VendorContactWhereInput
    /**
     * Limit how many VendorContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorContact upsert
   */
  export type VendorContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorContact to update in case it exists.
     */
    where: VendorContactWhereUniqueInput
    /**
     * In case the VendorContact found by the `where` argument doesn't exist, create a new VendorContact with this data.
     */
    create: XOR<VendorContactCreateInput, VendorContactUncheckedCreateInput>
    /**
     * In case the VendorContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorContactUpdateInput, VendorContactUncheckedUpdateInput>
  }

  /**
   * VendorContact delete
   */
  export type VendorContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
    /**
     * Filter which VendorContact to delete.
     */
    where: VendorContactWhereUniqueInput
  }

  /**
   * VendorContact deleteMany
   */
  export type VendorContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorContacts to delete
     */
    where?: VendorContactWhereInput
    /**
     * Limit how many VendorContacts to delete.
     */
    limit?: number
  }

  /**
   * VendorContact without action
   */
  export type VendorContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorContact
     */
    select?: VendorContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorContact
     */
    omit?: VendorContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorContactInclude<ExtArgs> | null
  }


  /**
   * Model VendorAddress
   */

  export type AggregateVendorAddress = {
    _count: VendorAddressCountAggregateOutputType | null
    _min: VendorAddressMinAggregateOutputType | null
    _max: VendorAddressMaxAggregateOutputType | null
  }

  export type VendorAddressMinAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    address_1: string | null
    address_2: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorAddressMaxAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    address_1: string | null
    address_2: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorAddressCountAggregateOutputType = {
    id: number
    vendor_id: number
    address_1: number
    address_2: number
    city: number
    state: number
    zip: number
    country: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorAddressMinAggregateInputType = {
    id?: true
    vendor_id?: true
    address_1?: true
    address_2?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorAddressMaxAggregateInputType = {
    id?: true
    vendor_id?: true
    address_1?: true
    address_2?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorAddressCountAggregateInputType = {
    id?: true
    vendor_id?: true
    address_1?: true
    address_2?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorAddress to aggregate.
     */
    where?: VendorAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAddresses to fetch.
     */
    orderBy?: VendorAddressOrderByWithRelationInput | VendorAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorAddresses
    **/
    _count?: true | VendorAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorAddressMaxAggregateInputType
  }

  export type GetVendorAddressAggregateType<T extends VendorAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorAddress[P]>
      : GetScalarType<T[P], AggregateVendorAddress[P]>
  }




  export type VendorAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorAddressWhereInput
    orderBy?: VendorAddressOrderByWithAggregationInput | VendorAddressOrderByWithAggregationInput[]
    by: VendorAddressScalarFieldEnum[] | VendorAddressScalarFieldEnum
    having?: VendorAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorAddressCountAggregateInputType | true
    _min?: VendorAddressMinAggregateInputType
    _max?: VendorAddressMaxAggregateInputType
  }

  export type VendorAddressGroupByOutputType = {
    id: string
    vendor_id: string
    address_1: string
    address_2: string | null
    city: string
    state: string
    zip: string
    country: string
    created_at: Date
    updated_at: Date
    _count: VendorAddressCountAggregateOutputType | null
    _min: VendorAddressMinAggregateOutputType | null
    _max: VendorAddressMaxAggregateOutputType | null
  }

  type GetVendorAddressGroupByPayload<T extends VendorAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorAddressGroupByOutputType[P]>
            : GetScalarType<T[P], VendorAddressGroupByOutputType[P]>
        }
      >
    >


  export type VendorAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    address_1?: boolean
    address_2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorAddress"]>

  export type VendorAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    address_1?: boolean
    address_2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorAddress"]>

  export type VendorAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    address_1?: boolean
    address_2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorAddress"]>

  export type VendorAddressSelectScalar = {
    id?: boolean
    vendor_id?: boolean
    address_1?: boolean
    address_2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_id" | "address_1" | "address_2" | "city" | "state" | "zip" | "country" | "created_at" | "updated_at", ExtArgs["result"]["vendorAddress"]>
  export type VendorAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorAddress"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_id: string
      address_1: string
      address_2: string | null
      city: string
      state: string
      zip: string
      country: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendorAddress"]>
    composites: {}
  }

  type VendorAddressGetPayload<S extends boolean | null | undefined | VendorAddressDefaultArgs> = $Result.GetResult<Prisma.$VendorAddressPayload, S>

  type VendorAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorAddressCountAggregateInputType | true
    }

  export interface VendorAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorAddress'], meta: { name: 'VendorAddress' } }
    /**
     * Find zero or one VendorAddress that matches the filter.
     * @param {VendorAddressFindUniqueArgs} args - Arguments to find a VendorAddress
     * @example
     * // Get one VendorAddress
     * const vendorAddress = await prisma.vendorAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorAddressFindUniqueArgs>(args: SelectSubset<T, VendorAddressFindUniqueArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorAddressFindUniqueOrThrowArgs} args - Arguments to find a VendorAddress
     * @example
     * // Get one VendorAddress
     * const vendorAddress = await prisma.vendorAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAddressFindFirstArgs} args - Arguments to find a VendorAddress
     * @example
     * // Get one VendorAddress
     * const vendorAddress = await prisma.vendorAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorAddressFindFirstArgs>(args?: SelectSubset<T, VendorAddressFindFirstArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAddressFindFirstOrThrowArgs} args - Arguments to find a VendorAddress
     * @example
     * // Get one VendorAddress
     * const vendorAddress = await prisma.vendorAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorAddresses
     * const vendorAddresses = await prisma.vendorAddress.findMany()
     * 
     * // Get first 10 VendorAddresses
     * const vendorAddresses = await prisma.vendorAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorAddressWithIdOnly = await prisma.vendorAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorAddressFindManyArgs>(args?: SelectSubset<T, VendorAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorAddress.
     * @param {VendorAddressCreateArgs} args - Arguments to create a VendorAddress.
     * @example
     * // Create one VendorAddress
     * const VendorAddress = await prisma.vendorAddress.create({
     *   data: {
     *     // ... data to create a VendorAddress
     *   }
     * })
     * 
     */
    create<T extends VendorAddressCreateArgs>(args: SelectSubset<T, VendorAddressCreateArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorAddresses.
     * @param {VendorAddressCreateManyArgs} args - Arguments to create many VendorAddresses.
     * @example
     * // Create many VendorAddresses
     * const vendorAddress = await prisma.vendorAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorAddressCreateManyArgs>(args?: SelectSubset<T, VendorAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorAddresses and returns the data saved in the database.
     * @param {VendorAddressCreateManyAndReturnArgs} args - Arguments to create many VendorAddresses.
     * @example
     * // Create many VendorAddresses
     * const vendorAddress = await prisma.vendorAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorAddresses and only return the `id`
     * const vendorAddressWithIdOnly = await prisma.vendorAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorAddress.
     * @param {VendorAddressDeleteArgs} args - Arguments to delete one VendorAddress.
     * @example
     * // Delete one VendorAddress
     * const VendorAddress = await prisma.vendorAddress.delete({
     *   where: {
     *     // ... filter to delete one VendorAddress
     *   }
     * })
     * 
     */
    delete<T extends VendorAddressDeleteArgs>(args: SelectSubset<T, VendorAddressDeleteArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorAddress.
     * @param {VendorAddressUpdateArgs} args - Arguments to update one VendorAddress.
     * @example
     * // Update one VendorAddress
     * const vendorAddress = await prisma.vendorAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorAddressUpdateArgs>(args: SelectSubset<T, VendorAddressUpdateArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorAddresses.
     * @param {VendorAddressDeleteManyArgs} args - Arguments to filter VendorAddresses to delete.
     * @example
     * // Delete a few VendorAddresses
     * const { count } = await prisma.vendorAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorAddressDeleteManyArgs>(args?: SelectSubset<T, VendorAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorAddresses
     * const vendorAddress = await prisma.vendorAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorAddressUpdateManyArgs>(args: SelectSubset<T, VendorAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorAddresses and returns the data updated in the database.
     * @param {VendorAddressUpdateManyAndReturnArgs} args - Arguments to update many VendorAddresses.
     * @example
     * // Update many VendorAddresses
     * const vendorAddress = await prisma.vendorAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorAddresses and only return the `id`
     * const vendorAddressWithIdOnly = await prisma.vendorAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorAddress.
     * @param {VendorAddressUpsertArgs} args - Arguments to update or create a VendorAddress.
     * @example
     * // Update or create a VendorAddress
     * const vendorAddress = await prisma.vendorAddress.upsert({
     *   create: {
     *     // ... data to create a VendorAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorAddress we want to update
     *   }
     * })
     */
    upsert<T extends VendorAddressUpsertArgs>(args: SelectSubset<T, VendorAddressUpsertArgs<ExtArgs>>): Prisma__VendorAddressClient<$Result.GetResult<Prisma.$VendorAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAddressCountArgs} args - Arguments to filter VendorAddresses to count.
     * @example
     * // Count the number of VendorAddresses
     * const count = await prisma.vendorAddress.count({
     *   where: {
     *     // ... the filter for the VendorAddresses we want to count
     *   }
     * })
    **/
    count<T extends VendorAddressCountArgs>(
      args?: Subset<T, VendorAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAddressAggregateArgs>(args: Subset<T, VendorAddressAggregateArgs>): Prisma.PrismaPromise<GetVendorAddressAggregateType<T>>

    /**
     * Group by VendorAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorAddressGroupByArgs['orderBy'] }
        : { orderBy?: VendorAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorAddress model
   */
  readonly fields: VendorAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorAddress model
   */
  interface VendorAddressFieldRefs {
    readonly id: FieldRef<"VendorAddress", 'String'>
    readonly vendor_id: FieldRef<"VendorAddress", 'String'>
    readonly address_1: FieldRef<"VendorAddress", 'String'>
    readonly address_2: FieldRef<"VendorAddress", 'String'>
    readonly city: FieldRef<"VendorAddress", 'String'>
    readonly state: FieldRef<"VendorAddress", 'String'>
    readonly zip: FieldRef<"VendorAddress", 'String'>
    readonly country: FieldRef<"VendorAddress", 'String'>
    readonly created_at: FieldRef<"VendorAddress", 'DateTime'>
    readonly updated_at: FieldRef<"VendorAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorAddress findUnique
   */
  export type VendorAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * Filter, which VendorAddress to fetch.
     */
    where: VendorAddressWhereUniqueInput
  }

  /**
   * VendorAddress findUniqueOrThrow
   */
  export type VendorAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * Filter, which VendorAddress to fetch.
     */
    where: VendorAddressWhereUniqueInput
  }

  /**
   * VendorAddress findFirst
   */
  export type VendorAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * Filter, which VendorAddress to fetch.
     */
    where?: VendorAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAddresses to fetch.
     */
    orderBy?: VendorAddressOrderByWithRelationInput | VendorAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorAddresses.
     */
    cursor?: VendorAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorAddresses.
     */
    distinct?: VendorAddressScalarFieldEnum | VendorAddressScalarFieldEnum[]
  }

  /**
   * VendorAddress findFirstOrThrow
   */
  export type VendorAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * Filter, which VendorAddress to fetch.
     */
    where?: VendorAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAddresses to fetch.
     */
    orderBy?: VendorAddressOrderByWithRelationInput | VendorAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorAddresses.
     */
    cursor?: VendorAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorAddresses.
     */
    distinct?: VendorAddressScalarFieldEnum | VendorAddressScalarFieldEnum[]
  }

  /**
   * VendorAddress findMany
   */
  export type VendorAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * Filter, which VendorAddresses to fetch.
     */
    where?: VendorAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAddresses to fetch.
     */
    orderBy?: VendorAddressOrderByWithRelationInput | VendorAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorAddresses.
     */
    cursor?: VendorAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAddresses.
     */
    skip?: number
    distinct?: VendorAddressScalarFieldEnum | VendorAddressScalarFieldEnum[]
  }

  /**
   * VendorAddress create
   */
  export type VendorAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorAddress.
     */
    data: XOR<VendorAddressCreateInput, VendorAddressUncheckedCreateInput>
  }

  /**
   * VendorAddress createMany
   */
  export type VendorAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorAddresses.
     */
    data: VendorAddressCreateManyInput | VendorAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorAddress createManyAndReturn
   */
  export type VendorAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * The data used to create many VendorAddresses.
     */
    data: VendorAddressCreateManyInput | VendorAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorAddress update
   */
  export type VendorAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorAddress.
     */
    data: XOR<VendorAddressUpdateInput, VendorAddressUncheckedUpdateInput>
    /**
     * Choose, which VendorAddress to update.
     */
    where: VendorAddressWhereUniqueInput
  }

  /**
   * VendorAddress updateMany
   */
  export type VendorAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorAddresses.
     */
    data: XOR<VendorAddressUpdateManyMutationInput, VendorAddressUncheckedUpdateManyInput>
    /**
     * Filter which VendorAddresses to update
     */
    where?: VendorAddressWhereInput
    /**
     * Limit how many VendorAddresses to update.
     */
    limit?: number
  }

  /**
   * VendorAddress updateManyAndReturn
   */
  export type VendorAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * The data used to update VendorAddresses.
     */
    data: XOR<VendorAddressUpdateManyMutationInput, VendorAddressUncheckedUpdateManyInput>
    /**
     * Filter which VendorAddresses to update
     */
    where?: VendorAddressWhereInput
    /**
     * Limit how many VendorAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorAddress upsert
   */
  export type VendorAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorAddress to update in case it exists.
     */
    where: VendorAddressWhereUniqueInput
    /**
     * In case the VendorAddress found by the `where` argument doesn't exist, create a new VendorAddress with this data.
     */
    create: XOR<VendorAddressCreateInput, VendorAddressUncheckedCreateInput>
    /**
     * In case the VendorAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorAddressUpdateInput, VendorAddressUncheckedUpdateInput>
  }

  /**
   * VendorAddress delete
   */
  export type VendorAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
    /**
     * Filter which VendorAddress to delete.
     */
    where: VendorAddressWhereUniqueInput
  }

  /**
   * VendorAddress deleteMany
   */
  export type VendorAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorAddresses to delete
     */
    where?: VendorAddressWhereInput
    /**
     * Limit how many VendorAddresses to delete.
     */
    limit?: number
  }

  /**
   * VendorAddress without action
   */
  export type VendorAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAddress
     */
    select?: VendorAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAddress
     */
    omit?: VendorAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAddressInclude<ExtArgs> | null
  }


  /**
   * Model VendorTaxCompliance
   */

  export type AggregateVendorTaxCompliance = {
    _count: VendorTaxComplianceCountAggregateOutputType | null
    _min: VendorTaxComplianceMinAggregateOutputType | null
    _max: VendorTaxComplianceMaxAggregateOutputType | null
  }

  export type VendorTaxComplianceMinAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    tax_number: string | null
    vat_number: string | null
    company_number: string | null
    compliance_type: string | null
    file_name: string | null
    file_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorTaxComplianceMaxAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    tax_number: string | null
    vat_number: string | null
    company_number: string | null
    compliance_type: string | null
    file_name: string | null
    file_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorTaxComplianceCountAggregateOutputType = {
    id: number
    vendor_id: number
    tax_number: number
    vat_number: number
    company_number: number
    compliance_type: number
    file_name: number
    file_url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorTaxComplianceMinAggregateInputType = {
    id?: true
    vendor_id?: true
    tax_number?: true
    vat_number?: true
    company_number?: true
    compliance_type?: true
    file_name?: true
    file_url?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorTaxComplianceMaxAggregateInputType = {
    id?: true
    vendor_id?: true
    tax_number?: true
    vat_number?: true
    company_number?: true
    compliance_type?: true
    file_name?: true
    file_url?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorTaxComplianceCountAggregateInputType = {
    id?: true
    vendor_id?: true
    tax_number?: true
    vat_number?: true
    company_number?: true
    compliance_type?: true
    file_name?: true
    file_url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorTaxComplianceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorTaxCompliance to aggregate.
     */
    where?: VendorTaxComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorTaxCompliances to fetch.
     */
    orderBy?: VendorTaxComplianceOrderByWithRelationInput | VendorTaxComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorTaxComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorTaxCompliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorTaxCompliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorTaxCompliances
    **/
    _count?: true | VendorTaxComplianceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorTaxComplianceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorTaxComplianceMaxAggregateInputType
  }

  export type GetVendorTaxComplianceAggregateType<T extends VendorTaxComplianceAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorTaxCompliance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorTaxCompliance[P]>
      : GetScalarType<T[P], AggregateVendorTaxCompliance[P]>
  }




  export type VendorTaxComplianceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorTaxComplianceWhereInput
    orderBy?: VendorTaxComplianceOrderByWithAggregationInput | VendorTaxComplianceOrderByWithAggregationInput[]
    by: VendorTaxComplianceScalarFieldEnum[] | VendorTaxComplianceScalarFieldEnum
    having?: VendorTaxComplianceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorTaxComplianceCountAggregateInputType | true
    _min?: VendorTaxComplianceMinAggregateInputType
    _max?: VendorTaxComplianceMaxAggregateInputType
  }

  export type VendorTaxComplianceGroupByOutputType = {
    id: string
    vendor_id: string
    tax_number: string | null
    vat_number: string | null
    company_number: string | null
    compliance_type: string | null
    file_name: string | null
    file_url: string | null
    created_at: Date
    updated_at: Date
    _count: VendorTaxComplianceCountAggregateOutputType | null
    _min: VendorTaxComplianceMinAggregateOutputType | null
    _max: VendorTaxComplianceMaxAggregateOutputType | null
  }

  type GetVendorTaxComplianceGroupByPayload<T extends VendorTaxComplianceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorTaxComplianceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorTaxComplianceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorTaxComplianceGroupByOutputType[P]>
            : GetScalarType<T[P], VendorTaxComplianceGroupByOutputType[P]>
        }
      >
    >


  export type VendorTaxComplianceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    tax_number?: boolean
    vat_number?: boolean
    company_number?: boolean
    compliance_type?: boolean
    file_name?: boolean
    file_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorTaxCompliance"]>

  export type VendorTaxComplianceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    tax_number?: boolean
    vat_number?: boolean
    company_number?: boolean
    compliance_type?: boolean
    file_name?: boolean
    file_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorTaxCompliance"]>

  export type VendorTaxComplianceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    tax_number?: boolean
    vat_number?: boolean
    company_number?: boolean
    compliance_type?: boolean
    file_name?: boolean
    file_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorTaxCompliance"]>

  export type VendorTaxComplianceSelectScalar = {
    id?: boolean
    vendor_id?: boolean
    tax_number?: boolean
    vat_number?: boolean
    company_number?: boolean
    compliance_type?: boolean
    file_name?: boolean
    file_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorTaxComplianceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_id" | "tax_number" | "vat_number" | "company_number" | "compliance_type" | "file_name" | "file_url" | "created_at" | "updated_at", ExtArgs["result"]["vendorTaxCompliance"]>
  export type VendorTaxComplianceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorTaxComplianceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorTaxComplianceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorTaxCompliancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorTaxCompliance"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_id: string
      tax_number: string | null
      vat_number: string | null
      company_number: string | null
      compliance_type: string | null
      file_name: string | null
      file_url: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendorTaxCompliance"]>
    composites: {}
  }

  type VendorTaxComplianceGetPayload<S extends boolean | null | undefined | VendorTaxComplianceDefaultArgs> = $Result.GetResult<Prisma.$VendorTaxCompliancePayload, S>

  type VendorTaxComplianceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorTaxComplianceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorTaxComplianceCountAggregateInputType | true
    }

  export interface VendorTaxComplianceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorTaxCompliance'], meta: { name: 'VendorTaxCompliance' } }
    /**
     * Find zero or one VendorTaxCompliance that matches the filter.
     * @param {VendorTaxComplianceFindUniqueArgs} args - Arguments to find a VendorTaxCompliance
     * @example
     * // Get one VendorTaxCompliance
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorTaxComplianceFindUniqueArgs>(args: SelectSubset<T, VendorTaxComplianceFindUniqueArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorTaxCompliance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorTaxComplianceFindUniqueOrThrowArgs} args - Arguments to find a VendorTaxCompliance
     * @example
     * // Get one VendorTaxCompliance
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorTaxComplianceFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorTaxComplianceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorTaxCompliance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTaxComplianceFindFirstArgs} args - Arguments to find a VendorTaxCompliance
     * @example
     * // Get one VendorTaxCompliance
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorTaxComplianceFindFirstArgs>(args?: SelectSubset<T, VendorTaxComplianceFindFirstArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorTaxCompliance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTaxComplianceFindFirstOrThrowArgs} args - Arguments to find a VendorTaxCompliance
     * @example
     * // Get one VendorTaxCompliance
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorTaxComplianceFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorTaxComplianceFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorTaxCompliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTaxComplianceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorTaxCompliances
     * const vendorTaxCompliances = await prisma.vendorTaxCompliance.findMany()
     * 
     * // Get first 10 VendorTaxCompliances
     * const vendorTaxCompliances = await prisma.vendorTaxCompliance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorTaxComplianceWithIdOnly = await prisma.vendorTaxCompliance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorTaxComplianceFindManyArgs>(args?: SelectSubset<T, VendorTaxComplianceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorTaxCompliance.
     * @param {VendorTaxComplianceCreateArgs} args - Arguments to create a VendorTaxCompliance.
     * @example
     * // Create one VendorTaxCompliance
     * const VendorTaxCompliance = await prisma.vendorTaxCompliance.create({
     *   data: {
     *     // ... data to create a VendorTaxCompliance
     *   }
     * })
     * 
     */
    create<T extends VendorTaxComplianceCreateArgs>(args: SelectSubset<T, VendorTaxComplianceCreateArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorTaxCompliances.
     * @param {VendorTaxComplianceCreateManyArgs} args - Arguments to create many VendorTaxCompliances.
     * @example
     * // Create many VendorTaxCompliances
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorTaxComplianceCreateManyArgs>(args?: SelectSubset<T, VendorTaxComplianceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorTaxCompliances and returns the data saved in the database.
     * @param {VendorTaxComplianceCreateManyAndReturnArgs} args - Arguments to create many VendorTaxCompliances.
     * @example
     * // Create many VendorTaxCompliances
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorTaxCompliances and only return the `id`
     * const vendorTaxComplianceWithIdOnly = await prisma.vendorTaxCompliance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorTaxComplianceCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorTaxComplianceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorTaxCompliance.
     * @param {VendorTaxComplianceDeleteArgs} args - Arguments to delete one VendorTaxCompliance.
     * @example
     * // Delete one VendorTaxCompliance
     * const VendorTaxCompliance = await prisma.vendorTaxCompliance.delete({
     *   where: {
     *     // ... filter to delete one VendorTaxCompliance
     *   }
     * })
     * 
     */
    delete<T extends VendorTaxComplianceDeleteArgs>(args: SelectSubset<T, VendorTaxComplianceDeleteArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorTaxCompliance.
     * @param {VendorTaxComplianceUpdateArgs} args - Arguments to update one VendorTaxCompliance.
     * @example
     * // Update one VendorTaxCompliance
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorTaxComplianceUpdateArgs>(args: SelectSubset<T, VendorTaxComplianceUpdateArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorTaxCompliances.
     * @param {VendorTaxComplianceDeleteManyArgs} args - Arguments to filter VendorTaxCompliances to delete.
     * @example
     * // Delete a few VendorTaxCompliances
     * const { count } = await prisma.vendorTaxCompliance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorTaxComplianceDeleteManyArgs>(args?: SelectSubset<T, VendorTaxComplianceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorTaxCompliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTaxComplianceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorTaxCompliances
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorTaxComplianceUpdateManyArgs>(args: SelectSubset<T, VendorTaxComplianceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorTaxCompliances and returns the data updated in the database.
     * @param {VendorTaxComplianceUpdateManyAndReturnArgs} args - Arguments to update many VendorTaxCompliances.
     * @example
     * // Update many VendorTaxCompliances
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorTaxCompliances and only return the `id`
     * const vendorTaxComplianceWithIdOnly = await prisma.vendorTaxCompliance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorTaxComplianceUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorTaxComplianceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorTaxCompliance.
     * @param {VendorTaxComplianceUpsertArgs} args - Arguments to update or create a VendorTaxCompliance.
     * @example
     * // Update or create a VendorTaxCompliance
     * const vendorTaxCompliance = await prisma.vendorTaxCompliance.upsert({
     *   create: {
     *     // ... data to create a VendorTaxCompliance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorTaxCompliance we want to update
     *   }
     * })
     */
    upsert<T extends VendorTaxComplianceUpsertArgs>(args: SelectSubset<T, VendorTaxComplianceUpsertArgs<ExtArgs>>): Prisma__VendorTaxComplianceClient<$Result.GetResult<Prisma.$VendorTaxCompliancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorTaxCompliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTaxComplianceCountArgs} args - Arguments to filter VendorTaxCompliances to count.
     * @example
     * // Count the number of VendorTaxCompliances
     * const count = await prisma.vendorTaxCompliance.count({
     *   where: {
     *     // ... the filter for the VendorTaxCompliances we want to count
     *   }
     * })
    **/
    count<T extends VendorTaxComplianceCountArgs>(
      args?: Subset<T, VendorTaxComplianceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorTaxComplianceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorTaxCompliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTaxComplianceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorTaxComplianceAggregateArgs>(args: Subset<T, VendorTaxComplianceAggregateArgs>): Prisma.PrismaPromise<GetVendorTaxComplianceAggregateType<T>>

    /**
     * Group by VendorTaxCompliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTaxComplianceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorTaxComplianceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorTaxComplianceGroupByArgs['orderBy'] }
        : { orderBy?: VendorTaxComplianceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorTaxComplianceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorTaxComplianceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorTaxCompliance model
   */
  readonly fields: VendorTaxComplianceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorTaxCompliance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorTaxComplianceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorTaxCompliance model
   */
  interface VendorTaxComplianceFieldRefs {
    readonly id: FieldRef<"VendorTaxCompliance", 'String'>
    readonly vendor_id: FieldRef<"VendorTaxCompliance", 'String'>
    readonly tax_number: FieldRef<"VendorTaxCompliance", 'String'>
    readonly vat_number: FieldRef<"VendorTaxCompliance", 'String'>
    readonly company_number: FieldRef<"VendorTaxCompliance", 'String'>
    readonly compliance_type: FieldRef<"VendorTaxCompliance", 'String'>
    readonly file_name: FieldRef<"VendorTaxCompliance", 'String'>
    readonly file_url: FieldRef<"VendorTaxCompliance", 'String'>
    readonly created_at: FieldRef<"VendorTaxCompliance", 'DateTime'>
    readonly updated_at: FieldRef<"VendorTaxCompliance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorTaxCompliance findUnique
   */
  export type VendorTaxComplianceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * Filter, which VendorTaxCompliance to fetch.
     */
    where: VendorTaxComplianceWhereUniqueInput
  }

  /**
   * VendorTaxCompliance findUniqueOrThrow
   */
  export type VendorTaxComplianceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * Filter, which VendorTaxCompliance to fetch.
     */
    where: VendorTaxComplianceWhereUniqueInput
  }

  /**
   * VendorTaxCompliance findFirst
   */
  export type VendorTaxComplianceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * Filter, which VendorTaxCompliance to fetch.
     */
    where?: VendorTaxComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorTaxCompliances to fetch.
     */
    orderBy?: VendorTaxComplianceOrderByWithRelationInput | VendorTaxComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorTaxCompliances.
     */
    cursor?: VendorTaxComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorTaxCompliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorTaxCompliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorTaxCompliances.
     */
    distinct?: VendorTaxComplianceScalarFieldEnum | VendorTaxComplianceScalarFieldEnum[]
  }

  /**
   * VendorTaxCompliance findFirstOrThrow
   */
  export type VendorTaxComplianceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * Filter, which VendorTaxCompliance to fetch.
     */
    where?: VendorTaxComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorTaxCompliances to fetch.
     */
    orderBy?: VendorTaxComplianceOrderByWithRelationInput | VendorTaxComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorTaxCompliances.
     */
    cursor?: VendorTaxComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorTaxCompliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorTaxCompliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorTaxCompliances.
     */
    distinct?: VendorTaxComplianceScalarFieldEnum | VendorTaxComplianceScalarFieldEnum[]
  }

  /**
   * VendorTaxCompliance findMany
   */
  export type VendorTaxComplianceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * Filter, which VendorTaxCompliances to fetch.
     */
    where?: VendorTaxComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorTaxCompliances to fetch.
     */
    orderBy?: VendorTaxComplianceOrderByWithRelationInput | VendorTaxComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorTaxCompliances.
     */
    cursor?: VendorTaxComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorTaxCompliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorTaxCompliances.
     */
    skip?: number
    distinct?: VendorTaxComplianceScalarFieldEnum | VendorTaxComplianceScalarFieldEnum[]
  }

  /**
   * VendorTaxCompliance create
   */
  export type VendorTaxComplianceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorTaxCompliance.
     */
    data: XOR<VendorTaxComplianceCreateInput, VendorTaxComplianceUncheckedCreateInput>
  }

  /**
   * VendorTaxCompliance createMany
   */
  export type VendorTaxComplianceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorTaxCompliances.
     */
    data: VendorTaxComplianceCreateManyInput | VendorTaxComplianceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorTaxCompliance createManyAndReturn
   */
  export type VendorTaxComplianceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * The data used to create many VendorTaxCompliances.
     */
    data: VendorTaxComplianceCreateManyInput | VendorTaxComplianceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorTaxCompliance update
   */
  export type VendorTaxComplianceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorTaxCompliance.
     */
    data: XOR<VendorTaxComplianceUpdateInput, VendorTaxComplianceUncheckedUpdateInput>
    /**
     * Choose, which VendorTaxCompliance to update.
     */
    where: VendorTaxComplianceWhereUniqueInput
  }

  /**
   * VendorTaxCompliance updateMany
   */
  export type VendorTaxComplianceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorTaxCompliances.
     */
    data: XOR<VendorTaxComplianceUpdateManyMutationInput, VendorTaxComplianceUncheckedUpdateManyInput>
    /**
     * Filter which VendorTaxCompliances to update
     */
    where?: VendorTaxComplianceWhereInput
    /**
     * Limit how many VendorTaxCompliances to update.
     */
    limit?: number
  }

  /**
   * VendorTaxCompliance updateManyAndReturn
   */
  export type VendorTaxComplianceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * The data used to update VendorTaxCompliances.
     */
    data: XOR<VendorTaxComplianceUpdateManyMutationInput, VendorTaxComplianceUncheckedUpdateManyInput>
    /**
     * Filter which VendorTaxCompliances to update
     */
    where?: VendorTaxComplianceWhereInput
    /**
     * Limit how many VendorTaxCompliances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorTaxCompliance upsert
   */
  export type VendorTaxComplianceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorTaxCompliance to update in case it exists.
     */
    where: VendorTaxComplianceWhereUniqueInput
    /**
     * In case the VendorTaxCompliance found by the `where` argument doesn't exist, create a new VendorTaxCompliance with this data.
     */
    create: XOR<VendorTaxComplianceCreateInput, VendorTaxComplianceUncheckedCreateInput>
    /**
     * In case the VendorTaxCompliance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorTaxComplianceUpdateInput, VendorTaxComplianceUncheckedUpdateInput>
  }

  /**
   * VendorTaxCompliance delete
   */
  export type VendorTaxComplianceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
    /**
     * Filter which VendorTaxCompliance to delete.
     */
    where: VendorTaxComplianceWhereUniqueInput
  }

  /**
   * VendorTaxCompliance deleteMany
   */
  export type VendorTaxComplianceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorTaxCompliances to delete
     */
    where?: VendorTaxComplianceWhereInput
    /**
     * Limit how many VendorTaxCompliances to delete.
     */
    limit?: number
  }

  /**
   * VendorTaxCompliance without action
   */
  export type VendorTaxComplianceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorTaxCompliance
     */
    select?: VendorTaxComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorTaxCompliance
     */
    omit?: VendorTaxComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorTaxComplianceInclude<ExtArgs> | null
  }


  /**
   * Model VendorFinancial
   */

  export type AggregateVendorFinancial = {
    _count: VendorFinancialCountAggregateOutputType | null
    _avg: VendorFinancialAvgAggregateOutputType | null
    _sum: VendorFinancialSumAggregateOutputType | null
    _min: VendorFinancialMinAggregateOutputType | null
    _max: VendorFinancialMaxAggregateOutputType | null
  }

  export type VendorFinancialAvgAggregateOutputType = {
    credit_limit: number | null
  }

  export type VendorFinancialSumAggregateOutputType = {
    credit_limit: number | null
  }

  export type VendorFinancialMinAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    bank_name: string | null
    bank_account_number: string | null
    swift_iban_code: string | null
    preferred_currency: string | null
    payment_terms: string | null
    default_tax_rate: string | null
    credit_limit: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorFinancialMaxAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    bank_name: string | null
    bank_account_number: string | null
    swift_iban_code: string | null
    preferred_currency: string | null
    payment_terms: string | null
    default_tax_rate: string | null
    credit_limit: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorFinancialCountAggregateOutputType = {
    id: number
    vendor_id: number
    bank_name: number
    bank_account_number: number
    swift_iban_code: number
    preferred_currency: number
    payment_terms: number
    default_tax_rate: number
    credit_limit: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorFinancialAvgAggregateInputType = {
    credit_limit?: true
  }

  export type VendorFinancialSumAggregateInputType = {
    credit_limit?: true
  }

  export type VendorFinancialMinAggregateInputType = {
    id?: true
    vendor_id?: true
    bank_name?: true
    bank_account_number?: true
    swift_iban_code?: true
    preferred_currency?: true
    payment_terms?: true
    default_tax_rate?: true
    credit_limit?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorFinancialMaxAggregateInputType = {
    id?: true
    vendor_id?: true
    bank_name?: true
    bank_account_number?: true
    swift_iban_code?: true
    preferred_currency?: true
    payment_terms?: true
    default_tax_rate?: true
    credit_limit?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorFinancialCountAggregateInputType = {
    id?: true
    vendor_id?: true
    bank_name?: true
    bank_account_number?: true
    swift_iban_code?: true
    preferred_currency?: true
    payment_terms?: true
    default_tax_rate?: true
    credit_limit?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorFinancialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorFinancial to aggregate.
     */
    where?: VendorFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorFinancials to fetch.
     */
    orderBy?: VendorFinancialOrderByWithRelationInput | VendorFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorFinancials
    **/
    _count?: true | VendorFinancialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorFinancialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorFinancialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorFinancialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorFinancialMaxAggregateInputType
  }

  export type GetVendorFinancialAggregateType<T extends VendorFinancialAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorFinancial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorFinancial[P]>
      : GetScalarType<T[P], AggregateVendorFinancial[P]>
  }




  export type VendorFinancialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorFinancialWhereInput
    orderBy?: VendorFinancialOrderByWithAggregationInput | VendorFinancialOrderByWithAggregationInput[]
    by: VendorFinancialScalarFieldEnum[] | VendorFinancialScalarFieldEnum
    having?: VendorFinancialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorFinancialCountAggregateInputType | true
    _avg?: VendorFinancialAvgAggregateInputType
    _sum?: VendorFinancialSumAggregateInputType
    _min?: VendorFinancialMinAggregateInputType
    _max?: VendorFinancialMaxAggregateInputType
  }

  export type VendorFinancialGroupByOutputType = {
    id: string
    vendor_id: string
    bank_name: string | null
    bank_account_number: string | null
    swift_iban_code: string | null
    preferred_currency: string
    payment_terms: string
    default_tax_rate: string | null
    credit_limit: number | null
    created_at: Date
    updated_at: Date
    _count: VendorFinancialCountAggregateOutputType | null
    _avg: VendorFinancialAvgAggregateOutputType | null
    _sum: VendorFinancialSumAggregateOutputType | null
    _min: VendorFinancialMinAggregateOutputType | null
    _max: VendorFinancialMaxAggregateOutputType | null
  }

  type GetVendorFinancialGroupByPayload<T extends VendorFinancialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorFinancialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorFinancialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorFinancialGroupByOutputType[P]>
            : GetScalarType<T[P], VendorFinancialGroupByOutputType[P]>
        }
      >
    >


  export type VendorFinancialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    bank_name?: boolean
    bank_account_number?: boolean
    swift_iban_code?: boolean
    preferred_currency?: boolean
    payment_terms?: boolean
    default_tax_rate?: boolean
    credit_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorFinancial"]>

  export type VendorFinancialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    bank_name?: boolean
    bank_account_number?: boolean
    swift_iban_code?: boolean
    preferred_currency?: boolean
    payment_terms?: boolean
    default_tax_rate?: boolean
    credit_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorFinancial"]>

  export type VendorFinancialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    bank_name?: boolean
    bank_account_number?: boolean
    swift_iban_code?: boolean
    preferred_currency?: boolean
    payment_terms?: boolean
    default_tax_rate?: boolean
    credit_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorFinancial"]>

  export type VendorFinancialSelectScalar = {
    id?: boolean
    vendor_id?: boolean
    bank_name?: boolean
    bank_account_number?: boolean
    swift_iban_code?: boolean
    preferred_currency?: boolean
    payment_terms?: boolean
    default_tax_rate?: boolean
    credit_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorFinancialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_id" | "bank_name" | "bank_account_number" | "swift_iban_code" | "preferred_currency" | "payment_terms" | "default_tax_rate" | "credit_limit" | "created_at" | "updated_at", ExtArgs["result"]["vendorFinancial"]>
  export type VendorFinancialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorFinancialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorFinancialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorFinancialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorFinancial"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_id: string
      bank_name: string | null
      bank_account_number: string | null
      swift_iban_code: string | null
      preferred_currency: string
      payment_terms: string
      default_tax_rate: string | null
      credit_limit: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendorFinancial"]>
    composites: {}
  }

  type VendorFinancialGetPayload<S extends boolean | null | undefined | VendorFinancialDefaultArgs> = $Result.GetResult<Prisma.$VendorFinancialPayload, S>

  type VendorFinancialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFinancialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorFinancialCountAggregateInputType | true
    }

  export interface VendorFinancialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorFinancial'], meta: { name: 'VendorFinancial' } }
    /**
     * Find zero or one VendorFinancial that matches the filter.
     * @param {VendorFinancialFindUniqueArgs} args - Arguments to find a VendorFinancial
     * @example
     * // Get one VendorFinancial
     * const vendorFinancial = await prisma.vendorFinancial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFinancialFindUniqueArgs>(args: SelectSubset<T, VendorFinancialFindUniqueArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorFinancial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFinancialFindUniqueOrThrowArgs} args - Arguments to find a VendorFinancial
     * @example
     * // Get one VendorFinancial
     * const vendorFinancial = await prisma.vendorFinancial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFinancialFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFinancialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorFinancial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFinancialFindFirstArgs} args - Arguments to find a VendorFinancial
     * @example
     * // Get one VendorFinancial
     * const vendorFinancial = await prisma.vendorFinancial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFinancialFindFirstArgs>(args?: SelectSubset<T, VendorFinancialFindFirstArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorFinancial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFinancialFindFirstOrThrowArgs} args - Arguments to find a VendorFinancial
     * @example
     * // Get one VendorFinancial
     * const vendorFinancial = await prisma.vendorFinancial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFinancialFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFinancialFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorFinancials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFinancialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorFinancials
     * const vendorFinancials = await prisma.vendorFinancial.findMany()
     * 
     * // Get first 10 VendorFinancials
     * const vendorFinancials = await prisma.vendorFinancial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorFinancialWithIdOnly = await prisma.vendorFinancial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFinancialFindManyArgs>(args?: SelectSubset<T, VendorFinancialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorFinancial.
     * @param {VendorFinancialCreateArgs} args - Arguments to create a VendorFinancial.
     * @example
     * // Create one VendorFinancial
     * const VendorFinancial = await prisma.vendorFinancial.create({
     *   data: {
     *     // ... data to create a VendorFinancial
     *   }
     * })
     * 
     */
    create<T extends VendorFinancialCreateArgs>(args: SelectSubset<T, VendorFinancialCreateArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorFinancials.
     * @param {VendorFinancialCreateManyArgs} args - Arguments to create many VendorFinancials.
     * @example
     * // Create many VendorFinancials
     * const vendorFinancial = await prisma.vendorFinancial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorFinancialCreateManyArgs>(args?: SelectSubset<T, VendorFinancialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorFinancials and returns the data saved in the database.
     * @param {VendorFinancialCreateManyAndReturnArgs} args - Arguments to create many VendorFinancials.
     * @example
     * // Create many VendorFinancials
     * const vendorFinancial = await prisma.vendorFinancial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorFinancials and only return the `id`
     * const vendorFinancialWithIdOnly = await prisma.vendorFinancial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorFinancialCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorFinancialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorFinancial.
     * @param {VendorFinancialDeleteArgs} args - Arguments to delete one VendorFinancial.
     * @example
     * // Delete one VendorFinancial
     * const VendorFinancial = await prisma.vendorFinancial.delete({
     *   where: {
     *     // ... filter to delete one VendorFinancial
     *   }
     * })
     * 
     */
    delete<T extends VendorFinancialDeleteArgs>(args: SelectSubset<T, VendorFinancialDeleteArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorFinancial.
     * @param {VendorFinancialUpdateArgs} args - Arguments to update one VendorFinancial.
     * @example
     * // Update one VendorFinancial
     * const vendorFinancial = await prisma.vendorFinancial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorFinancialUpdateArgs>(args: SelectSubset<T, VendorFinancialUpdateArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorFinancials.
     * @param {VendorFinancialDeleteManyArgs} args - Arguments to filter VendorFinancials to delete.
     * @example
     * // Delete a few VendorFinancials
     * const { count } = await prisma.vendorFinancial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorFinancialDeleteManyArgs>(args?: SelectSubset<T, VendorFinancialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorFinancials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFinancialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorFinancials
     * const vendorFinancial = await prisma.vendorFinancial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorFinancialUpdateManyArgs>(args: SelectSubset<T, VendorFinancialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorFinancials and returns the data updated in the database.
     * @param {VendorFinancialUpdateManyAndReturnArgs} args - Arguments to update many VendorFinancials.
     * @example
     * // Update many VendorFinancials
     * const vendorFinancial = await prisma.vendorFinancial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorFinancials and only return the `id`
     * const vendorFinancialWithIdOnly = await prisma.vendorFinancial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorFinancialUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorFinancialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorFinancial.
     * @param {VendorFinancialUpsertArgs} args - Arguments to update or create a VendorFinancial.
     * @example
     * // Update or create a VendorFinancial
     * const vendorFinancial = await prisma.vendorFinancial.upsert({
     *   create: {
     *     // ... data to create a VendorFinancial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorFinancial we want to update
     *   }
     * })
     */
    upsert<T extends VendorFinancialUpsertArgs>(args: SelectSubset<T, VendorFinancialUpsertArgs<ExtArgs>>): Prisma__VendorFinancialClient<$Result.GetResult<Prisma.$VendorFinancialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorFinancials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFinancialCountArgs} args - Arguments to filter VendorFinancials to count.
     * @example
     * // Count the number of VendorFinancials
     * const count = await prisma.vendorFinancial.count({
     *   where: {
     *     // ... the filter for the VendorFinancials we want to count
     *   }
     * })
    **/
    count<T extends VendorFinancialCountArgs>(
      args?: Subset<T, VendorFinancialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorFinancialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorFinancial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFinancialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorFinancialAggregateArgs>(args: Subset<T, VendorFinancialAggregateArgs>): Prisma.PrismaPromise<GetVendorFinancialAggregateType<T>>

    /**
     * Group by VendorFinancial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFinancialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorFinancialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorFinancialGroupByArgs['orderBy'] }
        : { orderBy?: VendorFinancialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorFinancialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorFinancialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorFinancial model
   */
  readonly fields: VendorFinancialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorFinancial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorFinancialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorFinancial model
   */
  interface VendorFinancialFieldRefs {
    readonly id: FieldRef<"VendorFinancial", 'String'>
    readonly vendor_id: FieldRef<"VendorFinancial", 'String'>
    readonly bank_name: FieldRef<"VendorFinancial", 'String'>
    readonly bank_account_number: FieldRef<"VendorFinancial", 'String'>
    readonly swift_iban_code: FieldRef<"VendorFinancial", 'String'>
    readonly preferred_currency: FieldRef<"VendorFinancial", 'String'>
    readonly payment_terms: FieldRef<"VendorFinancial", 'String'>
    readonly default_tax_rate: FieldRef<"VendorFinancial", 'String'>
    readonly credit_limit: FieldRef<"VendorFinancial", 'Float'>
    readonly created_at: FieldRef<"VendorFinancial", 'DateTime'>
    readonly updated_at: FieldRef<"VendorFinancial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorFinancial findUnique
   */
  export type VendorFinancialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * Filter, which VendorFinancial to fetch.
     */
    where: VendorFinancialWhereUniqueInput
  }

  /**
   * VendorFinancial findUniqueOrThrow
   */
  export type VendorFinancialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * Filter, which VendorFinancial to fetch.
     */
    where: VendorFinancialWhereUniqueInput
  }

  /**
   * VendorFinancial findFirst
   */
  export type VendorFinancialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * Filter, which VendorFinancial to fetch.
     */
    where?: VendorFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorFinancials to fetch.
     */
    orderBy?: VendorFinancialOrderByWithRelationInput | VendorFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorFinancials.
     */
    cursor?: VendorFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorFinancials.
     */
    distinct?: VendorFinancialScalarFieldEnum | VendorFinancialScalarFieldEnum[]
  }

  /**
   * VendorFinancial findFirstOrThrow
   */
  export type VendorFinancialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * Filter, which VendorFinancial to fetch.
     */
    where?: VendorFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorFinancials to fetch.
     */
    orderBy?: VendorFinancialOrderByWithRelationInput | VendorFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorFinancials.
     */
    cursor?: VendorFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorFinancials.
     */
    distinct?: VendorFinancialScalarFieldEnum | VendorFinancialScalarFieldEnum[]
  }

  /**
   * VendorFinancial findMany
   */
  export type VendorFinancialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * Filter, which VendorFinancials to fetch.
     */
    where?: VendorFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorFinancials to fetch.
     */
    orderBy?: VendorFinancialOrderByWithRelationInput | VendorFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorFinancials.
     */
    cursor?: VendorFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorFinancials.
     */
    skip?: number
    distinct?: VendorFinancialScalarFieldEnum | VendorFinancialScalarFieldEnum[]
  }

  /**
   * VendorFinancial create
   */
  export type VendorFinancialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorFinancial.
     */
    data: XOR<VendorFinancialCreateInput, VendorFinancialUncheckedCreateInput>
  }

  /**
   * VendorFinancial createMany
   */
  export type VendorFinancialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorFinancials.
     */
    data: VendorFinancialCreateManyInput | VendorFinancialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorFinancial createManyAndReturn
   */
  export type VendorFinancialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * The data used to create many VendorFinancials.
     */
    data: VendorFinancialCreateManyInput | VendorFinancialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorFinancial update
   */
  export type VendorFinancialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorFinancial.
     */
    data: XOR<VendorFinancialUpdateInput, VendorFinancialUncheckedUpdateInput>
    /**
     * Choose, which VendorFinancial to update.
     */
    where: VendorFinancialWhereUniqueInput
  }

  /**
   * VendorFinancial updateMany
   */
  export type VendorFinancialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorFinancials.
     */
    data: XOR<VendorFinancialUpdateManyMutationInput, VendorFinancialUncheckedUpdateManyInput>
    /**
     * Filter which VendorFinancials to update
     */
    where?: VendorFinancialWhereInput
    /**
     * Limit how many VendorFinancials to update.
     */
    limit?: number
  }

  /**
   * VendorFinancial updateManyAndReturn
   */
  export type VendorFinancialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * The data used to update VendorFinancials.
     */
    data: XOR<VendorFinancialUpdateManyMutationInput, VendorFinancialUncheckedUpdateManyInput>
    /**
     * Filter which VendorFinancials to update
     */
    where?: VendorFinancialWhereInput
    /**
     * Limit how many VendorFinancials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorFinancial upsert
   */
  export type VendorFinancialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorFinancial to update in case it exists.
     */
    where: VendorFinancialWhereUniqueInput
    /**
     * In case the VendorFinancial found by the `where` argument doesn't exist, create a new VendorFinancial with this data.
     */
    create: XOR<VendorFinancialCreateInput, VendorFinancialUncheckedCreateInput>
    /**
     * In case the VendorFinancial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorFinancialUpdateInput, VendorFinancialUncheckedUpdateInput>
  }

  /**
   * VendorFinancial delete
   */
  export type VendorFinancialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
    /**
     * Filter which VendorFinancial to delete.
     */
    where: VendorFinancialWhereUniqueInput
  }

  /**
   * VendorFinancial deleteMany
   */
  export type VendorFinancialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorFinancials to delete
     */
    where?: VendorFinancialWhereInput
    /**
     * Limit how many VendorFinancials to delete.
     */
    limit?: number
  }

  /**
   * VendorFinancial without action
   */
  export type VendorFinancialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFinancial
     */
    select?: VendorFinancialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFinancial
     */
    omit?: VendorFinancialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFinancialInclude<ExtArgs> | null
  }


  /**
   * Model VendorOperationalSetting
   */

  export type AggregateVendorOperationalSetting = {
    _count: VendorOperationalSettingCountAggregateOutputType | null
    _avg: VendorOperationalSettingAvgAggregateOutputType | null
    _sum: VendorOperationalSettingSumAggregateOutputType | null
    _min: VendorOperationalSettingMinAggregateOutputType | null
    _max: VendorOperationalSettingMaxAggregateOutputType | null
  }

  export type VendorOperationalSettingAvgAggregateOutputType = {
    lead_time: number | null
    minimum_order_quantity: number | null
  }

  export type VendorOperationalSettingSumAggregateOutputType = {
    lead_time: number | null
    minimum_order_quantity: number | null
  }

  export type VendorOperationalSettingMinAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    status: string | null
    shipping_method: string | null
    lead_time: number | null
    minimum_order_quantity: number | null
    manager: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorOperationalSettingMaxAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    status: string | null
    shipping_method: string | null
    lead_time: number | null
    minimum_order_quantity: number | null
    manager: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorOperationalSettingCountAggregateOutputType = {
    id: number
    vendor_id: number
    status: number
    shipping_method: number
    lead_time: number
    minimum_order_quantity: number
    categories: number
    manager: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorOperationalSettingAvgAggregateInputType = {
    lead_time?: true
    minimum_order_quantity?: true
  }

  export type VendorOperationalSettingSumAggregateInputType = {
    lead_time?: true
    minimum_order_quantity?: true
  }

  export type VendorOperationalSettingMinAggregateInputType = {
    id?: true
    vendor_id?: true
    status?: true
    shipping_method?: true
    lead_time?: true
    minimum_order_quantity?: true
    manager?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorOperationalSettingMaxAggregateInputType = {
    id?: true
    vendor_id?: true
    status?: true
    shipping_method?: true
    lead_time?: true
    minimum_order_quantity?: true
    manager?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorOperationalSettingCountAggregateInputType = {
    id?: true
    vendor_id?: true
    status?: true
    shipping_method?: true
    lead_time?: true
    minimum_order_quantity?: true
    categories?: true
    manager?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorOperationalSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorOperationalSetting to aggregate.
     */
    where?: VendorOperationalSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorOperationalSettings to fetch.
     */
    orderBy?: VendorOperationalSettingOrderByWithRelationInput | VendorOperationalSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorOperationalSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorOperationalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorOperationalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorOperationalSettings
    **/
    _count?: true | VendorOperationalSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorOperationalSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorOperationalSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorOperationalSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorOperationalSettingMaxAggregateInputType
  }

  export type GetVendorOperationalSettingAggregateType<T extends VendorOperationalSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorOperationalSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorOperationalSetting[P]>
      : GetScalarType<T[P], AggregateVendorOperationalSetting[P]>
  }




  export type VendorOperationalSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorOperationalSettingWhereInput
    orderBy?: VendorOperationalSettingOrderByWithAggregationInput | VendorOperationalSettingOrderByWithAggregationInput[]
    by: VendorOperationalSettingScalarFieldEnum[] | VendorOperationalSettingScalarFieldEnum
    having?: VendorOperationalSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorOperationalSettingCountAggregateInputType | true
    _avg?: VendorOperationalSettingAvgAggregateInputType
    _sum?: VendorOperationalSettingSumAggregateInputType
    _min?: VendorOperationalSettingMinAggregateInputType
    _max?: VendorOperationalSettingMaxAggregateInputType
  }

  export type VendorOperationalSettingGroupByOutputType = {
    id: string
    vendor_id: string
    status: string | null
    shipping_method: string | null
    lead_time: number | null
    minimum_order_quantity: number | null
    categories: string[]
    manager: string
    created_at: Date
    updated_at: Date
    _count: VendorOperationalSettingCountAggregateOutputType | null
    _avg: VendorOperationalSettingAvgAggregateOutputType | null
    _sum: VendorOperationalSettingSumAggregateOutputType | null
    _min: VendorOperationalSettingMinAggregateOutputType | null
    _max: VendorOperationalSettingMaxAggregateOutputType | null
  }

  type GetVendorOperationalSettingGroupByPayload<T extends VendorOperationalSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorOperationalSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorOperationalSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorOperationalSettingGroupByOutputType[P]>
            : GetScalarType<T[P], VendorOperationalSettingGroupByOutputType[P]>
        }
      >
    >


  export type VendorOperationalSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    status?: boolean
    shipping_method?: boolean
    lead_time?: boolean
    minimum_order_quantity?: boolean
    categories?: boolean
    manager?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorOperationalSetting"]>

  export type VendorOperationalSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    status?: boolean
    shipping_method?: boolean
    lead_time?: boolean
    minimum_order_quantity?: boolean
    categories?: boolean
    manager?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorOperationalSetting"]>

  export type VendorOperationalSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    status?: boolean
    shipping_method?: boolean
    lead_time?: boolean
    minimum_order_quantity?: boolean
    categories?: boolean
    manager?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorOperationalSetting"]>

  export type VendorOperationalSettingSelectScalar = {
    id?: boolean
    vendor_id?: boolean
    status?: boolean
    shipping_method?: boolean
    lead_time?: boolean
    minimum_order_quantity?: boolean
    categories?: boolean
    manager?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorOperationalSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_id" | "status" | "shipping_method" | "lead_time" | "minimum_order_quantity" | "categories" | "manager" | "created_at" | "updated_at", ExtArgs["result"]["vendorOperationalSetting"]>
  export type VendorOperationalSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorOperationalSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorOperationalSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorOperationalSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorOperationalSetting"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_id: string
      status: string | null
      shipping_method: string | null
      lead_time: number | null
      minimum_order_quantity: number | null
      categories: string[]
      manager: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendorOperationalSetting"]>
    composites: {}
  }

  type VendorOperationalSettingGetPayload<S extends boolean | null | undefined | VendorOperationalSettingDefaultArgs> = $Result.GetResult<Prisma.$VendorOperationalSettingPayload, S>

  type VendorOperationalSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorOperationalSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorOperationalSettingCountAggregateInputType | true
    }

  export interface VendorOperationalSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorOperationalSetting'], meta: { name: 'VendorOperationalSetting' } }
    /**
     * Find zero or one VendorOperationalSetting that matches the filter.
     * @param {VendorOperationalSettingFindUniqueArgs} args - Arguments to find a VendorOperationalSetting
     * @example
     * // Get one VendorOperationalSetting
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorOperationalSettingFindUniqueArgs>(args: SelectSubset<T, VendorOperationalSettingFindUniqueArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorOperationalSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorOperationalSettingFindUniqueOrThrowArgs} args - Arguments to find a VendorOperationalSetting
     * @example
     * // Get one VendorOperationalSetting
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorOperationalSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorOperationalSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorOperationalSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorOperationalSettingFindFirstArgs} args - Arguments to find a VendorOperationalSetting
     * @example
     * // Get one VendorOperationalSetting
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorOperationalSettingFindFirstArgs>(args?: SelectSubset<T, VendorOperationalSettingFindFirstArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorOperationalSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorOperationalSettingFindFirstOrThrowArgs} args - Arguments to find a VendorOperationalSetting
     * @example
     * // Get one VendorOperationalSetting
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorOperationalSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorOperationalSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorOperationalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorOperationalSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorOperationalSettings
     * const vendorOperationalSettings = await prisma.vendorOperationalSetting.findMany()
     * 
     * // Get first 10 VendorOperationalSettings
     * const vendorOperationalSettings = await prisma.vendorOperationalSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorOperationalSettingWithIdOnly = await prisma.vendorOperationalSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorOperationalSettingFindManyArgs>(args?: SelectSubset<T, VendorOperationalSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorOperationalSetting.
     * @param {VendorOperationalSettingCreateArgs} args - Arguments to create a VendorOperationalSetting.
     * @example
     * // Create one VendorOperationalSetting
     * const VendorOperationalSetting = await prisma.vendorOperationalSetting.create({
     *   data: {
     *     // ... data to create a VendorOperationalSetting
     *   }
     * })
     * 
     */
    create<T extends VendorOperationalSettingCreateArgs>(args: SelectSubset<T, VendorOperationalSettingCreateArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorOperationalSettings.
     * @param {VendorOperationalSettingCreateManyArgs} args - Arguments to create many VendorOperationalSettings.
     * @example
     * // Create many VendorOperationalSettings
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorOperationalSettingCreateManyArgs>(args?: SelectSubset<T, VendorOperationalSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorOperationalSettings and returns the data saved in the database.
     * @param {VendorOperationalSettingCreateManyAndReturnArgs} args - Arguments to create many VendorOperationalSettings.
     * @example
     * // Create many VendorOperationalSettings
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorOperationalSettings and only return the `id`
     * const vendorOperationalSettingWithIdOnly = await prisma.vendorOperationalSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorOperationalSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorOperationalSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorOperationalSetting.
     * @param {VendorOperationalSettingDeleteArgs} args - Arguments to delete one VendorOperationalSetting.
     * @example
     * // Delete one VendorOperationalSetting
     * const VendorOperationalSetting = await prisma.vendorOperationalSetting.delete({
     *   where: {
     *     // ... filter to delete one VendorOperationalSetting
     *   }
     * })
     * 
     */
    delete<T extends VendorOperationalSettingDeleteArgs>(args: SelectSubset<T, VendorOperationalSettingDeleteArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorOperationalSetting.
     * @param {VendorOperationalSettingUpdateArgs} args - Arguments to update one VendorOperationalSetting.
     * @example
     * // Update one VendorOperationalSetting
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorOperationalSettingUpdateArgs>(args: SelectSubset<T, VendorOperationalSettingUpdateArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorOperationalSettings.
     * @param {VendorOperationalSettingDeleteManyArgs} args - Arguments to filter VendorOperationalSettings to delete.
     * @example
     * // Delete a few VendorOperationalSettings
     * const { count } = await prisma.vendorOperationalSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorOperationalSettingDeleteManyArgs>(args?: SelectSubset<T, VendorOperationalSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorOperationalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorOperationalSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorOperationalSettings
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorOperationalSettingUpdateManyArgs>(args: SelectSubset<T, VendorOperationalSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorOperationalSettings and returns the data updated in the database.
     * @param {VendorOperationalSettingUpdateManyAndReturnArgs} args - Arguments to update many VendorOperationalSettings.
     * @example
     * // Update many VendorOperationalSettings
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorOperationalSettings and only return the `id`
     * const vendorOperationalSettingWithIdOnly = await prisma.vendorOperationalSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorOperationalSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorOperationalSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorOperationalSetting.
     * @param {VendorOperationalSettingUpsertArgs} args - Arguments to update or create a VendorOperationalSetting.
     * @example
     * // Update or create a VendorOperationalSetting
     * const vendorOperationalSetting = await prisma.vendorOperationalSetting.upsert({
     *   create: {
     *     // ... data to create a VendorOperationalSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorOperationalSetting we want to update
     *   }
     * })
     */
    upsert<T extends VendorOperationalSettingUpsertArgs>(args: SelectSubset<T, VendorOperationalSettingUpsertArgs<ExtArgs>>): Prisma__VendorOperationalSettingClient<$Result.GetResult<Prisma.$VendorOperationalSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorOperationalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorOperationalSettingCountArgs} args - Arguments to filter VendorOperationalSettings to count.
     * @example
     * // Count the number of VendorOperationalSettings
     * const count = await prisma.vendorOperationalSetting.count({
     *   where: {
     *     // ... the filter for the VendorOperationalSettings we want to count
     *   }
     * })
    **/
    count<T extends VendorOperationalSettingCountArgs>(
      args?: Subset<T, VendorOperationalSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorOperationalSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorOperationalSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorOperationalSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorOperationalSettingAggregateArgs>(args: Subset<T, VendorOperationalSettingAggregateArgs>): Prisma.PrismaPromise<GetVendorOperationalSettingAggregateType<T>>

    /**
     * Group by VendorOperationalSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorOperationalSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorOperationalSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorOperationalSettingGroupByArgs['orderBy'] }
        : { orderBy?: VendorOperationalSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorOperationalSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorOperationalSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorOperationalSetting model
   */
  readonly fields: VendorOperationalSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorOperationalSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorOperationalSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorOperationalSetting model
   */
  interface VendorOperationalSettingFieldRefs {
    readonly id: FieldRef<"VendorOperationalSetting", 'String'>
    readonly vendor_id: FieldRef<"VendorOperationalSetting", 'String'>
    readonly status: FieldRef<"VendorOperationalSetting", 'String'>
    readonly shipping_method: FieldRef<"VendorOperationalSetting", 'String'>
    readonly lead_time: FieldRef<"VendorOperationalSetting", 'Int'>
    readonly minimum_order_quantity: FieldRef<"VendorOperationalSetting", 'Int'>
    readonly categories: FieldRef<"VendorOperationalSetting", 'String[]'>
    readonly manager: FieldRef<"VendorOperationalSetting", 'String'>
    readonly created_at: FieldRef<"VendorOperationalSetting", 'DateTime'>
    readonly updated_at: FieldRef<"VendorOperationalSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorOperationalSetting findUnique
   */
  export type VendorOperationalSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * Filter, which VendorOperationalSetting to fetch.
     */
    where: VendorOperationalSettingWhereUniqueInput
  }

  /**
   * VendorOperationalSetting findUniqueOrThrow
   */
  export type VendorOperationalSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * Filter, which VendorOperationalSetting to fetch.
     */
    where: VendorOperationalSettingWhereUniqueInput
  }

  /**
   * VendorOperationalSetting findFirst
   */
  export type VendorOperationalSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * Filter, which VendorOperationalSetting to fetch.
     */
    where?: VendorOperationalSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorOperationalSettings to fetch.
     */
    orderBy?: VendorOperationalSettingOrderByWithRelationInput | VendorOperationalSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorOperationalSettings.
     */
    cursor?: VendorOperationalSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorOperationalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorOperationalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorOperationalSettings.
     */
    distinct?: VendorOperationalSettingScalarFieldEnum | VendorOperationalSettingScalarFieldEnum[]
  }

  /**
   * VendorOperationalSetting findFirstOrThrow
   */
  export type VendorOperationalSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * Filter, which VendorOperationalSetting to fetch.
     */
    where?: VendorOperationalSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorOperationalSettings to fetch.
     */
    orderBy?: VendorOperationalSettingOrderByWithRelationInput | VendorOperationalSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorOperationalSettings.
     */
    cursor?: VendorOperationalSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorOperationalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorOperationalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorOperationalSettings.
     */
    distinct?: VendorOperationalSettingScalarFieldEnum | VendorOperationalSettingScalarFieldEnum[]
  }

  /**
   * VendorOperationalSetting findMany
   */
  export type VendorOperationalSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * Filter, which VendorOperationalSettings to fetch.
     */
    where?: VendorOperationalSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorOperationalSettings to fetch.
     */
    orderBy?: VendorOperationalSettingOrderByWithRelationInput | VendorOperationalSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorOperationalSettings.
     */
    cursor?: VendorOperationalSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorOperationalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorOperationalSettings.
     */
    skip?: number
    distinct?: VendorOperationalSettingScalarFieldEnum | VendorOperationalSettingScalarFieldEnum[]
  }

  /**
   * VendorOperationalSetting create
   */
  export type VendorOperationalSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorOperationalSetting.
     */
    data: XOR<VendorOperationalSettingCreateInput, VendorOperationalSettingUncheckedCreateInput>
  }

  /**
   * VendorOperationalSetting createMany
   */
  export type VendorOperationalSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorOperationalSettings.
     */
    data: VendorOperationalSettingCreateManyInput | VendorOperationalSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorOperationalSetting createManyAndReturn
   */
  export type VendorOperationalSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * The data used to create many VendorOperationalSettings.
     */
    data: VendorOperationalSettingCreateManyInput | VendorOperationalSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorOperationalSetting update
   */
  export type VendorOperationalSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorOperationalSetting.
     */
    data: XOR<VendorOperationalSettingUpdateInput, VendorOperationalSettingUncheckedUpdateInput>
    /**
     * Choose, which VendorOperationalSetting to update.
     */
    where: VendorOperationalSettingWhereUniqueInput
  }

  /**
   * VendorOperationalSetting updateMany
   */
  export type VendorOperationalSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorOperationalSettings.
     */
    data: XOR<VendorOperationalSettingUpdateManyMutationInput, VendorOperationalSettingUncheckedUpdateManyInput>
    /**
     * Filter which VendorOperationalSettings to update
     */
    where?: VendorOperationalSettingWhereInput
    /**
     * Limit how many VendorOperationalSettings to update.
     */
    limit?: number
  }

  /**
   * VendorOperationalSetting updateManyAndReturn
   */
  export type VendorOperationalSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * The data used to update VendorOperationalSettings.
     */
    data: XOR<VendorOperationalSettingUpdateManyMutationInput, VendorOperationalSettingUncheckedUpdateManyInput>
    /**
     * Filter which VendorOperationalSettings to update
     */
    where?: VendorOperationalSettingWhereInput
    /**
     * Limit how many VendorOperationalSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorOperationalSetting upsert
   */
  export type VendorOperationalSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorOperationalSetting to update in case it exists.
     */
    where: VendorOperationalSettingWhereUniqueInput
    /**
     * In case the VendorOperationalSetting found by the `where` argument doesn't exist, create a new VendorOperationalSetting with this data.
     */
    create: XOR<VendorOperationalSettingCreateInput, VendorOperationalSettingUncheckedCreateInput>
    /**
     * In case the VendorOperationalSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorOperationalSettingUpdateInput, VendorOperationalSettingUncheckedUpdateInput>
  }

  /**
   * VendorOperationalSetting delete
   */
  export type VendorOperationalSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
    /**
     * Filter which VendorOperationalSetting to delete.
     */
    where: VendorOperationalSettingWhereUniqueInput
  }

  /**
   * VendorOperationalSetting deleteMany
   */
  export type VendorOperationalSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorOperationalSettings to delete
     */
    where?: VendorOperationalSettingWhereInput
    /**
     * Limit how many VendorOperationalSettings to delete.
     */
    limit?: number
  }

  /**
   * VendorOperationalSetting without action
   */
  export type VendorOperationalSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorOperationalSetting
     */
    select?: VendorOperationalSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorOperationalSetting
     */
    omit?: VendorOperationalSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorOperationalSettingInclude<ExtArgs> | null
  }


  /**
   * Model VendorMetadata
   */

  export type AggregateVendorMetadata = {
    _count: VendorMetadataCountAggregateOutputType | null
    _avg: VendorMetadataAvgAggregateOutputType | null
    _sum: VendorMetadataSumAggregateOutputType | null
    _min: VendorMetadataMinAggregateOutputType | null
    _max: VendorMetadataMaxAggregateOutputType | null
  }

  export type VendorMetadataAvgAggregateOutputType = {
    score: number | null
  }

  export type VendorMetadataSumAggregateOutputType = {
    score: number | null
  }

  export type VendorMetadataMinAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    notes: string | null
    score: number | null
    last_order: Date | null
    next_review: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorMetadataMaxAggregateOutputType = {
    id: string | null
    vendor_id: string | null
    notes: string | null
    score: number | null
    last_order: Date | null
    next_review: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorMetadataCountAggregateOutputType = {
    id: number
    vendor_id: number
    notes: number
    tags: number
    score: number
    last_order: number
    next_review: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorMetadataAvgAggregateInputType = {
    score?: true
  }

  export type VendorMetadataSumAggregateInputType = {
    score?: true
  }

  export type VendorMetadataMinAggregateInputType = {
    id?: true
    vendor_id?: true
    notes?: true
    score?: true
    last_order?: true
    next_review?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorMetadataMaxAggregateInputType = {
    id?: true
    vendor_id?: true
    notes?: true
    score?: true
    last_order?: true
    next_review?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorMetadataCountAggregateInputType = {
    id?: true
    vendor_id?: true
    notes?: true
    tags?: true
    score?: true
    last_order?: true
    next_review?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorMetadata to aggregate.
     */
    where?: VendorMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorMetadata to fetch.
     */
    orderBy?: VendorMetadataOrderByWithRelationInput | VendorMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorMetadata
    **/
    _count?: true | VendorMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMetadataMaxAggregateInputType
  }

  export type GetVendorMetadataAggregateType<T extends VendorMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorMetadata[P]>
      : GetScalarType<T[P], AggregateVendorMetadata[P]>
  }




  export type VendorMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorMetadataWhereInput
    orderBy?: VendorMetadataOrderByWithAggregationInput | VendorMetadataOrderByWithAggregationInput[]
    by: VendorMetadataScalarFieldEnum[] | VendorMetadataScalarFieldEnum
    having?: VendorMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorMetadataCountAggregateInputType | true
    _avg?: VendorMetadataAvgAggregateInputType
    _sum?: VendorMetadataSumAggregateInputType
    _min?: VendorMetadataMinAggregateInputType
    _max?: VendorMetadataMaxAggregateInputType
  }

  export type VendorMetadataGroupByOutputType = {
    id: string
    vendor_id: string
    notes: string | null
    tags: string[]
    score: number | null
    last_order: Date
    next_review: Date | null
    created_at: Date
    updated_at: Date
    _count: VendorMetadataCountAggregateOutputType | null
    _avg: VendorMetadataAvgAggregateOutputType | null
    _sum: VendorMetadataSumAggregateOutputType | null
    _min: VendorMetadataMinAggregateOutputType | null
    _max: VendorMetadataMaxAggregateOutputType | null
  }

  type GetVendorMetadataGroupByPayload<T extends VendorMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], VendorMetadataGroupByOutputType[P]>
        }
      >
    >


  export type VendorMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    notes?: boolean
    tags?: boolean
    score?: boolean
    last_order?: boolean
    next_review?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorMetadata"]>

  export type VendorMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    notes?: boolean
    tags?: boolean
    score?: boolean
    last_order?: boolean
    next_review?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorMetadata"]>

  export type VendorMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_id?: boolean
    notes?: boolean
    tags?: boolean
    score?: boolean
    last_order?: boolean
    next_review?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorMetadata"]>

  export type VendorMetadataSelectScalar = {
    id?: boolean
    vendor_id?: boolean
    notes?: boolean
    tags?: boolean
    score?: boolean
    last_order?: boolean
    next_review?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_id" | "notes" | "tags" | "score" | "last_order" | "next_review" | "created_at" | "updated_at", ExtArgs["result"]["vendorMetadata"]>
  export type VendorMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorMetadata"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_id: string
      notes: string | null
      tags: string[]
      score: number | null
      last_order: Date
      next_review: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendorMetadata"]>
    composites: {}
  }

  type VendorMetadataGetPayload<S extends boolean | null | undefined | VendorMetadataDefaultArgs> = $Result.GetResult<Prisma.$VendorMetadataPayload, S>

  type VendorMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorMetadataCountAggregateInputType | true
    }

  export interface VendorMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorMetadata'], meta: { name: 'VendorMetadata' } }
    /**
     * Find zero or one VendorMetadata that matches the filter.
     * @param {VendorMetadataFindUniqueArgs} args - Arguments to find a VendorMetadata
     * @example
     * // Get one VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorMetadataFindUniqueArgs>(args: SelectSubset<T, VendorMetadataFindUniqueArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorMetadataFindUniqueOrThrowArgs} args - Arguments to find a VendorMetadata
     * @example
     * // Get one VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorMetadataFindFirstArgs} args - Arguments to find a VendorMetadata
     * @example
     * // Get one VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorMetadataFindFirstArgs>(args?: SelectSubset<T, VendorMetadataFindFirstArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorMetadataFindFirstOrThrowArgs} args - Arguments to find a VendorMetadata
     * @example
     * // Get one VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.findMany()
     * 
     * // Get first 10 VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorMetadataWithIdOnly = await prisma.vendorMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorMetadataFindManyArgs>(args?: SelectSubset<T, VendorMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorMetadata.
     * @param {VendorMetadataCreateArgs} args - Arguments to create a VendorMetadata.
     * @example
     * // Create one VendorMetadata
     * const VendorMetadata = await prisma.vendorMetadata.create({
     *   data: {
     *     // ... data to create a VendorMetadata
     *   }
     * })
     * 
     */
    create<T extends VendorMetadataCreateArgs>(args: SelectSubset<T, VendorMetadataCreateArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorMetadata.
     * @param {VendorMetadataCreateManyArgs} args - Arguments to create many VendorMetadata.
     * @example
     * // Create many VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorMetadataCreateManyArgs>(args?: SelectSubset<T, VendorMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorMetadata and returns the data saved in the database.
     * @param {VendorMetadataCreateManyAndReturnArgs} args - Arguments to create many VendorMetadata.
     * @example
     * // Create many VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorMetadata and only return the `id`
     * const vendorMetadataWithIdOnly = await prisma.vendorMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorMetadata.
     * @param {VendorMetadataDeleteArgs} args - Arguments to delete one VendorMetadata.
     * @example
     * // Delete one VendorMetadata
     * const VendorMetadata = await prisma.vendorMetadata.delete({
     *   where: {
     *     // ... filter to delete one VendorMetadata
     *   }
     * })
     * 
     */
    delete<T extends VendorMetadataDeleteArgs>(args: SelectSubset<T, VendorMetadataDeleteArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorMetadata.
     * @param {VendorMetadataUpdateArgs} args - Arguments to update one VendorMetadata.
     * @example
     * // Update one VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorMetadataUpdateArgs>(args: SelectSubset<T, VendorMetadataUpdateArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorMetadata.
     * @param {VendorMetadataDeleteManyArgs} args - Arguments to filter VendorMetadata to delete.
     * @example
     * // Delete a few VendorMetadata
     * const { count } = await prisma.vendorMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorMetadataDeleteManyArgs>(args?: SelectSubset<T, VendorMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorMetadataUpdateManyArgs>(args: SelectSubset<T, VendorMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorMetadata and returns the data updated in the database.
     * @param {VendorMetadataUpdateManyAndReturnArgs} args - Arguments to update many VendorMetadata.
     * @example
     * // Update many VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorMetadata and only return the `id`
     * const vendorMetadataWithIdOnly = await prisma.vendorMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorMetadata.
     * @param {VendorMetadataUpsertArgs} args - Arguments to update or create a VendorMetadata.
     * @example
     * // Update or create a VendorMetadata
     * const vendorMetadata = await prisma.vendorMetadata.upsert({
     *   create: {
     *     // ... data to create a VendorMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorMetadata we want to update
     *   }
     * })
     */
    upsert<T extends VendorMetadataUpsertArgs>(args: SelectSubset<T, VendorMetadataUpsertArgs<ExtArgs>>): Prisma__VendorMetadataClient<$Result.GetResult<Prisma.$VendorMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorMetadataCountArgs} args - Arguments to filter VendorMetadata to count.
     * @example
     * // Count the number of VendorMetadata
     * const count = await prisma.vendorMetadata.count({
     *   where: {
     *     // ... the filter for the VendorMetadata we want to count
     *   }
     * })
    **/
    count<T extends VendorMetadataCountArgs>(
      args?: Subset<T, VendorMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorMetadataAggregateArgs>(args: Subset<T, VendorMetadataAggregateArgs>): Prisma.PrismaPromise<GetVendorMetadataAggregateType<T>>

    /**
     * Group by VendorMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorMetadataGroupByArgs['orderBy'] }
        : { orderBy?: VendorMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorMetadata model
   */
  readonly fields: VendorMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorMetadata model
   */
  interface VendorMetadataFieldRefs {
    readonly id: FieldRef<"VendorMetadata", 'String'>
    readonly vendor_id: FieldRef<"VendorMetadata", 'String'>
    readonly notes: FieldRef<"VendorMetadata", 'String'>
    readonly tags: FieldRef<"VendorMetadata", 'String[]'>
    readonly score: FieldRef<"VendorMetadata", 'Int'>
    readonly last_order: FieldRef<"VendorMetadata", 'DateTime'>
    readonly next_review: FieldRef<"VendorMetadata", 'DateTime'>
    readonly created_at: FieldRef<"VendorMetadata", 'DateTime'>
    readonly updated_at: FieldRef<"VendorMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorMetadata findUnique
   */
  export type VendorMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VendorMetadata to fetch.
     */
    where: VendorMetadataWhereUniqueInput
  }

  /**
   * VendorMetadata findUniqueOrThrow
   */
  export type VendorMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VendorMetadata to fetch.
     */
    where: VendorMetadataWhereUniqueInput
  }

  /**
   * VendorMetadata findFirst
   */
  export type VendorMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VendorMetadata to fetch.
     */
    where?: VendorMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorMetadata to fetch.
     */
    orderBy?: VendorMetadataOrderByWithRelationInput | VendorMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorMetadata.
     */
    cursor?: VendorMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorMetadata.
     */
    distinct?: VendorMetadataScalarFieldEnum | VendorMetadataScalarFieldEnum[]
  }

  /**
   * VendorMetadata findFirstOrThrow
   */
  export type VendorMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VendorMetadata to fetch.
     */
    where?: VendorMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorMetadata to fetch.
     */
    orderBy?: VendorMetadataOrderByWithRelationInput | VendorMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorMetadata.
     */
    cursor?: VendorMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorMetadata.
     */
    distinct?: VendorMetadataScalarFieldEnum | VendorMetadataScalarFieldEnum[]
  }

  /**
   * VendorMetadata findMany
   */
  export type VendorMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VendorMetadata to fetch.
     */
    where?: VendorMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorMetadata to fetch.
     */
    orderBy?: VendorMetadataOrderByWithRelationInput | VendorMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorMetadata.
     */
    cursor?: VendorMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorMetadata.
     */
    skip?: number
    distinct?: VendorMetadataScalarFieldEnum | VendorMetadataScalarFieldEnum[]
  }

  /**
   * VendorMetadata create
   */
  export type VendorMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorMetadata.
     */
    data: XOR<VendorMetadataCreateInput, VendorMetadataUncheckedCreateInput>
  }

  /**
   * VendorMetadata createMany
   */
  export type VendorMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorMetadata.
     */
    data: VendorMetadataCreateManyInput | VendorMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorMetadata createManyAndReturn
   */
  export type VendorMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many VendorMetadata.
     */
    data: VendorMetadataCreateManyInput | VendorMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorMetadata update
   */
  export type VendorMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorMetadata.
     */
    data: XOR<VendorMetadataUpdateInput, VendorMetadataUncheckedUpdateInput>
    /**
     * Choose, which VendorMetadata to update.
     */
    where: VendorMetadataWhereUniqueInput
  }

  /**
   * VendorMetadata updateMany
   */
  export type VendorMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorMetadata.
     */
    data: XOR<VendorMetadataUpdateManyMutationInput, VendorMetadataUncheckedUpdateManyInput>
    /**
     * Filter which VendorMetadata to update
     */
    where?: VendorMetadataWhereInput
    /**
     * Limit how many VendorMetadata to update.
     */
    limit?: number
  }

  /**
   * VendorMetadata updateManyAndReturn
   */
  export type VendorMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * The data used to update VendorMetadata.
     */
    data: XOR<VendorMetadataUpdateManyMutationInput, VendorMetadataUncheckedUpdateManyInput>
    /**
     * Filter which VendorMetadata to update
     */
    where?: VendorMetadataWhereInput
    /**
     * Limit how many VendorMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorMetadata upsert
   */
  export type VendorMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorMetadata to update in case it exists.
     */
    where: VendorMetadataWhereUniqueInput
    /**
     * In case the VendorMetadata found by the `where` argument doesn't exist, create a new VendorMetadata with this data.
     */
    create: XOR<VendorMetadataCreateInput, VendorMetadataUncheckedCreateInput>
    /**
     * In case the VendorMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorMetadataUpdateInput, VendorMetadataUncheckedUpdateInput>
  }

  /**
   * VendorMetadata delete
   */
  export type VendorMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
    /**
     * Filter which VendorMetadata to delete.
     */
    where: VendorMetadataWhereUniqueInput
  }

  /**
   * VendorMetadata deleteMany
   */
  export type VendorMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorMetadata to delete
     */
    where?: VendorMetadataWhereInput
    /**
     * Limit how many VendorMetadata to delete.
     */
    limit?: number
  }

  /**
   * VendorMetadata without action
   */
  export type VendorMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorMetadata
     */
    select?: VendorMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorMetadata
     */
    omit?: VendorMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorMetadataInclude<ExtArgs> | null
  }


  /**
   * Model company_vendor_capabilities
   */

  export type AggregateCompany_vendor_capabilities = {
    _count: Company_vendor_capabilitiesCountAggregateOutputType | null
    _min: Company_vendor_capabilitiesMinAggregateOutputType | null
    _max: Company_vendor_capabilitiesMaxAggregateOutputType | null
  }

  export type Company_vendor_capabilitiesMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_vendor_capabilitiesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_vendor_capabilitiesCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_vendor_capabilitiesMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_vendor_capabilitiesMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_vendor_capabilitiesCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_vendor_capabilitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_vendor_capabilities to aggregate.
     */
    where?: company_vendor_capabilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_capabilities to fetch.
     */
    orderBy?: company_vendor_capabilitiesOrderByWithRelationInput | company_vendor_capabilitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_vendor_capabilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_vendor_capabilities
    **/
    _count?: true | Company_vendor_capabilitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_vendor_capabilitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_vendor_capabilitiesMaxAggregateInputType
  }

  export type GetCompany_vendor_capabilitiesAggregateType<T extends Company_vendor_capabilitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_vendor_capabilities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_vendor_capabilities[P]>
      : GetScalarType<T[P], AggregateCompany_vendor_capabilities[P]>
  }




  export type company_vendor_capabilitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_vendor_capabilitiesWhereInput
    orderBy?: company_vendor_capabilitiesOrderByWithAggregationInput | company_vendor_capabilitiesOrderByWithAggregationInput[]
    by: Company_vendor_capabilitiesScalarFieldEnum[] | Company_vendor_capabilitiesScalarFieldEnum
    having?: company_vendor_capabilitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_vendor_capabilitiesCountAggregateInputType | true
    _min?: Company_vendor_capabilitiesMinAggregateInputType
    _max?: Company_vendor_capabilitiesMaxAggregateInputType
  }

  export type Company_vendor_capabilitiesGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Company_vendor_capabilitiesCountAggregateOutputType | null
    _min: Company_vendor_capabilitiesMinAggregateOutputType | null
    _max: Company_vendor_capabilitiesMaxAggregateOutputType | null
  }

  type GetCompany_vendor_capabilitiesGroupByPayload<T extends company_vendor_capabilitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_vendor_capabilitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_vendor_capabilitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_vendor_capabilitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Company_vendor_capabilitiesGroupByOutputType[P]>
        }
      >
    >


  export type company_vendor_capabilitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    subCategories?: boolean | company_vendor_capabilities$subCategoriesArgs<ExtArgs>
    _count?: boolean | Company_vendor_capabilitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_vendor_capabilities"]>

  export type company_vendor_capabilitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company_vendor_capabilities"]>

  export type company_vendor_capabilitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company_vendor_capabilities"]>

  export type company_vendor_capabilitiesSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_vendor_capabilitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["company_vendor_capabilities"]>
  export type company_vendor_capabilitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | company_vendor_capabilities$subCategoriesArgs<ExtArgs>
    _count?: boolean | Company_vendor_capabilitiesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type company_vendor_capabilitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type company_vendor_capabilitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $company_vendor_capabilitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_vendor_capabilities"
    objects: {
      subCategories: Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["company_vendor_capabilities"]>
    composites: {}
  }

  type company_vendor_capabilitiesGetPayload<S extends boolean | null | undefined | company_vendor_capabilitiesDefaultArgs> = $Result.GetResult<Prisma.$company_vendor_capabilitiesPayload, S>

  type company_vendor_capabilitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_vendor_capabilitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_vendor_capabilitiesCountAggregateInputType | true
    }

  export interface company_vendor_capabilitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_vendor_capabilities'], meta: { name: 'company_vendor_capabilities' } }
    /**
     * Find zero or one Company_vendor_capabilities that matches the filter.
     * @param {company_vendor_capabilitiesFindUniqueArgs} args - Arguments to find a Company_vendor_capabilities
     * @example
     * // Get one Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_vendor_capabilitiesFindUniqueArgs>(args: SelectSubset<T, company_vendor_capabilitiesFindUniqueArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_vendor_capabilities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_vendor_capabilitiesFindUniqueOrThrowArgs} args - Arguments to find a Company_vendor_capabilities
     * @example
     * // Get one Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_vendor_capabilitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, company_vendor_capabilitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_vendor_capabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capabilitiesFindFirstArgs} args - Arguments to find a Company_vendor_capabilities
     * @example
     * // Get one Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_vendor_capabilitiesFindFirstArgs>(args?: SelectSubset<T, company_vendor_capabilitiesFindFirstArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_vendor_capabilities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capabilitiesFindFirstOrThrowArgs} args - Arguments to find a Company_vendor_capabilities
     * @example
     * // Get one Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_vendor_capabilitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, company_vendor_capabilitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_vendor_capabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capabilitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.findMany()
     * 
     * // Get first 10 Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_vendor_capabilitiesWithIdOnly = await prisma.company_vendor_capabilities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_vendor_capabilitiesFindManyArgs>(args?: SelectSubset<T, company_vendor_capabilitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_vendor_capabilities.
     * @param {company_vendor_capabilitiesCreateArgs} args - Arguments to create a Company_vendor_capabilities.
     * @example
     * // Create one Company_vendor_capabilities
     * const Company_vendor_capabilities = await prisma.company_vendor_capabilities.create({
     *   data: {
     *     // ... data to create a Company_vendor_capabilities
     *   }
     * })
     * 
     */
    create<T extends company_vendor_capabilitiesCreateArgs>(args: SelectSubset<T, company_vendor_capabilitiesCreateArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_vendor_capabilities.
     * @param {company_vendor_capabilitiesCreateManyArgs} args - Arguments to create many Company_vendor_capabilities.
     * @example
     * // Create many Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_vendor_capabilitiesCreateManyArgs>(args?: SelectSubset<T, company_vendor_capabilitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_vendor_capabilities and returns the data saved in the database.
     * @param {company_vendor_capabilitiesCreateManyAndReturnArgs} args - Arguments to create many Company_vendor_capabilities.
     * @example
     * // Create many Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_vendor_capabilities and only return the `id`
     * const company_vendor_capabilitiesWithIdOnly = await prisma.company_vendor_capabilities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_vendor_capabilitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, company_vendor_capabilitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_vendor_capabilities.
     * @param {company_vendor_capabilitiesDeleteArgs} args - Arguments to delete one Company_vendor_capabilities.
     * @example
     * // Delete one Company_vendor_capabilities
     * const Company_vendor_capabilities = await prisma.company_vendor_capabilities.delete({
     *   where: {
     *     // ... filter to delete one Company_vendor_capabilities
     *   }
     * })
     * 
     */
    delete<T extends company_vendor_capabilitiesDeleteArgs>(args: SelectSubset<T, company_vendor_capabilitiesDeleteArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_vendor_capabilities.
     * @param {company_vendor_capabilitiesUpdateArgs} args - Arguments to update one Company_vendor_capabilities.
     * @example
     * // Update one Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_vendor_capabilitiesUpdateArgs>(args: SelectSubset<T, company_vendor_capabilitiesUpdateArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_vendor_capabilities.
     * @param {company_vendor_capabilitiesDeleteManyArgs} args - Arguments to filter Company_vendor_capabilities to delete.
     * @example
     * // Delete a few Company_vendor_capabilities
     * const { count } = await prisma.company_vendor_capabilities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_vendor_capabilitiesDeleteManyArgs>(args?: SelectSubset<T, company_vendor_capabilitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_vendor_capabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capabilitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_vendor_capabilitiesUpdateManyArgs>(args: SelectSubset<T, company_vendor_capabilitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_vendor_capabilities and returns the data updated in the database.
     * @param {company_vendor_capabilitiesUpdateManyAndReturnArgs} args - Arguments to update many Company_vendor_capabilities.
     * @example
     * // Update many Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_vendor_capabilities and only return the `id`
     * const company_vendor_capabilitiesWithIdOnly = await prisma.company_vendor_capabilities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_vendor_capabilitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, company_vendor_capabilitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_vendor_capabilities.
     * @param {company_vendor_capabilitiesUpsertArgs} args - Arguments to update or create a Company_vendor_capabilities.
     * @example
     * // Update or create a Company_vendor_capabilities
     * const company_vendor_capabilities = await prisma.company_vendor_capabilities.upsert({
     *   create: {
     *     // ... data to create a Company_vendor_capabilities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_vendor_capabilities we want to update
     *   }
     * })
     */
    upsert<T extends company_vendor_capabilitiesUpsertArgs>(args: SelectSubset<T, company_vendor_capabilitiesUpsertArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_vendor_capabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capabilitiesCountArgs} args - Arguments to filter Company_vendor_capabilities to count.
     * @example
     * // Count the number of Company_vendor_capabilities
     * const count = await prisma.company_vendor_capabilities.count({
     *   where: {
     *     // ... the filter for the Company_vendor_capabilities we want to count
     *   }
     * })
    **/
    count<T extends company_vendor_capabilitiesCountArgs>(
      args?: Subset<T, company_vendor_capabilitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_vendor_capabilitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_vendor_capabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_vendor_capabilitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_vendor_capabilitiesAggregateArgs>(args: Subset<T, Company_vendor_capabilitiesAggregateArgs>): Prisma.PrismaPromise<GetCompany_vendor_capabilitiesAggregateType<T>>

    /**
     * Group by Company_vendor_capabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capabilitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_vendor_capabilitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_vendor_capabilitiesGroupByArgs['orderBy'] }
        : { orderBy?: company_vendor_capabilitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_vendor_capabilitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_vendor_capabilitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_vendor_capabilities model
   */
  readonly fields: company_vendor_capabilitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_vendor_capabilities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_vendor_capabilitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subCategories<T extends company_vendor_capabilities$subCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, company_vendor_capabilities$subCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_vendor_capabilities model
   */
  interface company_vendor_capabilitiesFieldRefs {
    readonly id: FieldRef<"company_vendor_capabilities", 'String'>
    readonly name: FieldRef<"company_vendor_capabilities", 'String'>
    readonly is_active: FieldRef<"company_vendor_capabilities", 'Boolean'>
    readonly created_at: FieldRef<"company_vendor_capabilities", 'DateTime'>
    readonly updated_at: FieldRef<"company_vendor_capabilities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_vendor_capabilities findUnique
   */
  export type company_vendor_capabilitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capabilities to fetch.
     */
    where: company_vendor_capabilitiesWhereUniqueInput
  }

  /**
   * company_vendor_capabilities findUniqueOrThrow
   */
  export type company_vendor_capabilitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capabilities to fetch.
     */
    where: company_vendor_capabilitiesWhereUniqueInput
  }

  /**
   * company_vendor_capabilities findFirst
   */
  export type company_vendor_capabilitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capabilities to fetch.
     */
    where?: company_vendor_capabilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_capabilities to fetch.
     */
    orderBy?: company_vendor_capabilitiesOrderByWithRelationInput | company_vendor_capabilitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_vendor_capabilities.
     */
    cursor?: company_vendor_capabilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_vendor_capabilities.
     */
    distinct?: Company_vendor_capabilitiesScalarFieldEnum | Company_vendor_capabilitiesScalarFieldEnum[]
  }

  /**
   * company_vendor_capabilities findFirstOrThrow
   */
  export type company_vendor_capabilitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capabilities to fetch.
     */
    where?: company_vendor_capabilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_capabilities to fetch.
     */
    orderBy?: company_vendor_capabilitiesOrderByWithRelationInput | company_vendor_capabilitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_vendor_capabilities.
     */
    cursor?: company_vendor_capabilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_vendor_capabilities.
     */
    distinct?: Company_vendor_capabilitiesScalarFieldEnum | Company_vendor_capabilitiesScalarFieldEnum[]
  }

  /**
   * company_vendor_capabilities findMany
   */
  export type company_vendor_capabilitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capabilities to fetch.
     */
    where?: company_vendor_capabilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_capabilities to fetch.
     */
    orderBy?: company_vendor_capabilitiesOrderByWithRelationInput | company_vendor_capabilitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_vendor_capabilities.
     */
    cursor?: company_vendor_capabilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_capabilities.
     */
    skip?: number
    distinct?: Company_vendor_capabilitiesScalarFieldEnum | Company_vendor_capabilitiesScalarFieldEnum[]
  }

  /**
   * company_vendor_capabilities create
   */
  export type company_vendor_capabilitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a company_vendor_capabilities.
     */
    data: XOR<company_vendor_capabilitiesCreateInput, company_vendor_capabilitiesUncheckedCreateInput>
  }

  /**
   * company_vendor_capabilities createMany
   */
  export type company_vendor_capabilitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_vendor_capabilities.
     */
    data: company_vendor_capabilitiesCreateManyInput | company_vendor_capabilitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_vendor_capabilities createManyAndReturn
   */
  export type company_vendor_capabilitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * The data used to create many company_vendor_capabilities.
     */
    data: company_vendor_capabilitiesCreateManyInput | company_vendor_capabilitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_vendor_capabilities update
   */
  export type company_vendor_capabilitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a company_vendor_capabilities.
     */
    data: XOR<company_vendor_capabilitiesUpdateInput, company_vendor_capabilitiesUncheckedUpdateInput>
    /**
     * Choose, which company_vendor_capabilities to update.
     */
    where: company_vendor_capabilitiesWhereUniqueInput
  }

  /**
   * company_vendor_capabilities updateMany
   */
  export type company_vendor_capabilitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_vendor_capabilities.
     */
    data: XOR<company_vendor_capabilitiesUpdateManyMutationInput, company_vendor_capabilitiesUncheckedUpdateManyInput>
    /**
     * Filter which company_vendor_capabilities to update
     */
    where?: company_vendor_capabilitiesWhereInput
    /**
     * Limit how many company_vendor_capabilities to update.
     */
    limit?: number
  }

  /**
   * company_vendor_capabilities updateManyAndReturn
   */
  export type company_vendor_capabilitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * The data used to update company_vendor_capabilities.
     */
    data: XOR<company_vendor_capabilitiesUpdateManyMutationInput, company_vendor_capabilitiesUncheckedUpdateManyInput>
    /**
     * Filter which company_vendor_capabilities to update
     */
    where?: company_vendor_capabilitiesWhereInput
    /**
     * Limit how many company_vendor_capabilities to update.
     */
    limit?: number
  }

  /**
   * company_vendor_capabilities upsert
   */
  export type company_vendor_capabilitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the company_vendor_capabilities to update in case it exists.
     */
    where: company_vendor_capabilitiesWhereUniqueInput
    /**
     * In case the company_vendor_capabilities found by the `where` argument doesn't exist, create a new company_vendor_capabilities with this data.
     */
    create: XOR<company_vendor_capabilitiesCreateInput, company_vendor_capabilitiesUncheckedCreateInput>
    /**
     * In case the company_vendor_capabilities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_vendor_capabilitiesUpdateInput, company_vendor_capabilitiesUncheckedUpdateInput>
  }

  /**
   * company_vendor_capabilities delete
   */
  export type company_vendor_capabilitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
    /**
     * Filter which company_vendor_capabilities to delete.
     */
    where: company_vendor_capabilitiesWhereUniqueInput
  }

  /**
   * company_vendor_capabilities deleteMany
   */
  export type company_vendor_capabilitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_vendor_capabilities to delete
     */
    where?: company_vendor_capabilitiesWhereInput
    /**
     * Limit how many company_vendor_capabilities to delete.
     */
    limit?: number
  }

  /**
   * company_vendor_capabilities.subCategories
   */
  export type company_vendor_capabilities$subCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    where?: company_vendor_capability_sub_categoriesWhereInput
    orderBy?: company_vendor_capability_sub_categoriesOrderByWithRelationInput | company_vendor_capability_sub_categoriesOrderByWithRelationInput[]
    cursor?: company_vendor_capability_sub_categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_vendor_capability_sub_categoriesScalarFieldEnum | Company_vendor_capability_sub_categoriesScalarFieldEnum[]
  }

  /**
   * company_vendor_capabilities without action
   */
  export type company_vendor_capabilitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capabilities
     */
    select?: company_vendor_capabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capabilities
     */
    omit?: company_vendor_capabilitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capabilitiesInclude<ExtArgs> | null
  }


  /**
   * Model company_vendor_capability_sub_categories
   */

  export type AggregateCompany_vendor_capability_sub_categories = {
    _count: Company_vendor_capability_sub_categoriesCountAggregateOutputType | null
    _min: Company_vendor_capability_sub_categoriesMinAggregateOutputType | null
    _max: Company_vendor_capability_sub_categoriesMaxAggregateOutputType | null
  }

  export type Company_vendor_capability_sub_categoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    vendor_capability_id: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_vendor_capability_sub_categoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    vendor_capability_id: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_vendor_capability_sub_categoriesCountAggregateOutputType = {
    id: number
    name: number
    vendor_capability_id: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_vendor_capability_sub_categoriesMinAggregateInputType = {
    id?: true
    name?: true
    vendor_capability_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_vendor_capability_sub_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
    vendor_capability_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_vendor_capability_sub_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    vendor_capability_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_vendor_capability_sub_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_vendor_capability_sub_categories to aggregate.
     */
    where?: company_vendor_capability_sub_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_capability_sub_categories to fetch.
     */
    orderBy?: company_vendor_capability_sub_categoriesOrderByWithRelationInput | company_vendor_capability_sub_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_vendor_capability_sub_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_capability_sub_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_capability_sub_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_vendor_capability_sub_categories
    **/
    _count?: true | Company_vendor_capability_sub_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_vendor_capability_sub_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_vendor_capability_sub_categoriesMaxAggregateInputType
  }

  export type GetCompany_vendor_capability_sub_categoriesAggregateType<T extends Company_vendor_capability_sub_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_vendor_capability_sub_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_vendor_capability_sub_categories[P]>
      : GetScalarType<T[P], AggregateCompany_vendor_capability_sub_categories[P]>
  }




  export type company_vendor_capability_sub_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_vendor_capability_sub_categoriesWhereInput
    orderBy?: company_vendor_capability_sub_categoriesOrderByWithAggregationInput | company_vendor_capability_sub_categoriesOrderByWithAggregationInput[]
    by: Company_vendor_capability_sub_categoriesScalarFieldEnum[] | Company_vendor_capability_sub_categoriesScalarFieldEnum
    having?: company_vendor_capability_sub_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_vendor_capability_sub_categoriesCountAggregateInputType | true
    _min?: Company_vendor_capability_sub_categoriesMinAggregateInputType
    _max?: Company_vendor_capability_sub_categoriesMaxAggregateInputType
  }

  export type Company_vendor_capability_sub_categoriesGroupByOutputType = {
    id: string
    name: string
    vendor_capability_id: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Company_vendor_capability_sub_categoriesCountAggregateOutputType | null
    _min: Company_vendor_capability_sub_categoriesMinAggregateOutputType | null
    _max: Company_vendor_capability_sub_categoriesMaxAggregateOutputType | null
  }

  type GetCompany_vendor_capability_sub_categoriesGroupByPayload<T extends company_vendor_capability_sub_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_vendor_capability_sub_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_vendor_capability_sub_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_vendor_capability_sub_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Company_vendor_capability_sub_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type company_vendor_capability_sub_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vendor_capability_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    capability?: boolean | company_vendor_capabilitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_vendor_capability_sub_categories"]>

  export type company_vendor_capability_sub_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vendor_capability_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    capability?: boolean | company_vendor_capabilitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_vendor_capability_sub_categories"]>

  export type company_vendor_capability_sub_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vendor_capability_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    capability?: boolean | company_vendor_capabilitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_vendor_capability_sub_categories"]>

  export type company_vendor_capability_sub_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    vendor_capability_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_vendor_capability_sub_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "vendor_capability_id" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["company_vendor_capability_sub_categories"]>
  export type company_vendor_capability_sub_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | company_vendor_capabilitiesDefaultArgs<ExtArgs>
  }
  export type company_vendor_capability_sub_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | company_vendor_capabilitiesDefaultArgs<ExtArgs>
  }
  export type company_vendor_capability_sub_categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | company_vendor_capabilitiesDefaultArgs<ExtArgs>
  }

  export type $company_vendor_capability_sub_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_vendor_capability_sub_categories"
    objects: {
      capability: Prisma.$company_vendor_capabilitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      vendor_capability_id: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["company_vendor_capability_sub_categories"]>
    composites: {}
  }

  type company_vendor_capability_sub_categoriesGetPayload<S extends boolean | null | undefined | company_vendor_capability_sub_categoriesDefaultArgs> = $Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload, S>

  type company_vendor_capability_sub_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_vendor_capability_sub_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_vendor_capability_sub_categoriesCountAggregateInputType | true
    }

  export interface company_vendor_capability_sub_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_vendor_capability_sub_categories'], meta: { name: 'company_vendor_capability_sub_categories' } }
    /**
     * Find zero or one Company_vendor_capability_sub_categories that matches the filter.
     * @param {company_vendor_capability_sub_categoriesFindUniqueArgs} args - Arguments to find a Company_vendor_capability_sub_categories
     * @example
     * // Get one Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_vendor_capability_sub_categoriesFindUniqueArgs>(args: SelectSubset<T, company_vendor_capability_sub_categoriesFindUniqueArgs<ExtArgs>>): Prisma__company_vendor_capability_sub_categoriesClient<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_vendor_capability_sub_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_vendor_capability_sub_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Company_vendor_capability_sub_categories
     * @example
     * // Get one Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_vendor_capability_sub_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, company_vendor_capability_sub_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_vendor_capability_sub_categoriesClient<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_vendor_capability_sub_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capability_sub_categoriesFindFirstArgs} args - Arguments to find a Company_vendor_capability_sub_categories
     * @example
     * // Get one Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_vendor_capability_sub_categoriesFindFirstArgs>(args?: SelectSubset<T, company_vendor_capability_sub_categoriesFindFirstArgs<ExtArgs>>): Prisma__company_vendor_capability_sub_categoriesClient<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_vendor_capability_sub_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capability_sub_categoriesFindFirstOrThrowArgs} args - Arguments to find a Company_vendor_capability_sub_categories
     * @example
     * // Get one Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_vendor_capability_sub_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, company_vendor_capability_sub_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_vendor_capability_sub_categoriesClient<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_vendor_capability_sub_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capability_sub_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.findMany()
     * 
     * // Get first 10 Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_vendor_capability_sub_categoriesWithIdOnly = await prisma.company_vendor_capability_sub_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_vendor_capability_sub_categoriesFindManyArgs>(args?: SelectSubset<T, company_vendor_capability_sub_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_vendor_capability_sub_categories.
     * @param {company_vendor_capability_sub_categoriesCreateArgs} args - Arguments to create a Company_vendor_capability_sub_categories.
     * @example
     * // Create one Company_vendor_capability_sub_categories
     * const Company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.create({
     *   data: {
     *     // ... data to create a Company_vendor_capability_sub_categories
     *   }
     * })
     * 
     */
    create<T extends company_vendor_capability_sub_categoriesCreateArgs>(args: SelectSubset<T, company_vendor_capability_sub_categoriesCreateArgs<ExtArgs>>): Prisma__company_vendor_capability_sub_categoriesClient<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_vendor_capability_sub_categories.
     * @param {company_vendor_capability_sub_categoriesCreateManyArgs} args - Arguments to create many Company_vendor_capability_sub_categories.
     * @example
     * // Create many Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_vendor_capability_sub_categoriesCreateManyArgs>(args?: SelectSubset<T, company_vendor_capability_sub_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_vendor_capability_sub_categories and returns the data saved in the database.
     * @param {company_vendor_capability_sub_categoriesCreateManyAndReturnArgs} args - Arguments to create many Company_vendor_capability_sub_categories.
     * @example
     * // Create many Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_vendor_capability_sub_categories and only return the `id`
     * const company_vendor_capability_sub_categoriesWithIdOnly = await prisma.company_vendor_capability_sub_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_vendor_capability_sub_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, company_vendor_capability_sub_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_vendor_capability_sub_categories.
     * @param {company_vendor_capability_sub_categoriesDeleteArgs} args - Arguments to delete one Company_vendor_capability_sub_categories.
     * @example
     * // Delete one Company_vendor_capability_sub_categories
     * const Company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.delete({
     *   where: {
     *     // ... filter to delete one Company_vendor_capability_sub_categories
     *   }
     * })
     * 
     */
    delete<T extends company_vendor_capability_sub_categoriesDeleteArgs>(args: SelectSubset<T, company_vendor_capability_sub_categoriesDeleteArgs<ExtArgs>>): Prisma__company_vendor_capability_sub_categoriesClient<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_vendor_capability_sub_categories.
     * @param {company_vendor_capability_sub_categoriesUpdateArgs} args - Arguments to update one Company_vendor_capability_sub_categories.
     * @example
     * // Update one Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_vendor_capability_sub_categoriesUpdateArgs>(args: SelectSubset<T, company_vendor_capability_sub_categoriesUpdateArgs<ExtArgs>>): Prisma__company_vendor_capability_sub_categoriesClient<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_vendor_capability_sub_categories.
     * @param {company_vendor_capability_sub_categoriesDeleteManyArgs} args - Arguments to filter Company_vendor_capability_sub_categories to delete.
     * @example
     * // Delete a few Company_vendor_capability_sub_categories
     * const { count } = await prisma.company_vendor_capability_sub_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_vendor_capability_sub_categoriesDeleteManyArgs>(args?: SelectSubset<T, company_vendor_capability_sub_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_vendor_capability_sub_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capability_sub_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_vendor_capability_sub_categoriesUpdateManyArgs>(args: SelectSubset<T, company_vendor_capability_sub_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_vendor_capability_sub_categories and returns the data updated in the database.
     * @param {company_vendor_capability_sub_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Company_vendor_capability_sub_categories.
     * @example
     * // Update many Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_vendor_capability_sub_categories and only return the `id`
     * const company_vendor_capability_sub_categoriesWithIdOnly = await prisma.company_vendor_capability_sub_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_vendor_capability_sub_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, company_vendor_capability_sub_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_vendor_capability_sub_categories.
     * @param {company_vendor_capability_sub_categoriesUpsertArgs} args - Arguments to update or create a Company_vendor_capability_sub_categories.
     * @example
     * // Update or create a Company_vendor_capability_sub_categories
     * const company_vendor_capability_sub_categories = await prisma.company_vendor_capability_sub_categories.upsert({
     *   create: {
     *     // ... data to create a Company_vendor_capability_sub_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_vendor_capability_sub_categories we want to update
     *   }
     * })
     */
    upsert<T extends company_vendor_capability_sub_categoriesUpsertArgs>(args: SelectSubset<T, company_vendor_capability_sub_categoriesUpsertArgs<ExtArgs>>): Prisma__company_vendor_capability_sub_categoriesClient<$Result.GetResult<Prisma.$company_vendor_capability_sub_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_vendor_capability_sub_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capability_sub_categoriesCountArgs} args - Arguments to filter Company_vendor_capability_sub_categories to count.
     * @example
     * // Count the number of Company_vendor_capability_sub_categories
     * const count = await prisma.company_vendor_capability_sub_categories.count({
     *   where: {
     *     // ... the filter for the Company_vendor_capability_sub_categories we want to count
     *   }
     * })
    **/
    count<T extends company_vendor_capability_sub_categoriesCountArgs>(
      args?: Subset<T, company_vendor_capability_sub_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_vendor_capability_sub_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_vendor_capability_sub_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_vendor_capability_sub_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_vendor_capability_sub_categoriesAggregateArgs>(args: Subset<T, Company_vendor_capability_sub_categoriesAggregateArgs>): Prisma.PrismaPromise<GetCompany_vendor_capability_sub_categoriesAggregateType<T>>

    /**
     * Group by Company_vendor_capability_sub_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_capability_sub_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_vendor_capability_sub_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_vendor_capability_sub_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: company_vendor_capability_sub_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_vendor_capability_sub_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_vendor_capability_sub_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_vendor_capability_sub_categories model
   */
  readonly fields: company_vendor_capability_sub_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_vendor_capability_sub_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_vendor_capability_sub_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capability<T extends company_vendor_capabilitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, company_vendor_capabilitiesDefaultArgs<ExtArgs>>): Prisma__company_vendor_capabilitiesClient<$Result.GetResult<Prisma.$company_vendor_capabilitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_vendor_capability_sub_categories model
   */
  interface company_vendor_capability_sub_categoriesFieldRefs {
    readonly id: FieldRef<"company_vendor_capability_sub_categories", 'String'>
    readonly name: FieldRef<"company_vendor_capability_sub_categories", 'String'>
    readonly vendor_capability_id: FieldRef<"company_vendor_capability_sub_categories", 'String'>
    readonly is_active: FieldRef<"company_vendor_capability_sub_categories", 'Boolean'>
    readonly created_at: FieldRef<"company_vendor_capability_sub_categories", 'DateTime'>
    readonly updated_at: FieldRef<"company_vendor_capability_sub_categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_vendor_capability_sub_categories findUnique
   */
  export type company_vendor_capability_sub_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capability_sub_categories to fetch.
     */
    where: company_vendor_capability_sub_categoriesWhereUniqueInput
  }

  /**
   * company_vendor_capability_sub_categories findUniqueOrThrow
   */
  export type company_vendor_capability_sub_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capability_sub_categories to fetch.
     */
    where: company_vendor_capability_sub_categoriesWhereUniqueInput
  }

  /**
   * company_vendor_capability_sub_categories findFirst
   */
  export type company_vendor_capability_sub_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capability_sub_categories to fetch.
     */
    where?: company_vendor_capability_sub_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_capability_sub_categories to fetch.
     */
    orderBy?: company_vendor_capability_sub_categoriesOrderByWithRelationInput | company_vendor_capability_sub_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_vendor_capability_sub_categories.
     */
    cursor?: company_vendor_capability_sub_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_capability_sub_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_capability_sub_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_vendor_capability_sub_categories.
     */
    distinct?: Company_vendor_capability_sub_categoriesScalarFieldEnum | Company_vendor_capability_sub_categoriesScalarFieldEnum[]
  }

  /**
   * company_vendor_capability_sub_categories findFirstOrThrow
   */
  export type company_vendor_capability_sub_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capability_sub_categories to fetch.
     */
    where?: company_vendor_capability_sub_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_capability_sub_categories to fetch.
     */
    orderBy?: company_vendor_capability_sub_categoriesOrderByWithRelationInput | company_vendor_capability_sub_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_vendor_capability_sub_categories.
     */
    cursor?: company_vendor_capability_sub_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_capability_sub_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_capability_sub_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_vendor_capability_sub_categories.
     */
    distinct?: Company_vendor_capability_sub_categoriesScalarFieldEnum | Company_vendor_capability_sub_categoriesScalarFieldEnum[]
  }

  /**
   * company_vendor_capability_sub_categories findMany
   */
  export type company_vendor_capability_sub_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which company_vendor_capability_sub_categories to fetch.
     */
    where?: company_vendor_capability_sub_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_capability_sub_categories to fetch.
     */
    orderBy?: company_vendor_capability_sub_categoriesOrderByWithRelationInput | company_vendor_capability_sub_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_vendor_capability_sub_categories.
     */
    cursor?: company_vendor_capability_sub_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_capability_sub_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_capability_sub_categories.
     */
    skip?: number
    distinct?: Company_vendor_capability_sub_categoriesScalarFieldEnum | Company_vendor_capability_sub_categoriesScalarFieldEnum[]
  }

  /**
   * company_vendor_capability_sub_categories create
   */
  export type company_vendor_capability_sub_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a company_vendor_capability_sub_categories.
     */
    data: XOR<company_vendor_capability_sub_categoriesCreateInput, company_vendor_capability_sub_categoriesUncheckedCreateInput>
  }

  /**
   * company_vendor_capability_sub_categories createMany
   */
  export type company_vendor_capability_sub_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_vendor_capability_sub_categories.
     */
    data: company_vendor_capability_sub_categoriesCreateManyInput | company_vendor_capability_sub_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_vendor_capability_sub_categories createManyAndReturn
   */
  export type company_vendor_capability_sub_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many company_vendor_capability_sub_categories.
     */
    data: company_vendor_capability_sub_categoriesCreateManyInput | company_vendor_capability_sub_categoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_vendor_capability_sub_categories update
   */
  export type company_vendor_capability_sub_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a company_vendor_capability_sub_categories.
     */
    data: XOR<company_vendor_capability_sub_categoriesUpdateInput, company_vendor_capability_sub_categoriesUncheckedUpdateInput>
    /**
     * Choose, which company_vendor_capability_sub_categories to update.
     */
    where: company_vendor_capability_sub_categoriesWhereUniqueInput
  }

  /**
   * company_vendor_capability_sub_categories updateMany
   */
  export type company_vendor_capability_sub_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_vendor_capability_sub_categories.
     */
    data: XOR<company_vendor_capability_sub_categoriesUpdateManyMutationInput, company_vendor_capability_sub_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which company_vendor_capability_sub_categories to update
     */
    where?: company_vendor_capability_sub_categoriesWhereInput
    /**
     * Limit how many company_vendor_capability_sub_categories to update.
     */
    limit?: number
  }

  /**
   * company_vendor_capability_sub_categories updateManyAndReturn
   */
  export type company_vendor_capability_sub_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update company_vendor_capability_sub_categories.
     */
    data: XOR<company_vendor_capability_sub_categoriesUpdateManyMutationInput, company_vendor_capability_sub_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which company_vendor_capability_sub_categories to update
     */
    where?: company_vendor_capability_sub_categoriesWhereInput
    /**
     * Limit how many company_vendor_capability_sub_categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_vendor_capability_sub_categories upsert
   */
  export type company_vendor_capability_sub_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the company_vendor_capability_sub_categories to update in case it exists.
     */
    where: company_vendor_capability_sub_categoriesWhereUniqueInput
    /**
     * In case the company_vendor_capability_sub_categories found by the `where` argument doesn't exist, create a new company_vendor_capability_sub_categories with this data.
     */
    create: XOR<company_vendor_capability_sub_categoriesCreateInput, company_vendor_capability_sub_categoriesUncheckedCreateInput>
    /**
     * In case the company_vendor_capability_sub_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_vendor_capability_sub_categoriesUpdateInput, company_vendor_capability_sub_categoriesUncheckedUpdateInput>
  }

  /**
   * company_vendor_capability_sub_categories delete
   */
  export type company_vendor_capability_sub_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
    /**
     * Filter which company_vendor_capability_sub_categories to delete.
     */
    where: company_vendor_capability_sub_categoriesWhereUniqueInput
  }

  /**
   * company_vendor_capability_sub_categories deleteMany
   */
  export type company_vendor_capability_sub_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_vendor_capability_sub_categories to delete
     */
    where?: company_vendor_capability_sub_categoriesWhereInput
    /**
     * Limit how many company_vendor_capability_sub_categories to delete.
     */
    limit?: number
  }

  /**
   * company_vendor_capability_sub_categories without action
   */
  export type company_vendor_capability_sub_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_capability_sub_categories
     */
    select?: company_vendor_capability_sub_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_capability_sub_categories
     */
    omit?: company_vendor_capability_sub_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_vendor_capability_sub_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model company_vendor_certifications
   */

  export type AggregateCompany_vendor_certifications = {
    _count: Company_vendor_certificationsCountAggregateOutputType | null
    _min: Company_vendor_certificationsMinAggregateOutputType | null
    _max: Company_vendor_certificationsMaxAggregateOutputType | null
  }

  export type Company_vendor_certificationsMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_vendor_certificationsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_vendor_certificationsCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_vendor_certificationsMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_vendor_certificationsMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_vendor_certificationsCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_vendor_certificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_vendor_certifications to aggregate.
     */
    where?: company_vendor_certificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_certifications to fetch.
     */
    orderBy?: company_vendor_certificationsOrderByWithRelationInput | company_vendor_certificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_vendor_certificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_vendor_certifications
    **/
    _count?: true | Company_vendor_certificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_vendor_certificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_vendor_certificationsMaxAggregateInputType
  }

  export type GetCompany_vendor_certificationsAggregateType<T extends Company_vendor_certificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_vendor_certifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_vendor_certifications[P]>
      : GetScalarType<T[P], AggregateCompany_vendor_certifications[P]>
  }




  export type company_vendor_certificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_vendor_certificationsWhereInput
    orderBy?: company_vendor_certificationsOrderByWithAggregationInput | company_vendor_certificationsOrderByWithAggregationInput[]
    by: Company_vendor_certificationsScalarFieldEnum[] | Company_vendor_certificationsScalarFieldEnum
    having?: company_vendor_certificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_vendor_certificationsCountAggregateInputType | true
    _min?: Company_vendor_certificationsMinAggregateInputType
    _max?: Company_vendor_certificationsMaxAggregateInputType
  }

  export type Company_vendor_certificationsGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Company_vendor_certificationsCountAggregateOutputType | null
    _min: Company_vendor_certificationsMinAggregateOutputType | null
    _max: Company_vendor_certificationsMaxAggregateOutputType | null
  }

  type GetCompany_vendor_certificationsGroupByPayload<T extends company_vendor_certificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_vendor_certificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_vendor_certificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_vendor_certificationsGroupByOutputType[P]>
            : GetScalarType<T[P], Company_vendor_certificationsGroupByOutputType[P]>
        }
      >
    >


  export type company_vendor_certificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company_vendor_certifications"]>

  export type company_vendor_certificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company_vendor_certifications"]>

  export type company_vendor_certificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company_vendor_certifications"]>

  export type company_vendor_certificationsSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_vendor_certificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["company_vendor_certifications"]>

  export type $company_vendor_certificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_vendor_certifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["company_vendor_certifications"]>
    composites: {}
  }

  type company_vendor_certificationsGetPayload<S extends boolean | null | undefined | company_vendor_certificationsDefaultArgs> = $Result.GetResult<Prisma.$company_vendor_certificationsPayload, S>

  type company_vendor_certificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_vendor_certificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_vendor_certificationsCountAggregateInputType | true
    }

  export interface company_vendor_certificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_vendor_certifications'], meta: { name: 'company_vendor_certifications' } }
    /**
     * Find zero or one Company_vendor_certifications that matches the filter.
     * @param {company_vendor_certificationsFindUniqueArgs} args - Arguments to find a Company_vendor_certifications
     * @example
     * // Get one Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_vendor_certificationsFindUniqueArgs>(args: SelectSubset<T, company_vendor_certificationsFindUniqueArgs<ExtArgs>>): Prisma__company_vendor_certificationsClient<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_vendor_certifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_vendor_certificationsFindUniqueOrThrowArgs} args - Arguments to find a Company_vendor_certifications
     * @example
     * // Get one Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_vendor_certificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, company_vendor_certificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_vendor_certificationsClient<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_vendor_certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_certificationsFindFirstArgs} args - Arguments to find a Company_vendor_certifications
     * @example
     * // Get one Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_vendor_certificationsFindFirstArgs>(args?: SelectSubset<T, company_vendor_certificationsFindFirstArgs<ExtArgs>>): Prisma__company_vendor_certificationsClient<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_vendor_certifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_certificationsFindFirstOrThrowArgs} args - Arguments to find a Company_vendor_certifications
     * @example
     * // Get one Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_vendor_certificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, company_vendor_certificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_vendor_certificationsClient<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_vendor_certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_certificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.findMany()
     * 
     * // Get first 10 Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_vendor_certificationsWithIdOnly = await prisma.company_vendor_certifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_vendor_certificationsFindManyArgs>(args?: SelectSubset<T, company_vendor_certificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_vendor_certifications.
     * @param {company_vendor_certificationsCreateArgs} args - Arguments to create a Company_vendor_certifications.
     * @example
     * // Create one Company_vendor_certifications
     * const Company_vendor_certifications = await prisma.company_vendor_certifications.create({
     *   data: {
     *     // ... data to create a Company_vendor_certifications
     *   }
     * })
     * 
     */
    create<T extends company_vendor_certificationsCreateArgs>(args: SelectSubset<T, company_vendor_certificationsCreateArgs<ExtArgs>>): Prisma__company_vendor_certificationsClient<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_vendor_certifications.
     * @param {company_vendor_certificationsCreateManyArgs} args - Arguments to create many Company_vendor_certifications.
     * @example
     * // Create many Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_vendor_certificationsCreateManyArgs>(args?: SelectSubset<T, company_vendor_certificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_vendor_certifications and returns the data saved in the database.
     * @param {company_vendor_certificationsCreateManyAndReturnArgs} args - Arguments to create many Company_vendor_certifications.
     * @example
     * // Create many Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_vendor_certifications and only return the `id`
     * const company_vendor_certificationsWithIdOnly = await prisma.company_vendor_certifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_vendor_certificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, company_vendor_certificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_vendor_certifications.
     * @param {company_vendor_certificationsDeleteArgs} args - Arguments to delete one Company_vendor_certifications.
     * @example
     * // Delete one Company_vendor_certifications
     * const Company_vendor_certifications = await prisma.company_vendor_certifications.delete({
     *   where: {
     *     // ... filter to delete one Company_vendor_certifications
     *   }
     * })
     * 
     */
    delete<T extends company_vendor_certificationsDeleteArgs>(args: SelectSubset<T, company_vendor_certificationsDeleteArgs<ExtArgs>>): Prisma__company_vendor_certificationsClient<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_vendor_certifications.
     * @param {company_vendor_certificationsUpdateArgs} args - Arguments to update one Company_vendor_certifications.
     * @example
     * // Update one Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_vendor_certificationsUpdateArgs>(args: SelectSubset<T, company_vendor_certificationsUpdateArgs<ExtArgs>>): Prisma__company_vendor_certificationsClient<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_vendor_certifications.
     * @param {company_vendor_certificationsDeleteManyArgs} args - Arguments to filter Company_vendor_certifications to delete.
     * @example
     * // Delete a few Company_vendor_certifications
     * const { count } = await prisma.company_vendor_certifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_vendor_certificationsDeleteManyArgs>(args?: SelectSubset<T, company_vendor_certificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_vendor_certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_certificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_vendor_certificationsUpdateManyArgs>(args: SelectSubset<T, company_vendor_certificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_vendor_certifications and returns the data updated in the database.
     * @param {company_vendor_certificationsUpdateManyAndReturnArgs} args - Arguments to update many Company_vendor_certifications.
     * @example
     * // Update many Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_vendor_certifications and only return the `id`
     * const company_vendor_certificationsWithIdOnly = await prisma.company_vendor_certifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_vendor_certificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, company_vendor_certificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_vendor_certifications.
     * @param {company_vendor_certificationsUpsertArgs} args - Arguments to update or create a Company_vendor_certifications.
     * @example
     * // Update or create a Company_vendor_certifications
     * const company_vendor_certifications = await prisma.company_vendor_certifications.upsert({
     *   create: {
     *     // ... data to create a Company_vendor_certifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_vendor_certifications we want to update
     *   }
     * })
     */
    upsert<T extends company_vendor_certificationsUpsertArgs>(args: SelectSubset<T, company_vendor_certificationsUpsertArgs<ExtArgs>>): Prisma__company_vendor_certificationsClient<$Result.GetResult<Prisma.$company_vendor_certificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_vendor_certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_certificationsCountArgs} args - Arguments to filter Company_vendor_certifications to count.
     * @example
     * // Count the number of Company_vendor_certifications
     * const count = await prisma.company_vendor_certifications.count({
     *   where: {
     *     // ... the filter for the Company_vendor_certifications we want to count
     *   }
     * })
    **/
    count<T extends company_vendor_certificationsCountArgs>(
      args?: Subset<T, company_vendor_certificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_vendor_certificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_vendor_certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_vendor_certificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_vendor_certificationsAggregateArgs>(args: Subset<T, Company_vendor_certificationsAggregateArgs>): Prisma.PrismaPromise<GetCompany_vendor_certificationsAggregateType<T>>

    /**
     * Group by Company_vendor_certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_certificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_vendor_certificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_vendor_certificationsGroupByArgs['orderBy'] }
        : { orderBy?: company_vendor_certificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_vendor_certificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_vendor_certificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_vendor_certifications model
   */
  readonly fields: company_vendor_certificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_vendor_certifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_vendor_certificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_vendor_certifications model
   */
  interface company_vendor_certificationsFieldRefs {
    readonly id: FieldRef<"company_vendor_certifications", 'String'>
    readonly name: FieldRef<"company_vendor_certifications", 'String'>
    readonly is_active: FieldRef<"company_vendor_certifications", 'Boolean'>
    readonly created_at: FieldRef<"company_vendor_certifications", 'DateTime'>
    readonly updated_at: FieldRef<"company_vendor_certifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_vendor_certifications findUnique
   */
  export type company_vendor_certificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_certifications to fetch.
     */
    where: company_vendor_certificationsWhereUniqueInput
  }

  /**
   * company_vendor_certifications findUniqueOrThrow
   */
  export type company_vendor_certificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_certifications to fetch.
     */
    where: company_vendor_certificationsWhereUniqueInput
  }

  /**
   * company_vendor_certifications findFirst
   */
  export type company_vendor_certificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_certifications to fetch.
     */
    where?: company_vendor_certificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_certifications to fetch.
     */
    orderBy?: company_vendor_certificationsOrderByWithRelationInput | company_vendor_certificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_vendor_certifications.
     */
    cursor?: company_vendor_certificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_vendor_certifications.
     */
    distinct?: Company_vendor_certificationsScalarFieldEnum | Company_vendor_certificationsScalarFieldEnum[]
  }

  /**
   * company_vendor_certifications findFirstOrThrow
   */
  export type company_vendor_certificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_certifications to fetch.
     */
    where?: company_vendor_certificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_certifications to fetch.
     */
    orderBy?: company_vendor_certificationsOrderByWithRelationInput | company_vendor_certificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_vendor_certifications.
     */
    cursor?: company_vendor_certificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_vendor_certifications.
     */
    distinct?: Company_vendor_certificationsScalarFieldEnum | Company_vendor_certificationsScalarFieldEnum[]
  }

  /**
   * company_vendor_certifications findMany
   */
  export type company_vendor_certificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_certifications to fetch.
     */
    where?: company_vendor_certificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_certifications to fetch.
     */
    orderBy?: company_vendor_certificationsOrderByWithRelationInput | company_vendor_certificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_vendor_certifications.
     */
    cursor?: company_vendor_certificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_certifications.
     */
    skip?: number
    distinct?: Company_vendor_certificationsScalarFieldEnum | Company_vendor_certificationsScalarFieldEnum[]
  }

  /**
   * company_vendor_certifications create
   */
  export type company_vendor_certificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * The data needed to create a company_vendor_certifications.
     */
    data: XOR<company_vendor_certificationsCreateInput, company_vendor_certificationsUncheckedCreateInput>
  }

  /**
   * company_vendor_certifications createMany
   */
  export type company_vendor_certificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_vendor_certifications.
     */
    data: company_vendor_certificationsCreateManyInput | company_vendor_certificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_vendor_certifications createManyAndReturn
   */
  export type company_vendor_certificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * The data used to create many company_vendor_certifications.
     */
    data: company_vendor_certificationsCreateManyInput | company_vendor_certificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_vendor_certifications update
   */
  export type company_vendor_certificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * The data needed to update a company_vendor_certifications.
     */
    data: XOR<company_vendor_certificationsUpdateInput, company_vendor_certificationsUncheckedUpdateInput>
    /**
     * Choose, which company_vendor_certifications to update.
     */
    where: company_vendor_certificationsWhereUniqueInput
  }

  /**
   * company_vendor_certifications updateMany
   */
  export type company_vendor_certificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_vendor_certifications.
     */
    data: XOR<company_vendor_certificationsUpdateManyMutationInput, company_vendor_certificationsUncheckedUpdateManyInput>
    /**
     * Filter which company_vendor_certifications to update
     */
    where?: company_vendor_certificationsWhereInput
    /**
     * Limit how many company_vendor_certifications to update.
     */
    limit?: number
  }

  /**
   * company_vendor_certifications updateManyAndReturn
   */
  export type company_vendor_certificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * The data used to update company_vendor_certifications.
     */
    data: XOR<company_vendor_certificationsUpdateManyMutationInput, company_vendor_certificationsUncheckedUpdateManyInput>
    /**
     * Filter which company_vendor_certifications to update
     */
    where?: company_vendor_certificationsWhereInput
    /**
     * Limit how many company_vendor_certifications to update.
     */
    limit?: number
  }

  /**
   * company_vendor_certifications upsert
   */
  export type company_vendor_certificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * The filter to search for the company_vendor_certifications to update in case it exists.
     */
    where: company_vendor_certificationsWhereUniqueInput
    /**
     * In case the company_vendor_certifications found by the `where` argument doesn't exist, create a new company_vendor_certifications with this data.
     */
    create: XOR<company_vendor_certificationsCreateInput, company_vendor_certificationsUncheckedCreateInput>
    /**
     * In case the company_vendor_certifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_vendor_certificationsUpdateInput, company_vendor_certificationsUncheckedUpdateInput>
  }

  /**
   * company_vendor_certifications delete
   */
  export type company_vendor_certificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
    /**
     * Filter which company_vendor_certifications to delete.
     */
    where: company_vendor_certificationsWhereUniqueInput
  }

  /**
   * company_vendor_certifications deleteMany
   */
  export type company_vendor_certificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_vendor_certifications to delete
     */
    where?: company_vendor_certificationsWhereInput
    /**
     * Limit how many company_vendor_certifications to delete.
     */
    limit?: number
  }

  /**
   * company_vendor_certifications without action
   */
  export type company_vendor_certificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_certifications
     */
    select?: company_vendor_certificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_certifications
     */
    omit?: company_vendor_certificationsOmit<ExtArgs> | null
  }


  /**
   * Model company_vendor_flags
   */

  export type AggregateCompany_vendor_flags = {
    _count: Company_vendor_flagsCountAggregateOutputType | null
    _min: Company_vendor_flagsMinAggregateOutputType | null
    _max: Company_vendor_flagsMaxAggregateOutputType | null
  }

  export type Company_vendor_flagsMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_vendor_flagsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_vendor_flagsCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_vendor_flagsMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_vendor_flagsMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_vendor_flagsCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_vendor_flagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_vendor_flags to aggregate.
     */
    where?: company_vendor_flagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_flags to fetch.
     */
    orderBy?: company_vendor_flagsOrderByWithRelationInput | company_vendor_flagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_vendor_flagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_vendor_flags
    **/
    _count?: true | Company_vendor_flagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_vendor_flagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_vendor_flagsMaxAggregateInputType
  }

  export type GetCompany_vendor_flagsAggregateType<T extends Company_vendor_flagsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_vendor_flags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_vendor_flags[P]>
      : GetScalarType<T[P], AggregateCompany_vendor_flags[P]>
  }




  export type company_vendor_flagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_vendor_flagsWhereInput
    orderBy?: company_vendor_flagsOrderByWithAggregationInput | company_vendor_flagsOrderByWithAggregationInput[]
    by: Company_vendor_flagsScalarFieldEnum[] | Company_vendor_flagsScalarFieldEnum
    having?: company_vendor_flagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_vendor_flagsCountAggregateInputType | true
    _min?: Company_vendor_flagsMinAggregateInputType
    _max?: Company_vendor_flagsMaxAggregateInputType
  }

  export type Company_vendor_flagsGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Company_vendor_flagsCountAggregateOutputType | null
    _min: Company_vendor_flagsMinAggregateOutputType | null
    _max: Company_vendor_flagsMaxAggregateOutputType | null
  }

  type GetCompany_vendor_flagsGroupByPayload<T extends company_vendor_flagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_vendor_flagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_vendor_flagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_vendor_flagsGroupByOutputType[P]>
            : GetScalarType<T[P], Company_vendor_flagsGroupByOutputType[P]>
        }
      >
    >


  export type company_vendor_flagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company_vendor_flags"]>

  export type company_vendor_flagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company_vendor_flags"]>

  export type company_vendor_flagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company_vendor_flags"]>

  export type company_vendor_flagsSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_vendor_flagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["company_vendor_flags"]>

  export type $company_vendor_flagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_vendor_flags"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["company_vendor_flags"]>
    composites: {}
  }

  type company_vendor_flagsGetPayload<S extends boolean | null | undefined | company_vendor_flagsDefaultArgs> = $Result.GetResult<Prisma.$company_vendor_flagsPayload, S>

  type company_vendor_flagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_vendor_flagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_vendor_flagsCountAggregateInputType | true
    }

  export interface company_vendor_flagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_vendor_flags'], meta: { name: 'company_vendor_flags' } }
    /**
     * Find zero or one Company_vendor_flags that matches the filter.
     * @param {company_vendor_flagsFindUniqueArgs} args - Arguments to find a Company_vendor_flags
     * @example
     * // Get one Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_vendor_flagsFindUniqueArgs>(args: SelectSubset<T, company_vendor_flagsFindUniqueArgs<ExtArgs>>): Prisma__company_vendor_flagsClient<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_vendor_flags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_vendor_flagsFindUniqueOrThrowArgs} args - Arguments to find a Company_vendor_flags
     * @example
     * // Get one Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_vendor_flagsFindUniqueOrThrowArgs>(args: SelectSubset<T, company_vendor_flagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_vendor_flagsClient<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_vendor_flags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_flagsFindFirstArgs} args - Arguments to find a Company_vendor_flags
     * @example
     * // Get one Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_vendor_flagsFindFirstArgs>(args?: SelectSubset<T, company_vendor_flagsFindFirstArgs<ExtArgs>>): Prisma__company_vendor_flagsClient<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_vendor_flags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_flagsFindFirstOrThrowArgs} args - Arguments to find a Company_vendor_flags
     * @example
     * // Get one Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_vendor_flagsFindFirstOrThrowArgs>(args?: SelectSubset<T, company_vendor_flagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_vendor_flagsClient<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_vendor_flags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_flagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.findMany()
     * 
     * // Get first 10 Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_vendor_flagsWithIdOnly = await prisma.company_vendor_flags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_vendor_flagsFindManyArgs>(args?: SelectSubset<T, company_vendor_flagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_vendor_flags.
     * @param {company_vendor_flagsCreateArgs} args - Arguments to create a Company_vendor_flags.
     * @example
     * // Create one Company_vendor_flags
     * const Company_vendor_flags = await prisma.company_vendor_flags.create({
     *   data: {
     *     // ... data to create a Company_vendor_flags
     *   }
     * })
     * 
     */
    create<T extends company_vendor_flagsCreateArgs>(args: SelectSubset<T, company_vendor_flagsCreateArgs<ExtArgs>>): Prisma__company_vendor_flagsClient<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_vendor_flags.
     * @param {company_vendor_flagsCreateManyArgs} args - Arguments to create many Company_vendor_flags.
     * @example
     * // Create many Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_vendor_flagsCreateManyArgs>(args?: SelectSubset<T, company_vendor_flagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_vendor_flags and returns the data saved in the database.
     * @param {company_vendor_flagsCreateManyAndReturnArgs} args - Arguments to create many Company_vendor_flags.
     * @example
     * // Create many Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_vendor_flags and only return the `id`
     * const company_vendor_flagsWithIdOnly = await prisma.company_vendor_flags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_vendor_flagsCreateManyAndReturnArgs>(args?: SelectSubset<T, company_vendor_flagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_vendor_flags.
     * @param {company_vendor_flagsDeleteArgs} args - Arguments to delete one Company_vendor_flags.
     * @example
     * // Delete one Company_vendor_flags
     * const Company_vendor_flags = await prisma.company_vendor_flags.delete({
     *   where: {
     *     // ... filter to delete one Company_vendor_flags
     *   }
     * })
     * 
     */
    delete<T extends company_vendor_flagsDeleteArgs>(args: SelectSubset<T, company_vendor_flagsDeleteArgs<ExtArgs>>): Prisma__company_vendor_flagsClient<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_vendor_flags.
     * @param {company_vendor_flagsUpdateArgs} args - Arguments to update one Company_vendor_flags.
     * @example
     * // Update one Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_vendor_flagsUpdateArgs>(args: SelectSubset<T, company_vendor_flagsUpdateArgs<ExtArgs>>): Prisma__company_vendor_flagsClient<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_vendor_flags.
     * @param {company_vendor_flagsDeleteManyArgs} args - Arguments to filter Company_vendor_flags to delete.
     * @example
     * // Delete a few Company_vendor_flags
     * const { count } = await prisma.company_vendor_flags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_vendor_flagsDeleteManyArgs>(args?: SelectSubset<T, company_vendor_flagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_vendor_flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_flagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_vendor_flagsUpdateManyArgs>(args: SelectSubset<T, company_vendor_flagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_vendor_flags and returns the data updated in the database.
     * @param {company_vendor_flagsUpdateManyAndReturnArgs} args - Arguments to update many Company_vendor_flags.
     * @example
     * // Update many Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_vendor_flags and only return the `id`
     * const company_vendor_flagsWithIdOnly = await prisma.company_vendor_flags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_vendor_flagsUpdateManyAndReturnArgs>(args: SelectSubset<T, company_vendor_flagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_vendor_flags.
     * @param {company_vendor_flagsUpsertArgs} args - Arguments to update or create a Company_vendor_flags.
     * @example
     * // Update or create a Company_vendor_flags
     * const company_vendor_flags = await prisma.company_vendor_flags.upsert({
     *   create: {
     *     // ... data to create a Company_vendor_flags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_vendor_flags we want to update
     *   }
     * })
     */
    upsert<T extends company_vendor_flagsUpsertArgs>(args: SelectSubset<T, company_vendor_flagsUpsertArgs<ExtArgs>>): Prisma__company_vendor_flagsClient<$Result.GetResult<Prisma.$company_vendor_flagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_vendor_flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_flagsCountArgs} args - Arguments to filter Company_vendor_flags to count.
     * @example
     * // Count the number of Company_vendor_flags
     * const count = await prisma.company_vendor_flags.count({
     *   where: {
     *     // ... the filter for the Company_vendor_flags we want to count
     *   }
     * })
    **/
    count<T extends company_vendor_flagsCountArgs>(
      args?: Subset<T, company_vendor_flagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_vendor_flagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_vendor_flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_vendor_flagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_vendor_flagsAggregateArgs>(args: Subset<T, Company_vendor_flagsAggregateArgs>): Prisma.PrismaPromise<GetCompany_vendor_flagsAggregateType<T>>

    /**
     * Group by Company_vendor_flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_vendor_flagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_vendor_flagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_vendor_flagsGroupByArgs['orderBy'] }
        : { orderBy?: company_vendor_flagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_vendor_flagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_vendor_flagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_vendor_flags model
   */
  readonly fields: company_vendor_flagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_vendor_flags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_vendor_flagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_vendor_flags model
   */
  interface company_vendor_flagsFieldRefs {
    readonly id: FieldRef<"company_vendor_flags", 'String'>
    readonly name: FieldRef<"company_vendor_flags", 'String'>
    readonly is_active: FieldRef<"company_vendor_flags", 'Boolean'>
    readonly created_at: FieldRef<"company_vendor_flags", 'DateTime'>
    readonly updated_at: FieldRef<"company_vendor_flags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_vendor_flags findUnique
   */
  export type company_vendor_flagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_flags to fetch.
     */
    where: company_vendor_flagsWhereUniqueInput
  }

  /**
   * company_vendor_flags findUniqueOrThrow
   */
  export type company_vendor_flagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_flags to fetch.
     */
    where: company_vendor_flagsWhereUniqueInput
  }

  /**
   * company_vendor_flags findFirst
   */
  export type company_vendor_flagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_flags to fetch.
     */
    where?: company_vendor_flagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_flags to fetch.
     */
    orderBy?: company_vendor_flagsOrderByWithRelationInput | company_vendor_flagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_vendor_flags.
     */
    cursor?: company_vendor_flagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_vendor_flags.
     */
    distinct?: Company_vendor_flagsScalarFieldEnum | Company_vendor_flagsScalarFieldEnum[]
  }

  /**
   * company_vendor_flags findFirstOrThrow
   */
  export type company_vendor_flagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_flags to fetch.
     */
    where?: company_vendor_flagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_flags to fetch.
     */
    orderBy?: company_vendor_flagsOrderByWithRelationInput | company_vendor_flagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_vendor_flags.
     */
    cursor?: company_vendor_flagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_vendor_flags.
     */
    distinct?: Company_vendor_flagsScalarFieldEnum | Company_vendor_flagsScalarFieldEnum[]
  }

  /**
   * company_vendor_flags findMany
   */
  export type company_vendor_flagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * Filter, which company_vendor_flags to fetch.
     */
    where?: company_vendor_flagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_vendor_flags to fetch.
     */
    orderBy?: company_vendor_flagsOrderByWithRelationInput | company_vendor_flagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_vendor_flags.
     */
    cursor?: company_vendor_flagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_vendor_flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_vendor_flags.
     */
    skip?: number
    distinct?: Company_vendor_flagsScalarFieldEnum | Company_vendor_flagsScalarFieldEnum[]
  }

  /**
   * company_vendor_flags create
   */
  export type company_vendor_flagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * The data needed to create a company_vendor_flags.
     */
    data: XOR<company_vendor_flagsCreateInput, company_vendor_flagsUncheckedCreateInput>
  }

  /**
   * company_vendor_flags createMany
   */
  export type company_vendor_flagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_vendor_flags.
     */
    data: company_vendor_flagsCreateManyInput | company_vendor_flagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_vendor_flags createManyAndReturn
   */
  export type company_vendor_flagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * The data used to create many company_vendor_flags.
     */
    data: company_vendor_flagsCreateManyInput | company_vendor_flagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_vendor_flags update
   */
  export type company_vendor_flagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * The data needed to update a company_vendor_flags.
     */
    data: XOR<company_vendor_flagsUpdateInput, company_vendor_flagsUncheckedUpdateInput>
    /**
     * Choose, which company_vendor_flags to update.
     */
    where: company_vendor_flagsWhereUniqueInput
  }

  /**
   * company_vendor_flags updateMany
   */
  export type company_vendor_flagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_vendor_flags.
     */
    data: XOR<company_vendor_flagsUpdateManyMutationInput, company_vendor_flagsUncheckedUpdateManyInput>
    /**
     * Filter which company_vendor_flags to update
     */
    where?: company_vendor_flagsWhereInput
    /**
     * Limit how many company_vendor_flags to update.
     */
    limit?: number
  }

  /**
   * company_vendor_flags updateManyAndReturn
   */
  export type company_vendor_flagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * The data used to update company_vendor_flags.
     */
    data: XOR<company_vendor_flagsUpdateManyMutationInput, company_vendor_flagsUncheckedUpdateManyInput>
    /**
     * Filter which company_vendor_flags to update
     */
    where?: company_vendor_flagsWhereInput
    /**
     * Limit how many company_vendor_flags to update.
     */
    limit?: number
  }

  /**
   * company_vendor_flags upsert
   */
  export type company_vendor_flagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * The filter to search for the company_vendor_flags to update in case it exists.
     */
    where: company_vendor_flagsWhereUniqueInput
    /**
     * In case the company_vendor_flags found by the `where` argument doesn't exist, create a new company_vendor_flags with this data.
     */
    create: XOR<company_vendor_flagsCreateInput, company_vendor_flagsUncheckedCreateInput>
    /**
     * In case the company_vendor_flags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_vendor_flagsUpdateInput, company_vendor_flagsUncheckedUpdateInput>
  }

  /**
   * company_vendor_flags delete
   */
  export type company_vendor_flagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
    /**
     * Filter which company_vendor_flags to delete.
     */
    where: company_vendor_flagsWhereUniqueInput
  }

  /**
   * company_vendor_flags deleteMany
   */
  export type company_vendor_flagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_vendor_flags to delete
     */
    where?: company_vendor_flagsWhereInput
    /**
     * Limit how many company_vendor_flags to delete.
     */
    limit?: number
  }

  /**
   * company_vendor_flags without action
   */
  export type company_vendor_flagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_vendor_flags
     */
    select?: company_vendor_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_vendor_flags
     */
    omit?: company_vendor_flagsOmit<ExtArgs> | null
  }


  /**
   * Model company_school
   */

  export type AggregateCompany_school = {
    _count: Company_schoolCountAggregateOutputType | null
    _min: Company_schoolMinAggregateOutputType | null
    _max: Company_schoolMaxAggregateOutputType | null
  }

  export type Company_schoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    class: string | null
    roll_no: string | null
  }

  export type Company_schoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    class: string | null
    roll_no: string | null
  }

  export type Company_schoolCountAggregateOutputType = {
    id: number
    name: number
    class: number
    roll_no: number
    _all: number
  }


  export type Company_schoolMinAggregateInputType = {
    id?: true
    name?: true
    class?: true
    roll_no?: true
  }

  export type Company_schoolMaxAggregateInputType = {
    id?: true
    name?: true
    class?: true
    roll_no?: true
  }

  export type Company_schoolCountAggregateInputType = {
    id?: true
    name?: true
    class?: true
    roll_no?: true
    _all?: true
  }

  export type Company_schoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_school to aggregate.
     */
    where?: company_schoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_schools to fetch.
     */
    orderBy?: company_schoolOrderByWithRelationInput | company_schoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_schoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_schools
    **/
    _count?: true | Company_schoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_schoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_schoolMaxAggregateInputType
  }

  export type GetCompany_schoolAggregateType<T extends Company_schoolAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_school]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_school[P]>
      : GetScalarType<T[P], AggregateCompany_school[P]>
  }




  export type company_schoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_schoolWhereInput
    orderBy?: company_schoolOrderByWithAggregationInput | company_schoolOrderByWithAggregationInput[]
    by: Company_schoolScalarFieldEnum[] | Company_schoolScalarFieldEnum
    having?: company_schoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_schoolCountAggregateInputType | true
    _min?: Company_schoolMinAggregateInputType
    _max?: Company_schoolMaxAggregateInputType
  }

  export type Company_schoolGroupByOutputType = {
    id: string
    name: string
    class: string
    roll_no: string
    _count: Company_schoolCountAggregateOutputType | null
    _min: Company_schoolMinAggregateOutputType | null
    _max: Company_schoolMaxAggregateOutputType | null
  }

  type GetCompany_schoolGroupByPayload<T extends company_schoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_schoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_schoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_schoolGroupByOutputType[P]>
            : GetScalarType<T[P], Company_schoolGroupByOutputType[P]>
        }
      >
    >


  export type company_schoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class?: boolean
    roll_no?: boolean
  }, ExtArgs["result"]["company_school"]>

  export type company_schoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class?: boolean
    roll_no?: boolean
  }, ExtArgs["result"]["company_school"]>

  export type company_schoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class?: boolean
    roll_no?: boolean
  }, ExtArgs["result"]["company_school"]>

  export type company_schoolSelectScalar = {
    id?: boolean
    name?: boolean
    class?: boolean
    roll_no?: boolean
  }

  export type company_schoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "class" | "roll_no", ExtArgs["result"]["company_school"]>

  export type $company_schoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_school"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      class: string
      roll_no: string
    }, ExtArgs["result"]["company_school"]>
    composites: {}
  }

  type company_schoolGetPayload<S extends boolean | null | undefined | company_schoolDefaultArgs> = $Result.GetResult<Prisma.$company_schoolPayload, S>

  type company_schoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_schoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_schoolCountAggregateInputType | true
    }

  export interface company_schoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_school'], meta: { name: 'company_school' } }
    /**
     * Find zero or one Company_school that matches the filter.
     * @param {company_schoolFindUniqueArgs} args - Arguments to find a Company_school
     * @example
     * // Get one Company_school
     * const company_school = await prisma.company_school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_schoolFindUniqueArgs>(args: SelectSubset<T, company_schoolFindUniqueArgs<ExtArgs>>): Prisma__company_schoolClient<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_school that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_schoolFindUniqueOrThrowArgs} args - Arguments to find a Company_school
     * @example
     * // Get one Company_school
     * const company_school = await prisma.company_school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_schoolFindUniqueOrThrowArgs>(args: SelectSubset<T, company_schoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_schoolClient<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_school that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_schoolFindFirstArgs} args - Arguments to find a Company_school
     * @example
     * // Get one Company_school
     * const company_school = await prisma.company_school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_schoolFindFirstArgs>(args?: SelectSubset<T, company_schoolFindFirstArgs<ExtArgs>>): Prisma__company_schoolClient<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_school that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_schoolFindFirstOrThrowArgs} args - Arguments to find a Company_school
     * @example
     * // Get one Company_school
     * const company_school = await prisma.company_school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_schoolFindFirstOrThrowArgs>(args?: SelectSubset<T, company_schoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_schoolClient<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_schoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_schools
     * const company_schools = await prisma.company_school.findMany()
     * 
     * // Get first 10 Company_schools
     * const company_schools = await prisma.company_school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_schoolWithIdOnly = await prisma.company_school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_schoolFindManyArgs>(args?: SelectSubset<T, company_schoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_school.
     * @param {company_schoolCreateArgs} args - Arguments to create a Company_school.
     * @example
     * // Create one Company_school
     * const Company_school = await prisma.company_school.create({
     *   data: {
     *     // ... data to create a Company_school
     *   }
     * })
     * 
     */
    create<T extends company_schoolCreateArgs>(args: SelectSubset<T, company_schoolCreateArgs<ExtArgs>>): Prisma__company_schoolClient<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_schools.
     * @param {company_schoolCreateManyArgs} args - Arguments to create many Company_schools.
     * @example
     * // Create many Company_schools
     * const company_school = await prisma.company_school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_schoolCreateManyArgs>(args?: SelectSubset<T, company_schoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_schools and returns the data saved in the database.
     * @param {company_schoolCreateManyAndReturnArgs} args - Arguments to create many Company_schools.
     * @example
     * // Create many Company_schools
     * const company_school = await prisma.company_school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_schools and only return the `id`
     * const company_schoolWithIdOnly = await prisma.company_school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_schoolCreateManyAndReturnArgs>(args?: SelectSubset<T, company_schoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_school.
     * @param {company_schoolDeleteArgs} args - Arguments to delete one Company_school.
     * @example
     * // Delete one Company_school
     * const Company_school = await prisma.company_school.delete({
     *   where: {
     *     // ... filter to delete one Company_school
     *   }
     * })
     * 
     */
    delete<T extends company_schoolDeleteArgs>(args: SelectSubset<T, company_schoolDeleteArgs<ExtArgs>>): Prisma__company_schoolClient<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_school.
     * @param {company_schoolUpdateArgs} args - Arguments to update one Company_school.
     * @example
     * // Update one Company_school
     * const company_school = await prisma.company_school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_schoolUpdateArgs>(args: SelectSubset<T, company_schoolUpdateArgs<ExtArgs>>): Prisma__company_schoolClient<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_schools.
     * @param {company_schoolDeleteManyArgs} args - Arguments to filter Company_schools to delete.
     * @example
     * // Delete a few Company_schools
     * const { count } = await prisma.company_school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_schoolDeleteManyArgs>(args?: SelectSubset<T, company_schoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_schoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_schools
     * const company_school = await prisma.company_school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_schoolUpdateManyArgs>(args: SelectSubset<T, company_schoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_schools and returns the data updated in the database.
     * @param {company_schoolUpdateManyAndReturnArgs} args - Arguments to update many Company_schools.
     * @example
     * // Update many Company_schools
     * const company_school = await prisma.company_school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_schools and only return the `id`
     * const company_schoolWithIdOnly = await prisma.company_school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_schoolUpdateManyAndReturnArgs>(args: SelectSubset<T, company_schoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_school.
     * @param {company_schoolUpsertArgs} args - Arguments to update or create a Company_school.
     * @example
     * // Update or create a Company_school
     * const company_school = await prisma.company_school.upsert({
     *   create: {
     *     // ... data to create a Company_school
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_school we want to update
     *   }
     * })
     */
    upsert<T extends company_schoolUpsertArgs>(args: SelectSubset<T, company_schoolUpsertArgs<ExtArgs>>): Prisma__company_schoolClient<$Result.GetResult<Prisma.$company_schoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_schoolCountArgs} args - Arguments to filter Company_schools to count.
     * @example
     * // Count the number of Company_schools
     * const count = await prisma.company_school.count({
     *   where: {
     *     // ... the filter for the Company_schools we want to count
     *   }
     * })
    **/
    count<T extends company_schoolCountArgs>(
      args?: Subset<T, company_schoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_schoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_school.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_schoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_schoolAggregateArgs>(args: Subset<T, Company_schoolAggregateArgs>): Prisma.PrismaPromise<GetCompany_schoolAggregateType<T>>

    /**
     * Group by Company_school.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_schoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_schoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_schoolGroupByArgs['orderBy'] }
        : { orderBy?: company_schoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_schoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_schoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_school model
   */
  readonly fields: company_schoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_school.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_schoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_school model
   */
  interface company_schoolFieldRefs {
    readonly id: FieldRef<"company_school", 'String'>
    readonly name: FieldRef<"company_school", 'String'>
    readonly class: FieldRef<"company_school", 'String'>
    readonly roll_no: FieldRef<"company_school", 'String'>
  }
    

  // Custom InputTypes
  /**
   * company_school findUnique
   */
  export type company_schoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * Filter, which company_school to fetch.
     */
    where: company_schoolWhereUniqueInput
  }

  /**
   * company_school findUniqueOrThrow
   */
  export type company_schoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * Filter, which company_school to fetch.
     */
    where: company_schoolWhereUniqueInput
  }

  /**
   * company_school findFirst
   */
  export type company_schoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * Filter, which company_school to fetch.
     */
    where?: company_schoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_schools to fetch.
     */
    orderBy?: company_schoolOrderByWithRelationInput | company_schoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_schools.
     */
    cursor?: company_schoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_schools.
     */
    distinct?: Company_schoolScalarFieldEnum | Company_schoolScalarFieldEnum[]
  }

  /**
   * company_school findFirstOrThrow
   */
  export type company_schoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * Filter, which company_school to fetch.
     */
    where?: company_schoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_schools to fetch.
     */
    orderBy?: company_schoolOrderByWithRelationInput | company_schoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_schools.
     */
    cursor?: company_schoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_schools.
     */
    distinct?: Company_schoolScalarFieldEnum | Company_schoolScalarFieldEnum[]
  }

  /**
   * company_school findMany
   */
  export type company_schoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * Filter, which company_schools to fetch.
     */
    where?: company_schoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_schools to fetch.
     */
    orderBy?: company_schoolOrderByWithRelationInput | company_schoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_schools.
     */
    cursor?: company_schoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_schools.
     */
    skip?: number
    distinct?: Company_schoolScalarFieldEnum | Company_schoolScalarFieldEnum[]
  }

  /**
   * company_school create
   */
  export type company_schoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * The data needed to create a company_school.
     */
    data: XOR<company_schoolCreateInput, company_schoolUncheckedCreateInput>
  }

  /**
   * company_school createMany
   */
  export type company_schoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_schools.
     */
    data: company_schoolCreateManyInput | company_schoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_school createManyAndReturn
   */
  export type company_schoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * The data used to create many company_schools.
     */
    data: company_schoolCreateManyInput | company_schoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_school update
   */
  export type company_schoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * The data needed to update a company_school.
     */
    data: XOR<company_schoolUpdateInput, company_schoolUncheckedUpdateInput>
    /**
     * Choose, which company_school to update.
     */
    where: company_schoolWhereUniqueInput
  }

  /**
   * company_school updateMany
   */
  export type company_schoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_schools.
     */
    data: XOR<company_schoolUpdateManyMutationInput, company_schoolUncheckedUpdateManyInput>
    /**
     * Filter which company_schools to update
     */
    where?: company_schoolWhereInput
    /**
     * Limit how many company_schools to update.
     */
    limit?: number
  }

  /**
   * company_school updateManyAndReturn
   */
  export type company_schoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * The data used to update company_schools.
     */
    data: XOR<company_schoolUpdateManyMutationInput, company_schoolUncheckedUpdateManyInput>
    /**
     * Filter which company_schools to update
     */
    where?: company_schoolWhereInput
    /**
     * Limit how many company_schools to update.
     */
    limit?: number
  }

  /**
   * company_school upsert
   */
  export type company_schoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * The filter to search for the company_school to update in case it exists.
     */
    where: company_schoolWhereUniqueInput
    /**
     * In case the company_school found by the `where` argument doesn't exist, create a new company_school with this data.
     */
    create: XOR<company_schoolCreateInput, company_schoolUncheckedCreateInput>
    /**
     * In case the company_school was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_schoolUpdateInput, company_schoolUncheckedUpdateInput>
  }

  /**
   * company_school delete
   */
  export type company_schoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
    /**
     * Filter which company_school to delete.
     */
    where: company_schoolWhereUniqueInput
  }

  /**
   * company_school deleteMany
   */
  export type company_schoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_schools to delete
     */
    where?: company_schoolWhereInput
    /**
     * Limit how many company_schools to delete.
     */
    limit?: number
  }

  /**
   * company_school without action
   */
  export type company_schoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_school
     */
    select?: company_schoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_school
     */
    omit?: company_schoolOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone: 'phone',
    roles: 'roles',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    quote_item_id: 'quote_item_id',
    status: 'status',
    payment_status: 'payment_status',
    quote_type: 'quote_type',
    tax: 'tax',
    deposit_paid: 'deposit_paid',
    shipping: 'shipping',
    tax_buy_price: 'tax_buy_price',
    shipping_buy_price: 'shipping_buy_price',
    lead_time: 'lead_time',
    payable: 'payable',
    freight_condition: 'freight_condition',
    freight_condition_dismiss: 'freight_condition_dismiss',
    customer_email: 'customer_email',
    emails: 'emails',
    invoice_date: 'invoice_date',
    invoice_email: 'invoice_email',
    billing_name: 'billing_name',
    billing_company: 'billing_company',
    billing_address: 'billing_address',
    billing_city: 'billing_city',
    billing_state: 'billing_state',
    billing_country: 'billing_country',
    billing_zip: 'billing_zip',
    billing_phone: 'billing_phone',
    billing_fax: 'billing_fax',
    shipping_name: 'shipping_name',
    shipping_company: 'shipping_company',
    shipping_address: 'shipping_address',
    shipping_city: 'shipping_city',
    shipping_state: 'shipping_state',
    shipping_country: 'shipping_country',
    shipping_zip: 'shipping_zip',
    shipping_phone: 'shipping_phone',
    shipping_email: 'shipping_email',
    shipping_fax: 'shipping_fax',
    sales_person: 'sales_person',
    project_manager: 'project_manager',
    accept_agreement: 'accept_agreement',
    date_created: 'date_created',
    created_month: 'created_month',
    created_year: 'created_year',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    is_deleted: 'is_deleted'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const QuoteItemScalarFieldEnum: {
    id: 'id',
    quote_id: 'quote_id',
    file_name: 'file_name',
    file_url: 'file_url',
    status: 'status',
    quantity: 'quantity',
    service: 'service',
    material: 'material',
    finish: 'finish',
    description: 'description',
    process: 'process',
    specification: 'specification',
    price: 'price',
    cost: 'cost',
    cost_shipping_price: 'cost_shipping_price',
    cost_shipping_total: 'cost_shipping_total',
    custom_shipping_total: 'custom_shipping_total',
    buy_price: 'buy_price',
    buy_shipping_price: 'buy_shipping_price',
    buy_shipping_total: 'buy_shipping_total',
    quantity_owed: 'quantity_owed',
    invoiced: 'invoiced',
    non_taxable: 'non_taxable',
    non_shipping: 'non_shipping',
    is_deleted: 'is_deleted',
    vendor_id: 'vendor_id',
    vendor_details: 'vendor_details',
    last_updated_by: 'last_updated_by',
    work_instructions: 'work_instructions',
    add_vendor: 'add_vendor',
    markings: 'markings',
    part_item_number: 'part_item_number',
    file_year: 'file_year',
    file_month: 'file_month',
    tab_open: 'tab_open',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type QuoteItemScalarFieldEnum = (typeof QuoteItemScalarFieldEnum)[keyof typeof QuoteItemScalarFieldEnum]


  export const PasswordResetOTPScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp',
    request_id: 'request_id',
    expires_at: 'expires_at',
    created_at: 'created_at',
    user_id: 'user_id'
  };

  export type PasswordResetOTPScalarFieldEnum = (typeof PasswordResetOTPScalarFieldEnum)[keyof typeof PasswordResetOTPScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token: 'token',
    expires_at: 'expires_at',
    created_at: 'created_at'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const TenantCurrencyScalarFieldEnum: {
    id: 'id',
    currency_id: 'currency_id',
    code: 'code',
    name: 'name',
    symbol: 'symbol',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantCurrencyScalarFieldEnum = (typeof TenantCurrencyScalarFieldEnum)[keyof typeof TenantCurrencyScalarFieldEnum]


  export const TenantPaymentTermsScalarFieldEnum: {
    id: 'id',
    payment_terms_id: 'payment_terms_id',
    name: 'name',
    description: 'description',
    due_days: 'due_days',
    discount_days: 'discount_days',
    discount_percent: 'discount_percent',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantPaymentTermsScalarFieldEnum = (typeof TenantPaymentTermsScalarFieldEnum)[keyof typeof TenantPaymentTermsScalarFieldEnum]


  export const TenantPaymentStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantPaymentStatusScalarFieldEnum = (typeof TenantPaymentStatusScalarFieldEnum)[keyof typeof TenantPaymentStatusScalarFieldEnum]


  export const TenantQuoteStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantQuoteStatusScalarFieldEnum = (typeof TenantQuoteStatusScalarFieldEnum)[keyof typeof TenantQuoteStatusScalarFieldEnum]


  export const TenantOrderStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantOrderStatusScalarFieldEnum = (typeof TenantOrderStatusScalarFieldEnum)[keyof typeof TenantOrderStatusScalarFieldEnum]


  export const TenantLogisticsStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantLogisticsStatusScalarFieldEnum = (typeof TenantLogisticsStatusScalarFieldEnum)[keyof typeof TenantLogisticsStatusScalarFieldEnum]


  export const TenantFinanceStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantFinanceStatusScalarFieldEnum = (typeof TenantFinanceStatusScalarFieldEnum)[keyof typeof TenantFinanceStatusScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    first_name: 'first_name',
    last_name: 'last_name',
    customer_name: 'customer_name',
    company_name: 'company_name',
    email: 'email',
    password: 'password',
    phone: 'phone',
    type: 'type',
    website: 'website',
    is_active: 'is_active',
    notes: 'notes',
    sorting: 'sorting',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    user_id: 'user_id'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CompanyServiceScalarFieldEnum: {
    id: 'id',
    exclude_inspection: 'exclude_inspection',
    invoice50: 'invoice50',
    fob_china: 'fob_china',
    require_deposit_invoice: 'require_deposit_invoice',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CompanyServiceScalarFieldEnum = (typeof CompanyServiceScalarFieldEnum)[keyof typeof CompanyServiceScalarFieldEnum]


  export const CompanyMaterialScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CompanyMaterialScalarFieldEnum = (typeof CompanyMaterialScalarFieldEnum)[keyof typeof CompanyMaterialScalarFieldEnum]


  export const CompanyFinishScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CompanyFinishScalarFieldEnum = (typeof CompanyFinishScalarFieldEnum)[keyof typeof CompanyFinishScalarFieldEnum]


  export const CustomerAddressScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    billing_address: 'billing_address',
    billing_address2: 'billing_address2',
    billing_city: 'billing_city',
    billing_state: 'billing_state',
    billing_zip: 'billing_zip',
    billing_country: 'billing_country',
    shipping_address: 'shipping_address',
    shipping_address2: 'shipping_address2',
    shipping_city: 'shipping_city',
    shipping_state: 'shipping_state',
    shipping_zip: 'shipping_zip',
    shipping_country: 'shipping_country',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


  export const CustomerTaxInfoScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    tax_number: 'tax_number',
    default_tax: 'default_tax',
    currency: 'currency',
    payment_terms: 'payment_terms',
    credit_limit: 'credit_limit',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomerTaxInfoScalarFieldEnum = (typeof CustomerTaxInfoScalarFieldEnum)[keyof typeof CustomerTaxInfoScalarFieldEnum]


  export const CustomerContactScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    contact_name: 'contact_name',
    job_title: 'job_title',
    contact_email: 'contact_email',
    contact_phone: 'contact_phone',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomerContactScalarFieldEnum = (typeof CustomerContactScalarFieldEnum)[keyof typeof CustomerContactScalarFieldEnum]


  export const CustomerOperationalInfoScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    delivery_method: 'delivery_method',
    quote_format: 'quote_format',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomerOperationalInfoScalarFieldEnum = (typeof CustomerOperationalInfoScalarFieldEnum)[keyof typeof CustomerOperationalInfoScalarFieldEnum]


  export const CustomerNotesAndAttachmentsScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    internal_notes: 'internal_notes',
    tags: 'tags',
    file_url: 'file_url',
    file_name: 'file_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomerNotesAndAttachmentsScalarFieldEnum = (typeof CustomerNotesAndAttachmentsScalarFieldEnum)[keyof typeof CustomerNotesAndAttachmentsScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    vendor_id: 'vendor_id',
    first_name: 'first_name',
    last_name: 'last_name',
    vendor_name: 'vendor_name',
    vendor_type: 'vendor_type',
    email: 'email',
    password: 'password',
    phone: 'phone',
    website: 'website',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    user_id: 'user_id'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const VendorContactScalarFieldEnum: {
    id: 'id',
    vendor_id: 'vendor_id',
    contact_name: 'contact_name',
    job_title: 'job_title',
    email: 'email',
    phone: 'phone',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorContactScalarFieldEnum = (typeof VendorContactScalarFieldEnum)[keyof typeof VendorContactScalarFieldEnum]


  export const VendorAddressScalarFieldEnum: {
    id: 'id',
    vendor_id: 'vendor_id',
    address_1: 'address_1',
    address_2: 'address_2',
    city: 'city',
    state: 'state',
    zip: 'zip',
    country: 'country',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorAddressScalarFieldEnum = (typeof VendorAddressScalarFieldEnum)[keyof typeof VendorAddressScalarFieldEnum]


  export const VendorTaxComplianceScalarFieldEnum: {
    id: 'id',
    vendor_id: 'vendor_id',
    tax_number: 'tax_number',
    vat_number: 'vat_number',
    company_number: 'company_number',
    compliance_type: 'compliance_type',
    file_name: 'file_name',
    file_url: 'file_url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorTaxComplianceScalarFieldEnum = (typeof VendorTaxComplianceScalarFieldEnum)[keyof typeof VendorTaxComplianceScalarFieldEnum]


  export const VendorFinancialScalarFieldEnum: {
    id: 'id',
    vendor_id: 'vendor_id',
    bank_name: 'bank_name',
    bank_account_number: 'bank_account_number',
    swift_iban_code: 'swift_iban_code',
    preferred_currency: 'preferred_currency',
    payment_terms: 'payment_terms',
    default_tax_rate: 'default_tax_rate',
    credit_limit: 'credit_limit',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorFinancialScalarFieldEnum = (typeof VendorFinancialScalarFieldEnum)[keyof typeof VendorFinancialScalarFieldEnum]


  export const VendorOperationalSettingScalarFieldEnum: {
    id: 'id',
    vendor_id: 'vendor_id',
    status: 'status',
    shipping_method: 'shipping_method',
    lead_time: 'lead_time',
    minimum_order_quantity: 'minimum_order_quantity',
    categories: 'categories',
    manager: 'manager',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorOperationalSettingScalarFieldEnum = (typeof VendorOperationalSettingScalarFieldEnum)[keyof typeof VendorOperationalSettingScalarFieldEnum]


  export const VendorMetadataScalarFieldEnum: {
    id: 'id',
    vendor_id: 'vendor_id',
    notes: 'notes',
    tags: 'tags',
    score: 'score',
    last_order: 'last_order',
    next_review: 'next_review',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorMetadataScalarFieldEnum = (typeof VendorMetadataScalarFieldEnum)[keyof typeof VendorMetadataScalarFieldEnum]


  export const Company_vendor_capabilitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_vendor_capabilitiesScalarFieldEnum = (typeof Company_vendor_capabilitiesScalarFieldEnum)[keyof typeof Company_vendor_capabilitiesScalarFieldEnum]


  export const Company_vendor_capability_sub_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    vendor_capability_id: 'vendor_capability_id',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_vendor_capability_sub_categoriesScalarFieldEnum = (typeof Company_vendor_capability_sub_categoriesScalarFieldEnum)[keyof typeof Company_vendor_capability_sub_categoriesScalarFieldEnum]


  export const Company_vendor_certificationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_vendor_certificationsScalarFieldEnum = (typeof Company_vendor_certificationsScalarFieldEnum)[keyof typeof Company_vendor_certificationsScalarFieldEnum]


  export const Company_vendor_flagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_vendor_flagsScalarFieldEnum = (typeof Company_vendor_flagsScalarFieldEnum)[keyof typeof Company_vendor_flagsScalarFieldEnum]


  export const Company_schoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    class: 'class',
    roll_no: 'roll_no'
  };

  export type Company_schoolScalarFieldEnum = (typeof Company_schoolScalarFieldEnum)[keyof typeof Company_schoolScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'QuoteType'
   */
  export type EnumQuoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteType'>
    


  /**
   * Reference to a field of type 'QuoteType[]'
   */
  export type ListEnumQuoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    roles?: JsonFilter<"User">
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    otps?: PasswordResetOTPListRelationFilter
    resetTokens?: PasswordResetTokenListRelationFilter
    quotes?: QuoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    roles?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    otps?: PasswordResetOTPOrderByRelationAggregateInput
    resetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    roles?: JsonFilter<"User">
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    otps?: PasswordResetOTPListRelationFilter
    resetTokens?: PasswordResetTokenListRelationFilter
    quotes?: QuoteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    roles?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    first_name?: StringWithAggregatesFilter<"User"> | string
    last_name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    roles?: JsonWithAggregatesFilter<"User">
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: StringFilter<"Quote"> | string
    user_id?: StringFilter<"Quote"> | string
    quote_item_id?: IntFilter<"Quote"> | number
    status?: StringNullableFilter<"Quote"> | string | null
    payment_status?: StringNullableFilter<"Quote"> | string | null
    quote_type?: EnumQuoteTypeFilter<"Quote"> | $Enums.QuoteType
    tax?: StringNullableFilter<"Quote"> | string | null
    deposit_paid?: StringNullableFilter<"Quote"> | string | null
    shipping?: StringNullableFilter<"Quote"> | string | null
    tax_buy_price?: StringNullableFilter<"Quote"> | string | null
    shipping_buy_price?: StringNullableFilter<"Quote"> | string | null
    lead_time?: StringNullableFilter<"Quote"> | string | null
    payable?: StringNullableFilter<"Quote"> | string | null
    freight_condition?: StringNullableFilter<"Quote"> | string | null
    freight_condition_dismiss?: BoolNullableFilter<"Quote"> | boolean | null
    customer_email?: StringNullableFilter<"Quote"> | string | null
    emails?: StringNullableFilter<"Quote"> | string | null
    invoice_date?: DateTimeNullableFilter<"Quote"> | Date | string | null
    invoice_email?: StringNullableFilter<"Quote"> | string | null
    billing_name?: StringNullableFilter<"Quote"> | string | null
    billing_company?: StringNullableFilter<"Quote"> | string | null
    billing_address?: StringNullableFilter<"Quote"> | string | null
    billing_city?: StringNullableFilter<"Quote"> | string | null
    billing_state?: StringNullableFilter<"Quote"> | string | null
    billing_country?: StringNullableFilter<"Quote"> | string | null
    billing_zip?: StringNullableFilter<"Quote"> | string | null
    billing_phone?: StringNullableFilter<"Quote"> | string | null
    billing_fax?: StringNullableFilter<"Quote"> | string | null
    shipping_name?: StringNullableFilter<"Quote"> | string | null
    shipping_company?: StringNullableFilter<"Quote"> | string | null
    shipping_address?: StringNullableFilter<"Quote"> | string | null
    shipping_city?: StringNullableFilter<"Quote"> | string | null
    shipping_state?: StringNullableFilter<"Quote"> | string | null
    shipping_country?: StringNullableFilter<"Quote"> | string | null
    shipping_zip?: StringNullableFilter<"Quote"> | string | null
    shipping_phone?: StringNullableFilter<"Quote"> | string | null
    shipping_email?: StringNullableFilter<"Quote"> | string | null
    shipping_fax?: StringNullableFilter<"Quote"> | string | null
    sales_person?: IntNullableFilter<"Quote"> | number | null
    project_manager?: IntNullableFilter<"Quote"> | number | null
    accept_agreement?: IntNullableFilter<"Quote"> | number | null
    date_created?: DateTimeNullableFilter<"Quote"> | Date | string | null
    created_month?: StringNullableFilter<"Quote"> | string | null
    created_year?: StringNullableFilter<"Quote"> | string | null
    created_at?: DateTimeFilter<"Quote"> | Date | string
    updated_at?: DateTimeFilter<"Quote"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Quote"> | Date | string | null
    is_deleted?: BoolNullableFilter<"Quote"> | boolean | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    QuoteItems?: QuoteItemListRelationFilter
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    quote_item_id?: SortOrder
    status?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    quote_type?: SortOrder
    tax?: SortOrderInput | SortOrder
    deposit_paid?: SortOrderInput | SortOrder
    shipping?: SortOrderInput | SortOrder
    tax_buy_price?: SortOrderInput | SortOrder
    shipping_buy_price?: SortOrderInput | SortOrder
    lead_time?: SortOrderInput | SortOrder
    payable?: SortOrderInput | SortOrder
    freight_condition?: SortOrderInput | SortOrder
    freight_condition_dismiss?: SortOrderInput | SortOrder
    customer_email?: SortOrderInput | SortOrder
    emails?: SortOrderInput | SortOrder
    invoice_date?: SortOrderInput | SortOrder
    invoice_email?: SortOrderInput | SortOrder
    billing_name?: SortOrderInput | SortOrder
    billing_company?: SortOrderInput | SortOrder
    billing_address?: SortOrderInput | SortOrder
    billing_city?: SortOrderInput | SortOrder
    billing_state?: SortOrderInput | SortOrder
    billing_country?: SortOrderInput | SortOrder
    billing_zip?: SortOrderInput | SortOrder
    billing_phone?: SortOrderInput | SortOrder
    billing_fax?: SortOrderInput | SortOrder
    shipping_name?: SortOrderInput | SortOrder
    shipping_company?: SortOrderInput | SortOrder
    shipping_address?: SortOrderInput | SortOrder
    shipping_city?: SortOrderInput | SortOrder
    shipping_state?: SortOrderInput | SortOrder
    shipping_country?: SortOrderInput | SortOrder
    shipping_zip?: SortOrderInput | SortOrder
    shipping_phone?: SortOrderInput | SortOrder
    shipping_email?: SortOrderInput | SortOrder
    shipping_fax?: SortOrderInput | SortOrder
    sales_person?: SortOrderInput | SortOrder
    project_manager?: SortOrderInput | SortOrder
    accept_agreement?: SortOrderInput | SortOrder
    date_created?: SortOrderInput | SortOrder
    created_month?: SortOrderInput | SortOrder
    created_year?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_deleted?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    QuoteItems?: QuoteItemOrderByRelationAggregateInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quote_item_id?: number
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    user_id?: StringFilter<"Quote"> | string
    status?: StringNullableFilter<"Quote"> | string | null
    payment_status?: StringNullableFilter<"Quote"> | string | null
    quote_type?: EnumQuoteTypeFilter<"Quote"> | $Enums.QuoteType
    tax?: StringNullableFilter<"Quote"> | string | null
    deposit_paid?: StringNullableFilter<"Quote"> | string | null
    shipping?: StringNullableFilter<"Quote"> | string | null
    tax_buy_price?: StringNullableFilter<"Quote"> | string | null
    shipping_buy_price?: StringNullableFilter<"Quote"> | string | null
    lead_time?: StringNullableFilter<"Quote"> | string | null
    payable?: StringNullableFilter<"Quote"> | string | null
    freight_condition?: StringNullableFilter<"Quote"> | string | null
    freight_condition_dismiss?: BoolNullableFilter<"Quote"> | boolean | null
    customer_email?: StringNullableFilter<"Quote"> | string | null
    emails?: StringNullableFilter<"Quote"> | string | null
    invoice_date?: DateTimeNullableFilter<"Quote"> | Date | string | null
    invoice_email?: StringNullableFilter<"Quote"> | string | null
    billing_name?: StringNullableFilter<"Quote"> | string | null
    billing_company?: StringNullableFilter<"Quote"> | string | null
    billing_address?: StringNullableFilter<"Quote"> | string | null
    billing_city?: StringNullableFilter<"Quote"> | string | null
    billing_state?: StringNullableFilter<"Quote"> | string | null
    billing_country?: StringNullableFilter<"Quote"> | string | null
    billing_zip?: StringNullableFilter<"Quote"> | string | null
    billing_phone?: StringNullableFilter<"Quote"> | string | null
    billing_fax?: StringNullableFilter<"Quote"> | string | null
    shipping_name?: StringNullableFilter<"Quote"> | string | null
    shipping_company?: StringNullableFilter<"Quote"> | string | null
    shipping_address?: StringNullableFilter<"Quote"> | string | null
    shipping_city?: StringNullableFilter<"Quote"> | string | null
    shipping_state?: StringNullableFilter<"Quote"> | string | null
    shipping_country?: StringNullableFilter<"Quote"> | string | null
    shipping_zip?: StringNullableFilter<"Quote"> | string | null
    shipping_phone?: StringNullableFilter<"Quote"> | string | null
    shipping_email?: StringNullableFilter<"Quote"> | string | null
    shipping_fax?: StringNullableFilter<"Quote"> | string | null
    sales_person?: IntNullableFilter<"Quote"> | number | null
    project_manager?: IntNullableFilter<"Quote"> | number | null
    accept_agreement?: IntNullableFilter<"Quote"> | number | null
    date_created?: DateTimeNullableFilter<"Quote"> | Date | string | null
    created_month?: StringNullableFilter<"Quote"> | string | null
    created_year?: StringNullableFilter<"Quote"> | string | null
    created_at?: DateTimeFilter<"Quote"> | Date | string
    updated_at?: DateTimeFilter<"Quote"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Quote"> | Date | string | null
    is_deleted?: BoolNullableFilter<"Quote"> | boolean | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    QuoteItems?: QuoteItemListRelationFilter
  }, "id" | "quote_item_id">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    quote_item_id?: SortOrder
    status?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    quote_type?: SortOrder
    tax?: SortOrderInput | SortOrder
    deposit_paid?: SortOrderInput | SortOrder
    shipping?: SortOrderInput | SortOrder
    tax_buy_price?: SortOrderInput | SortOrder
    shipping_buy_price?: SortOrderInput | SortOrder
    lead_time?: SortOrderInput | SortOrder
    payable?: SortOrderInput | SortOrder
    freight_condition?: SortOrderInput | SortOrder
    freight_condition_dismiss?: SortOrderInput | SortOrder
    customer_email?: SortOrderInput | SortOrder
    emails?: SortOrderInput | SortOrder
    invoice_date?: SortOrderInput | SortOrder
    invoice_email?: SortOrderInput | SortOrder
    billing_name?: SortOrderInput | SortOrder
    billing_company?: SortOrderInput | SortOrder
    billing_address?: SortOrderInput | SortOrder
    billing_city?: SortOrderInput | SortOrder
    billing_state?: SortOrderInput | SortOrder
    billing_country?: SortOrderInput | SortOrder
    billing_zip?: SortOrderInput | SortOrder
    billing_phone?: SortOrderInput | SortOrder
    billing_fax?: SortOrderInput | SortOrder
    shipping_name?: SortOrderInput | SortOrder
    shipping_company?: SortOrderInput | SortOrder
    shipping_address?: SortOrderInput | SortOrder
    shipping_city?: SortOrderInput | SortOrder
    shipping_state?: SortOrderInput | SortOrder
    shipping_country?: SortOrderInput | SortOrder
    shipping_zip?: SortOrderInput | SortOrder
    shipping_phone?: SortOrderInput | SortOrder
    shipping_email?: SortOrderInput | SortOrder
    shipping_fax?: SortOrderInput | SortOrder
    sales_person?: SortOrderInput | SortOrder
    project_manager?: SortOrderInput | SortOrder
    accept_agreement?: SortOrderInput | SortOrder
    date_created?: SortOrderInput | SortOrder
    created_month?: SortOrderInput | SortOrder
    created_year?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_deleted?: SortOrderInput | SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _avg?: QuoteAvgOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
    _sum?: QuoteSumOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quote"> | string
    user_id?: StringWithAggregatesFilter<"Quote"> | string
    quote_item_id?: IntWithAggregatesFilter<"Quote"> | number
    status?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    payment_status?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    quote_type?: EnumQuoteTypeWithAggregatesFilter<"Quote"> | $Enums.QuoteType
    tax?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    deposit_paid?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    tax_buy_price?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_buy_price?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    lead_time?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    payable?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    freight_condition?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    freight_condition_dismiss?: BoolNullableWithAggregatesFilter<"Quote"> | boolean | null
    customer_email?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    emails?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    invoice_date?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    invoice_email?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_name?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_company?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_address?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_city?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_state?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_country?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_zip?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_phone?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    billing_fax?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_name?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_company?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_address?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_city?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_state?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_country?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_zip?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_phone?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_email?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    shipping_fax?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    sales_person?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    project_manager?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    accept_agreement?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    date_created?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    created_month?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    created_year?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    is_deleted?: BoolNullableWithAggregatesFilter<"Quote"> | boolean | null
  }

  export type QuoteItemWhereInput = {
    AND?: QuoteItemWhereInput | QuoteItemWhereInput[]
    OR?: QuoteItemWhereInput[]
    NOT?: QuoteItemWhereInput | QuoteItemWhereInput[]
    id?: StringFilter<"QuoteItem"> | string
    quote_id?: StringFilter<"QuoteItem"> | string
    file_name?: StringNullableFilter<"QuoteItem"> | string | null
    file_url?: StringNullableFilter<"QuoteItem"> | string | null
    status?: BoolFilter<"QuoteItem"> | boolean
    quantity?: IntFilter<"QuoteItem"> | number
    service?: StringNullableFilter<"QuoteItem"> | string | null
    material?: StringNullableFilter<"QuoteItem"> | string | null
    finish?: StringNullableFilter<"QuoteItem"> | string | null
    description?: StringNullableFilter<"QuoteItem"> | string | null
    process?: StringNullableFilter<"QuoteItem"> | string | null
    specification?: StringNullableFilter<"QuoteItem"> | string | null
    price?: StringNullableFilter<"QuoteItem"> | string | null
    cost?: StringNullableFilter<"QuoteItem"> | string | null
    cost_shipping_price?: StringNullableFilter<"QuoteItem"> | string | null
    cost_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    custom_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    buy_price?: StringNullableFilter<"QuoteItem"> | string | null
    buy_shipping_price?: StringNullableFilter<"QuoteItem"> | string | null
    buy_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    quantity_owed?: StringNullableFilter<"QuoteItem"> | string | null
    invoiced?: BoolNullableFilter<"QuoteItem"> | boolean | null
    non_taxable?: IntNullableFilter<"QuoteItem"> | number | null
    non_shipping?: IntNullableFilter<"QuoteItem"> | number | null
    is_deleted?: BoolNullableFilter<"QuoteItem"> | boolean | null
    vendor_id?: StringNullableFilter<"QuoteItem"> | string | null
    vendor_details?: StringNullableFilter<"QuoteItem"> | string | null
    last_updated_by?: IntNullableFilter<"QuoteItem"> | number | null
    work_instructions?: StringNullableFilter<"QuoteItem"> | string | null
    add_vendor?: BoolNullableFilter<"QuoteItem"> | boolean | null
    markings?: StringNullableFilter<"QuoteItem"> | string | null
    part_item_number?: StringNullableFilter<"QuoteItem"> | string | null
    file_year?: StringNullableFilter<"QuoteItem"> | string | null
    file_month?: StringNullableFilter<"QuoteItem"> | string | null
    tab_open?: BoolNullableFilter<"QuoteItem"> | boolean | null
    created_at?: DateTimeFilter<"QuoteItem"> | Date | string
    updated_at?: DateTimeFilter<"QuoteItem"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuoteItem"> | Date | string | null
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }

  export type QuoteItemOrderByWithRelationInput = {
    id?: SortOrder
    quote_id?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    status?: SortOrder
    quantity?: SortOrder
    service?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    finish?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    process?: SortOrderInput | SortOrder
    specification?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    cost_shipping_price?: SortOrderInput | SortOrder
    cost_shipping_total?: SortOrderInput | SortOrder
    custom_shipping_total?: SortOrderInput | SortOrder
    buy_price?: SortOrderInput | SortOrder
    buy_shipping_price?: SortOrderInput | SortOrder
    buy_shipping_total?: SortOrderInput | SortOrder
    quantity_owed?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    non_taxable?: SortOrderInput | SortOrder
    non_shipping?: SortOrderInput | SortOrder
    is_deleted?: SortOrderInput | SortOrder
    vendor_id?: SortOrderInput | SortOrder
    vendor_details?: SortOrderInput | SortOrder
    last_updated_by?: SortOrderInput | SortOrder
    work_instructions?: SortOrderInput | SortOrder
    add_vendor?: SortOrderInput | SortOrder
    markings?: SortOrderInput | SortOrder
    part_item_number?: SortOrderInput | SortOrder
    file_year?: SortOrderInput | SortOrder
    file_month?: SortOrderInput | SortOrder
    tab_open?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    quote?: QuoteOrderByWithRelationInput
  }

  export type QuoteItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuoteItemWhereInput | QuoteItemWhereInput[]
    OR?: QuoteItemWhereInput[]
    NOT?: QuoteItemWhereInput | QuoteItemWhereInput[]
    quote_id?: StringFilter<"QuoteItem"> | string
    file_name?: StringNullableFilter<"QuoteItem"> | string | null
    file_url?: StringNullableFilter<"QuoteItem"> | string | null
    status?: BoolFilter<"QuoteItem"> | boolean
    quantity?: IntFilter<"QuoteItem"> | number
    service?: StringNullableFilter<"QuoteItem"> | string | null
    material?: StringNullableFilter<"QuoteItem"> | string | null
    finish?: StringNullableFilter<"QuoteItem"> | string | null
    description?: StringNullableFilter<"QuoteItem"> | string | null
    process?: StringNullableFilter<"QuoteItem"> | string | null
    specification?: StringNullableFilter<"QuoteItem"> | string | null
    price?: StringNullableFilter<"QuoteItem"> | string | null
    cost?: StringNullableFilter<"QuoteItem"> | string | null
    cost_shipping_price?: StringNullableFilter<"QuoteItem"> | string | null
    cost_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    custom_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    buy_price?: StringNullableFilter<"QuoteItem"> | string | null
    buy_shipping_price?: StringNullableFilter<"QuoteItem"> | string | null
    buy_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    quantity_owed?: StringNullableFilter<"QuoteItem"> | string | null
    invoiced?: BoolNullableFilter<"QuoteItem"> | boolean | null
    non_taxable?: IntNullableFilter<"QuoteItem"> | number | null
    non_shipping?: IntNullableFilter<"QuoteItem"> | number | null
    is_deleted?: BoolNullableFilter<"QuoteItem"> | boolean | null
    vendor_id?: StringNullableFilter<"QuoteItem"> | string | null
    vendor_details?: StringNullableFilter<"QuoteItem"> | string | null
    last_updated_by?: IntNullableFilter<"QuoteItem"> | number | null
    work_instructions?: StringNullableFilter<"QuoteItem"> | string | null
    add_vendor?: BoolNullableFilter<"QuoteItem"> | boolean | null
    markings?: StringNullableFilter<"QuoteItem"> | string | null
    part_item_number?: StringNullableFilter<"QuoteItem"> | string | null
    file_year?: StringNullableFilter<"QuoteItem"> | string | null
    file_month?: StringNullableFilter<"QuoteItem"> | string | null
    tab_open?: BoolNullableFilter<"QuoteItem"> | boolean | null
    created_at?: DateTimeFilter<"QuoteItem"> | Date | string
    updated_at?: DateTimeFilter<"QuoteItem"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuoteItem"> | Date | string | null
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }, "id">

  export type QuoteItemOrderByWithAggregationInput = {
    id?: SortOrder
    quote_id?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    status?: SortOrder
    quantity?: SortOrder
    service?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    finish?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    process?: SortOrderInput | SortOrder
    specification?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    cost_shipping_price?: SortOrderInput | SortOrder
    cost_shipping_total?: SortOrderInput | SortOrder
    custom_shipping_total?: SortOrderInput | SortOrder
    buy_price?: SortOrderInput | SortOrder
    buy_shipping_price?: SortOrderInput | SortOrder
    buy_shipping_total?: SortOrderInput | SortOrder
    quantity_owed?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    non_taxable?: SortOrderInput | SortOrder
    non_shipping?: SortOrderInput | SortOrder
    is_deleted?: SortOrderInput | SortOrder
    vendor_id?: SortOrderInput | SortOrder
    vendor_details?: SortOrderInput | SortOrder
    last_updated_by?: SortOrderInput | SortOrder
    work_instructions?: SortOrderInput | SortOrder
    add_vendor?: SortOrderInput | SortOrder
    markings?: SortOrderInput | SortOrder
    part_item_number?: SortOrderInput | SortOrder
    file_year?: SortOrderInput | SortOrder
    file_month?: SortOrderInput | SortOrder
    tab_open?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: QuoteItemCountOrderByAggregateInput
    _avg?: QuoteItemAvgOrderByAggregateInput
    _max?: QuoteItemMaxOrderByAggregateInput
    _min?: QuoteItemMinOrderByAggregateInput
    _sum?: QuoteItemSumOrderByAggregateInput
  }

  export type QuoteItemScalarWhereWithAggregatesInput = {
    AND?: QuoteItemScalarWhereWithAggregatesInput | QuoteItemScalarWhereWithAggregatesInput[]
    OR?: QuoteItemScalarWhereWithAggregatesInput[]
    NOT?: QuoteItemScalarWhereWithAggregatesInput | QuoteItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuoteItem"> | string
    quote_id?: StringWithAggregatesFilter<"QuoteItem"> | string
    file_name?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    file_url?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    status?: BoolWithAggregatesFilter<"QuoteItem"> | boolean
    quantity?: IntWithAggregatesFilter<"QuoteItem"> | number
    service?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    material?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    finish?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    description?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    process?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    specification?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    price?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    cost?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    cost_shipping_price?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    cost_shipping_total?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    custom_shipping_total?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    buy_price?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    buy_shipping_price?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    buy_shipping_total?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    quantity_owed?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    invoiced?: BoolNullableWithAggregatesFilter<"QuoteItem"> | boolean | null
    non_taxable?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    non_shipping?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    is_deleted?: BoolNullableWithAggregatesFilter<"QuoteItem"> | boolean | null
    vendor_id?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    vendor_details?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    last_updated_by?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    work_instructions?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    add_vendor?: BoolNullableWithAggregatesFilter<"QuoteItem"> | boolean | null
    markings?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    part_item_number?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    file_year?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    file_month?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    tab_open?: BoolNullableWithAggregatesFilter<"QuoteItem"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"QuoteItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"QuoteItem"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"QuoteItem"> | Date | string | null
  }

  export type PasswordResetOTPWhereInput = {
    AND?: PasswordResetOTPWhereInput | PasswordResetOTPWhereInput[]
    OR?: PasswordResetOTPWhereInput[]
    NOT?: PasswordResetOTPWhereInput | PasswordResetOTPWhereInput[]
    id?: StringFilter<"PasswordResetOTP"> | string
    email?: StringFilter<"PasswordResetOTP"> | string
    otp?: StringFilter<"PasswordResetOTP"> | string
    request_id?: StringFilter<"PasswordResetOTP"> | string
    expires_at?: DateTimeFilter<"PasswordResetOTP"> | Date | string
    created_at?: DateTimeFilter<"PasswordResetOTP"> | Date | string
    user_id?: StringFilter<"PasswordResetOTP"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetOTPOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    request_id?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetOTPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    request_id?: string
    AND?: PasswordResetOTPWhereInput | PasswordResetOTPWhereInput[]
    OR?: PasswordResetOTPWhereInput[]
    NOT?: PasswordResetOTPWhereInput | PasswordResetOTPWhereInput[]
    email?: StringFilter<"PasswordResetOTP"> | string
    otp?: StringFilter<"PasswordResetOTP"> | string
    expires_at?: DateTimeFilter<"PasswordResetOTP"> | Date | string
    created_at?: DateTimeFilter<"PasswordResetOTP"> | Date | string
    user_id?: StringFilter<"PasswordResetOTP"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "request_id">

  export type PasswordResetOTPOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    request_id?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    _count?: PasswordResetOTPCountOrderByAggregateInput
    _max?: PasswordResetOTPMaxOrderByAggregateInput
    _min?: PasswordResetOTPMinOrderByAggregateInput
  }

  export type PasswordResetOTPScalarWhereWithAggregatesInput = {
    AND?: PasswordResetOTPScalarWhereWithAggregatesInput | PasswordResetOTPScalarWhereWithAggregatesInput[]
    OR?: PasswordResetOTPScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetOTPScalarWhereWithAggregatesInput | PasswordResetOTPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetOTP"> | string
    email?: StringWithAggregatesFilter<"PasswordResetOTP"> | string
    otp?: StringWithAggregatesFilter<"PasswordResetOTP"> | string
    request_id?: StringWithAggregatesFilter<"PasswordResetOTP"> | string
    expires_at?: DateTimeWithAggregatesFilter<"PasswordResetOTP"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"PasswordResetOTP"> | Date | string
    user_id?: StringWithAggregatesFilter<"PasswordResetOTP"> | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    user_id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires_at?: DateTimeFilter<"PasswordResetToken"> | Date | string
    created_at?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    user_id?: StringFilter<"PasswordResetToken"> | string
    expires_at?: DateTimeFilter<"PasswordResetToken"> | Date | string
    created_at?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    user_id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires_at?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type tenantCurrencyWhereInput = {
    AND?: tenantCurrencyWhereInput | tenantCurrencyWhereInput[]
    OR?: tenantCurrencyWhereInput[]
    NOT?: tenantCurrencyWhereInput | tenantCurrencyWhereInput[]
    id?: StringFilter<"tenantCurrency"> | string
    currency_id?: IntFilter<"tenantCurrency"> | number
    code?: StringFilter<"tenantCurrency"> | string
    name?: StringFilter<"tenantCurrency"> | string
    symbol?: StringFilter<"tenantCurrency"> | string
    is_active?: BoolFilter<"tenantCurrency"> | boolean
    created_at?: DateTimeFilter<"tenantCurrency"> | Date | string
    updated_at?: DateTimeFilter<"tenantCurrency"> | Date | string
  }

  export type tenantCurrencyOrderByWithRelationInput = {
    id?: SortOrder
    currency_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantCurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tenantCurrencyWhereInput | tenantCurrencyWhereInput[]
    OR?: tenantCurrencyWhereInput[]
    NOT?: tenantCurrencyWhereInput | tenantCurrencyWhereInput[]
    currency_id?: IntFilter<"tenantCurrency"> | number
    code?: StringFilter<"tenantCurrency"> | string
    name?: StringFilter<"tenantCurrency"> | string
    symbol?: StringFilter<"tenantCurrency"> | string
    is_active?: BoolFilter<"tenantCurrency"> | boolean
    created_at?: DateTimeFilter<"tenantCurrency"> | Date | string
    updated_at?: DateTimeFilter<"tenantCurrency"> | Date | string
  }, "id">

  export type tenantCurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    currency_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tenantCurrencyCountOrderByAggregateInput
    _avg?: tenantCurrencyAvgOrderByAggregateInput
    _max?: tenantCurrencyMaxOrderByAggregateInput
    _min?: tenantCurrencyMinOrderByAggregateInput
    _sum?: tenantCurrencySumOrderByAggregateInput
  }

  export type tenantCurrencyScalarWhereWithAggregatesInput = {
    AND?: tenantCurrencyScalarWhereWithAggregatesInput | tenantCurrencyScalarWhereWithAggregatesInput[]
    OR?: tenantCurrencyScalarWhereWithAggregatesInput[]
    NOT?: tenantCurrencyScalarWhereWithAggregatesInput | tenantCurrencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenantCurrency"> | string
    currency_id?: IntWithAggregatesFilter<"tenantCurrency"> | number
    code?: StringWithAggregatesFilter<"tenantCurrency"> | string
    name?: StringWithAggregatesFilter<"tenantCurrency"> | string
    symbol?: StringWithAggregatesFilter<"tenantCurrency"> | string
    is_active?: BoolWithAggregatesFilter<"tenantCurrency"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"tenantCurrency"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tenantCurrency"> | Date | string
  }

  export type tenantPaymentTermsWhereInput = {
    AND?: tenantPaymentTermsWhereInput | tenantPaymentTermsWhereInput[]
    OR?: tenantPaymentTermsWhereInput[]
    NOT?: tenantPaymentTermsWhereInput | tenantPaymentTermsWhereInput[]
    id?: StringFilter<"tenantPaymentTerms"> | string
    payment_terms_id?: IntFilter<"tenantPaymentTerms"> | number
    name?: StringFilter<"tenantPaymentTerms"> | string
    description?: StringNullableFilter<"tenantPaymentTerms"> | string | null
    due_days?: IntFilter<"tenantPaymentTerms"> | number
    discount_days?: IntFilter<"tenantPaymentTerms"> | number
    discount_percent?: DecimalFilter<"tenantPaymentTerms"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"tenantPaymentTerms"> | boolean
    created_at?: DateTimeFilter<"tenantPaymentTerms"> | Date | string
    updated_at?: DateTimeFilter<"tenantPaymentTerms"> | Date | string
  }

  export type tenantPaymentTermsOrderByWithRelationInput = {
    id?: SortOrder
    payment_terms_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    due_days?: SortOrder
    discount_days?: SortOrder
    discount_percent?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantPaymentTermsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tenantPaymentTermsWhereInput | tenantPaymentTermsWhereInput[]
    OR?: tenantPaymentTermsWhereInput[]
    NOT?: tenantPaymentTermsWhereInput | tenantPaymentTermsWhereInput[]
    payment_terms_id?: IntFilter<"tenantPaymentTerms"> | number
    name?: StringFilter<"tenantPaymentTerms"> | string
    description?: StringNullableFilter<"tenantPaymentTerms"> | string | null
    due_days?: IntFilter<"tenantPaymentTerms"> | number
    discount_days?: IntFilter<"tenantPaymentTerms"> | number
    discount_percent?: DecimalFilter<"tenantPaymentTerms"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"tenantPaymentTerms"> | boolean
    created_at?: DateTimeFilter<"tenantPaymentTerms"> | Date | string
    updated_at?: DateTimeFilter<"tenantPaymentTerms"> | Date | string
  }, "id">

  export type tenantPaymentTermsOrderByWithAggregationInput = {
    id?: SortOrder
    payment_terms_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    due_days?: SortOrder
    discount_days?: SortOrder
    discount_percent?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tenantPaymentTermsCountOrderByAggregateInput
    _avg?: tenantPaymentTermsAvgOrderByAggregateInput
    _max?: tenantPaymentTermsMaxOrderByAggregateInput
    _min?: tenantPaymentTermsMinOrderByAggregateInput
    _sum?: tenantPaymentTermsSumOrderByAggregateInput
  }

  export type tenantPaymentTermsScalarWhereWithAggregatesInput = {
    AND?: tenantPaymentTermsScalarWhereWithAggregatesInput | tenantPaymentTermsScalarWhereWithAggregatesInput[]
    OR?: tenantPaymentTermsScalarWhereWithAggregatesInput[]
    NOT?: tenantPaymentTermsScalarWhereWithAggregatesInput | tenantPaymentTermsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenantPaymentTerms"> | string
    payment_terms_id?: IntWithAggregatesFilter<"tenantPaymentTerms"> | number
    name?: StringWithAggregatesFilter<"tenantPaymentTerms"> | string
    description?: StringNullableWithAggregatesFilter<"tenantPaymentTerms"> | string | null
    due_days?: IntWithAggregatesFilter<"tenantPaymentTerms"> | number
    discount_days?: IntWithAggregatesFilter<"tenantPaymentTerms"> | number
    discount_percent?: DecimalWithAggregatesFilter<"tenantPaymentTerms"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolWithAggregatesFilter<"tenantPaymentTerms"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"tenantPaymentTerms"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tenantPaymentTerms"> | Date | string
  }

  export type tenantPaymentStatusWhereInput = {
    AND?: tenantPaymentStatusWhereInput | tenantPaymentStatusWhereInput[]
    OR?: tenantPaymentStatusWhereInput[]
    NOT?: tenantPaymentStatusWhereInput | tenantPaymentStatusWhereInput[]
    id?: StringFilter<"tenantPaymentStatus"> | string
    name?: StringFilter<"tenantPaymentStatus"> | string
    is_active?: BoolFilter<"tenantPaymentStatus"> | boolean
    created_at?: DateTimeFilter<"tenantPaymentStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantPaymentStatus"> | Date | string
  }

  export type tenantPaymentStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantPaymentStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tenantPaymentStatusWhereInput | tenantPaymentStatusWhereInput[]
    OR?: tenantPaymentStatusWhereInput[]
    NOT?: tenantPaymentStatusWhereInput | tenantPaymentStatusWhereInput[]
    name?: StringFilter<"tenantPaymentStatus"> | string
    is_active?: BoolFilter<"tenantPaymentStatus"> | boolean
    created_at?: DateTimeFilter<"tenantPaymentStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantPaymentStatus"> | Date | string
  }, "id">

  export type tenantPaymentStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tenantPaymentStatusCountOrderByAggregateInput
    _max?: tenantPaymentStatusMaxOrderByAggregateInput
    _min?: tenantPaymentStatusMinOrderByAggregateInput
  }

  export type tenantPaymentStatusScalarWhereWithAggregatesInput = {
    AND?: tenantPaymentStatusScalarWhereWithAggregatesInput | tenantPaymentStatusScalarWhereWithAggregatesInput[]
    OR?: tenantPaymentStatusScalarWhereWithAggregatesInput[]
    NOT?: tenantPaymentStatusScalarWhereWithAggregatesInput | tenantPaymentStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenantPaymentStatus"> | string
    name?: StringWithAggregatesFilter<"tenantPaymentStatus"> | string
    is_active?: BoolWithAggregatesFilter<"tenantPaymentStatus"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"tenantPaymentStatus"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tenantPaymentStatus"> | Date | string
  }

  export type tenantQuoteStatusWhereInput = {
    AND?: tenantQuoteStatusWhereInput | tenantQuoteStatusWhereInput[]
    OR?: tenantQuoteStatusWhereInput[]
    NOT?: tenantQuoteStatusWhereInput | tenantQuoteStatusWhereInput[]
    id?: StringFilter<"tenantQuoteStatus"> | string
    name?: StringFilter<"tenantQuoteStatus"> | string
    is_active?: BoolFilter<"tenantQuoteStatus"> | boolean
    created_at?: DateTimeFilter<"tenantQuoteStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantQuoteStatus"> | Date | string
  }

  export type tenantQuoteStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantQuoteStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tenantQuoteStatusWhereInput | tenantQuoteStatusWhereInput[]
    OR?: tenantQuoteStatusWhereInput[]
    NOT?: tenantQuoteStatusWhereInput | tenantQuoteStatusWhereInput[]
    name?: StringFilter<"tenantQuoteStatus"> | string
    is_active?: BoolFilter<"tenantQuoteStatus"> | boolean
    created_at?: DateTimeFilter<"tenantQuoteStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantQuoteStatus"> | Date | string
  }, "id">

  export type tenantQuoteStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tenantQuoteStatusCountOrderByAggregateInput
    _max?: tenantQuoteStatusMaxOrderByAggregateInput
    _min?: tenantQuoteStatusMinOrderByAggregateInput
  }

  export type tenantQuoteStatusScalarWhereWithAggregatesInput = {
    AND?: tenantQuoteStatusScalarWhereWithAggregatesInput | tenantQuoteStatusScalarWhereWithAggregatesInput[]
    OR?: tenantQuoteStatusScalarWhereWithAggregatesInput[]
    NOT?: tenantQuoteStatusScalarWhereWithAggregatesInput | tenantQuoteStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenantQuoteStatus"> | string
    name?: StringWithAggregatesFilter<"tenantQuoteStatus"> | string
    is_active?: BoolWithAggregatesFilter<"tenantQuoteStatus"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"tenantQuoteStatus"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tenantQuoteStatus"> | Date | string
  }

  export type tenantOrderStatusWhereInput = {
    AND?: tenantOrderStatusWhereInput | tenantOrderStatusWhereInput[]
    OR?: tenantOrderStatusWhereInput[]
    NOT?: tenantOrderStatusWhereInput | tenantOrderStatusWhereInput[]
    id?: StringFilter<"tenantOrderStatus"> | string
    name?: StringFilter<"tenantOrderStatus"> | string
    is_active?: BoolFilter<"tenantOrderStatus"> | boolean
    created_at?: DateTimeFilter<"tenantOrderStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantOrderStatus"> | Date | string
  }

  export type tenantOrderStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantOrderStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tenantOrderStatusWhereInput | tenantOrderStatusWhereInput[]
    OR?: tenantOrderStatusWhereInput[]
    NOT?: tenantOrderStatusWhereInput | tenantOrderStatusWhereInput[]
    name?: StringFilter<"tenantOrderStatus"> | string
    is_active?: BoolFilter<"tenantOrderStatus"> | boolean
    created_at?: DateTimeFilter<"tenantOrderStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantOrderStatus"> | Date | string
  }, "id">

  export type tenantOrderStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tenantOrderStatusCountOrderByAggregateInput
    _max?: tenantOrderStatusMaxOrderByAggregateInput
    _min?: tenantOrderStatusMinOrderByAggregateInput
  }

  export type tenantOrderStatusScalarWhereWithAggregatesInput = {
    AND?: tenantOrderStatusScalarWhereWithAggregatesInput | tenantOrderStatusScalarWhereWithAggregatesInput[]
    OR?: tenantOrderStatusScalarWhereWithAggregatesInput[]
    NOT?: tenantOrderStatusScalarWhereWithAggregatesInput | tenantOrderStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenantOrderStatus"> | string
    name?: StringWithAggregatesFilter<"tenantOrderStatus"> | string
    is_active?: BoolWithAggregatesFilter<"tenantOrderStatus"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"tenantOrderStatus"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tenantOrderStatus"> | Date | string
  }

  export type tenantLogisticsStatusWhereInput = {
    AND?: tenantLogisticsStatusWhereInput | tenantLogisticsStatusWhereInput[]
    OR?: tenantLogisticsStatusWhereInput[]
    NOT?: tenantLogisticsStatusWhereInput | tenantLogisticsStatusWhereInput[]
    id?: StringFilter<"tenantLogisticsStatus"> | string
    name?: StringFilter<"tenantLogisticsStatus"> | string
    is_active?: BoolFilter<"tenantLogisticsStatus"> | boolean
    created_at?: DateTimeFilter<"tenantLogisticsStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantLogisticsStatus"> | Date | string
  }

  export type tenantLogisticsStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantLogisticsStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tenantLogisticsStatusWhereInput | tenantLogisticsStatusWhereInput[]
    OR?: tenantLogisticsStatusWhereInput[]
    NOT?: tenantLogisticsStatusWhereInput | tenantLogisticsStatusWhereInput[]
    name?: StringFilter<"tenantLogisticsStatus"> | string
    is_active?: BoolFilter<"tenantLogisticsStatus"> | boolean
    created_at?: DateTimeFilter<"tenantLogisticsStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantLogisticsStatus"> | Date | string
  }, "id">

  export type tenantLogisticsStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tenantLogisticsStatusCountOrderByAggregateInput
    _max?: tenantLogisticsStatusMaxOrderByAggregateInput
    _min?: tenantLogisticsStatusMinOrderByAggregateInput
  }

  export type tenantLogisticsStatusScalarWhereWithAggregatesInput = {
    AND?: tenantLogisticsStatusScalarWhereWithAggregatesInput | tenantLogisticsStatusScalarWhereWithAggregatesInput[]
    OR?: tenantLogisticsStatusScalarWhereWithAggregatesInput[]
    NOT?: tenantLogisticsStatusScalarWhereWithAggregatesInput | tenantLogisticsStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenantLogisticsStatus"> | string
    name?: StringWithAggregatesFilter<"tenantLogisticsStatus"> | string
    is_active?: BoolWithAggregatesFilter<"tenantLogisticsStatus"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"tenantLogisticsStatus"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tenantLogisticsStatus"> | Date | string
  }

  export type tenantFinanceStatusWhereInput = {
    AND?: tenantFinanceStatusWhereInput | tenantFinanceStatusWhereInput[]
    OR?: tenantFinanceStatusWhereInput[]
    NOT?: tenantFinanceStatusWhereInput | tenantFinanceStatusWhereInput[]
    id?: StringFilter<"tenantFinanceStatus"> | string
    name?: StringFilter<"tenantFinanceStatus"> | string
    is_active?: BoolFilter<"tenantFinanceStatus"> | boolean
    created_at?: DateTimeFilter<"tenantFinanceStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantFinanceStatus"> | Date | string
  }

  export type tenantFinanceStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantFinanceStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tenantFinanceStatusWhereInput | tenantFinanceStatusWhereInput[]
    OR?: tenantFinanceStatusWhereInput[]
    NOT?: tenantFinanceStatusWhereInput | tenantFinanceStatusWhereInput[]
    name?: StringFilter<"tenantFinanceStatus"> | string
    is_active?: BoolFilter<"tenantFinanceStatus"> | boolean
    created_at?: DateTimeFilter<"tenantFinanceStatus"> | Date | string
    updated_at?: DateTimeFilter<"tenantFinanceStatus"> | Date | string
  }, "id">

  export type tenantFinanceStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tenantFinanceStatusCountOrderByAggregateInput
    _max?: tenantFinanceStatusMaxOrderByAggregateInput
    _min?: tenantFinanceStatusMinOrderByAggregateInput
  }

  export type tenantFinanceStatusScalarWhereWithAggregatesInput = {
    AND?: tenantFinanceStatusScalarWhereWithAggregatesInput | tenantFinanceStatusScalarWhereWithAggregatesInput[]
    OR?: tenantFinanceStatusScalarWhereWithAggregatesInput[]
    NOT?: tenantFinanceStatusScalarWhereWithAggregatesInput | tenantFinanceStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenantFinanceStatus"> | string
    name?: StringWithAggregatesFilter<"tenantFinanceStatus"> | string
    is_active?: BoolWithAggregatesFilter<"tenantFinanceStatus"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"tenantFinanceStatus"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tenantFinanceStatus"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    customer_id?: IntFilter<"Customer"> | number
    first_name?: StringFilter<"Customer"> | string
    last_name?: StringFilter<"Customer"> | string
    customer_name?: StringFilter<"Customer"> | string
    company_name?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    type?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    is_active?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    sorting?: IntFilter<"Customer"> | number
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Customer"> | Date | string | null
    user_id?: StringNullableFilter<"Customer"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    addresses?: CustomerAddressListRelationFilter
    tax_info?: XOR<CustomerTaxInfoNullableScalarRelationFilter, CustomerTaxInfoWhereInput> | null
    contacts?: CustomerContactListRelationFilter
    operational?: XOR<CustomerOperationalInfoNullableScalarRelationFilter, CustomerOperationalInfoWhereInput> | null
    attachments?: CustomerNotesAndAttachmentsListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    customer_name?: SortOrder
    company_name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    is_active?: SortOrder
    notes?: SortOrderInput | SortOrder
    sorting?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    addresses?: CustomerAddressOrderByRelationAggregateInput
    tax_info?: CustomerTaxInfoOrderByWithRelationInput
    contacts?: CustomerContactOrderByRelationAggregateInput
    operational?: CustomerOperationalInfoOrderByWithRelationInput
    attachments?: CustomerNotesAndAttachmentsOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    user_id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    customer_id?: IntFilter<"Customer"> | number
    first_name?: StringFilter<"Customer"> | string
    last_name?: StringFilter<"Customer"> | string
    customer_name?: StringFilter<"Customer"> | string
    company_name?: StringNullableFilter<"Customer"> | string | null
    password?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    type?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    is_active?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    sorting?: IntFilter<"Customer"> | number
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Customer"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    addresses?: CustomerAddressListRelationFilter
    tax_info?: XOR<CustomerTaxInfoNullableScalarRelationFilter, CustomerTaxInfoWhereInput> | null
    contacts?: CustomerContactListRelationFilter
    operational?: XOR<CustomerOperationalInfoNullableScalarRelationFilter, CustomerOperationalInfoWhereInput> | null
    attachments?: CustomerNotesAndAttachmentsListRelationFilter
  }, "id" | "email" | "user_id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    customer_name?: SortOrder
    company_name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    is_active?: SortOrder
    notes?: SortOrderInput | SortOrder
    sorting?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    customer_id?: IntWithAggregatesFilter<"Customer"> | number
    first_name?: StringWithAggregatesFilter<"Customer"> | string
    last_name?: StringWithAggregatesFilter<"Customer"> | string
    customer_name?: StringWithAggregatesFilter<"Customer"> | string
    company_name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringWithAggregatesFilter<"Customer"> | string
    password?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    type?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    website?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    is_active?: StringWithAggregatesFilter<"Customer"> | string
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    sorting?: IntWithAggregatesFilter<"Customer"> | number
    created_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    user_id?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type companyServiceWhereInput = {
    AND?: companyServiceWhereInput | companyServiceWhereInput[]
    OR?: companyServiceWhereInput[]
    NOT?: companyServiceWhereInput | companyServiceWhereInput[]
    id?: StringFilter<"companyService"> | string
    exclude_inspection?: BoolFilter<"companyService"> | boolean
    invoice50?: BoolFilter<"companyService"> | boolean
    fob_china?: BoolFilter<"companyService"> | boolean
    require_deposit_invoice?: BoolFilter<"companyService"> | boolean
    name?: StringFilter<"companyService"> | string
    created_at?: DateTimeFilter<"companyService"> | Date | string
    updated_at?: DateTimeFilter<"companyService"> | Date | string
    materials?: CompanyMaterialListRelationFilter
    finishes?: CompanyFinishListRelationFilter
  }

  export type companyServiceOrderByWithRelationInput = {
    id?: SortOrder
    exclude_inspection?: SortOrder
    invoice50?: SortOrder
    fob_china?: SortOrder
    require_deposit_invoice?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    materials?: companyMaterialOrderByRelationAggregateInput
    finishes?: companyFinishOrderByRelationAggregateInput
  }

  export type companyServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: companyServiceWhereInput | companyServiceWhereInput[]
    OR?: companyServiceWhereInput[]
    NOT?: companyServiceWhereInput | companyServiceWhereInput[]
    exclude_inspection?: BoolFilter<"companyService"> | boolean
    invoice50?: BoolFilter<"companyService"> | boolean
    fob_china?: BoolFilter<"companyService"> | boolean
    require_deposit_invoice?: BoolFilter<"companyService"> | boolean
    name?: StringFilter<"companyService"> | string
    created_at?: DateTimeFilter<"companyService"> | Date | string
    updated_at?: DateTimeFilter<"companyService"> | Date | string
    materials?: CompanyMaterialListRelationFilter
    finishes?: CompanyFinishListRelationFilter
  }, "id">

  export type companyServiceOrderByWithAggregationInput = {
    id?: SortOrder
    exclude_inspection?: SortOrder
    invoice50?: SortOrder
    fob_china?: SortOrder
    require_deposit_invoice?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: companyServiceCountOrderByAggregateInput
    _max?: companyServiceMaxOrderByAggregateInput
    _min?: companyServiceMinOrderByAggregateInput
  }

  export type companyServiceScalarWhereWithAggregatesInput = {
    AND?: companyServiceScalarWhereWithAggregatesInput | companyServiceScalarWhereWithAggregatesInput[]
    OR?: companyServiceScalarWhereWithAggregatesInput[]
    NOT?: companyServiceScalarWhereWithAggregatesInput | companyServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"companyService"> | string
    exclude_inspection?: BoolWithAggregatesFilter<"companyService"> | boolean
    invoice50?: BoolWithAggregatesFilter<"companyService"> | boolean
    fob_china?: BoolWithAggregatesFilter<"companyService"> | boolean
    require_deposit_invoice?: BoolWithAggregatesFilter<"companyService"> | boolean
    name?: StringWithAggregatesFilter<"companyService"> | string
    created_at?: DateTimeWithAggregatesFilter<"companyService"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"companyService"> | Date | string
  }

  export type companyMaterialWhereInput = {
    AND?: companyMaterialWhereInput | companyMaterialWhereInput[]
    OR?: companyMaterialWhereInput[]
    NOT?: companyMaterialWhereInput | companyMaterialWhereInput[]
    id?: StringFilter<"companyMaterial"> | string
    service_id?: StringFilter<"companyMaterial"> | string
    name?: StringNullableFilter<"companyMaterial"> | string | null
    created_at?: DateTimeFilter<"companyMaterial"> | Date | string
    updated_at?: DateTimeFilter<"companyMaterial"> | Date | string
    service?: XOR<CompanyServiceScalarRelationFilter, companyServiceWhereInput>
  }

  export type companyMaterialOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    service?: companyServiceOrderByWithRelationInput
  }

  export type companyMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: companyMaterialWhereInput | companyMaterialWhereInput[]
    OR?: companyMaterialWhereInput[]
    NOT?: companyMaterialWhereInput | companyMaterialWhereInput[]
    service_id?: StringFilter<"companyMaterial"> | string
    name?: StringNullableFilter<"companyMaterial"> | string | null
    created_at?: DateTimeFilter<"companyMaterial"> | Date | string
    updated_at?: DateTimeFilter<"companyMaterial"> | Date | string
    service?: XOR<CompanyServiceScalarRelationFilter, companyServiceWhereInput>
  }, "id">

  export type companyMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: companyMaterialCountOrderByAggregateInput
    _max?: companyMaterialMaxOrderByAggregateInput
    _min?: companyMaterialMinOrderByAggregateInput
  }

  export type companyMaterialScalarWhereWithAggregatesInput = {
    AND?: companyMaterialScalarWhereWithAggregatesInput | companyMaterialScalarWhereWithAggregatesInput[]
    OR?: companyMaterialScalarWhereWithAggregatesInput[]
    NOT?: companyMaterialScalarWhereWithAggregatesInput | companyMaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"companyMaterial"> | string
    service_id?: StringWithAggregatesFilter<"companyMaterial"> | string
    name?: StringNullableWithAggregatesFilter<"companyMaterial"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"companyMaterial"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"companyMaterial"> | Date | string
  }

  export type companyFinishWhereInput = {
    AND?: companyFinishWhereInput | companyFinishWhereInput[]
    OR?: companyFinishWhereInput[]
    NOT?: companyFinishWhereInput | companyFinishWhereInput[]
    id?: StringFilter<"companyFinish"> | string
    service_id?: StringFilter<"companyFinish"> | string
    name?: StringNullableFilter<"companyFinish"> | string | null
    created_at?: DateTimeFilter<"companyFinish"> | Date | string
    updated_at?: DateTimeFilter<"companyFinish"> | Date | string
    service?: XOR<CompanyServiceScalarRelationFilter, companyServiceWhereInput>
  }

  export type companyFinishOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    service?: companyServiceOrderByWithRelationInput
  }

  export type companyFinishWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: companyFinishWhereInput | companyFinishWhereInput[]
    OR?: companyFinishWhereInput[]
    NOT?: companyFinishWhereInput | companyFinishWhereInput[]
    service_id?: StringFilter<"companyFinish"> | string
    name?: StringNullableFilter<"companyFinish"> | string | null
    created_at?: DateTimeFilter<"companyFinish"> | Date | string
    updated_at?: DateTimeFilter<"companyFinish"> | Date | string
    service?: XOR<CompanyServiceScalarRelationFilter, companyServiceWhereInput>
  }, "id">

  export type companyFinishOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: companyFinishCountOrderByAggregateInput
    _max?: companyFinishMaxOrderByAggregateInput
    _min?: companyFinishMinOrderByAggregateInput
  }

  export type companyFinishScalarWhereWithAggregatesInput = {
    AND?: companyFinishScalarWhereWithAggregatesInput | companyFinishScalarWhereWithAggregatesInput[]
    OR?: companyFinishScalarWhereWithAggregatesInput[]
    NOT?: companyFinishScalarWhereWithAggregatesInput | companyFinishScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"companyFinish"> | string
    service_id?: StringWithAggregatesFilter<"companyFinish"> | string
    name?: StringNullableWithAggregatesFilter<"companyFinish"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"companyFinish"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"companyFinish"> | Date | string
  }

  export type CustomerAddressWhereInput = {
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customer_id?: StringFilter<"CustomerAddress"> | string
    billing_address?: StringFilter<"CustomerAddress"> | string
    billing_address2?: StringNullableFilter<"CustomerAddress"> | string | null
    billing_city?: StringFilter<"CustomerAddress"> | string
    billing_state?: StringFilter<"CustomerAddress"> | string
    billing_zip?: StringFilter<"CustomerAddress"> | string
    billing_country?: StringFilter<"CustomerAddress"> | string
    shipping_address?: StringFilter<"CustomerAddress"> | string
    shipping_address2?: StringNullableFilter<"CustomerAddress"> | string | null
    shipping_city?: StringFilter<"CustomerAddress"> | string
    shipping_state?: StringFilter<"CustomerAddress"> | string
    shipping_zip?: StringFilter<"CustomerAddress"> | string
    shipping_country?: StringFilter<"CustomerAddress"> | string
    is_default?: BoolFilter<"CustomerAddress"> | boolean
    created_at?: DateTimeFilter<"CustomerAddress"> | Date | string
    updated_at?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerAddressOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    billing_address?: SortOrder
    billing_address2?: SortOrderInput | SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    shipping_address?: SortOrder
    shipping_address2?: SortOrderInput | SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_zip?: SortOrder
    shipping_country?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    customer_id?: StringFilter<"CustomerAddress"> | string
    billing_address?: StringFilter<"CustomerAddress"> | string
    billing_address2?: StringNullableFilter<"CustomerAddress"> | string | null
    billing_city?: StringFilter<"CustomerAddress"> | string
    billing_state?: StringFilter<"CustomerAddress"> | string
    billing_zip?: StringFilter<"CustomerAddress"> | string
    billing_country?: StringFilter<"CustomerAddress"> | string
    shipping_address?: StringFilter<"CustomerAddress"> | string
    shipping_address2?: StringNullableFilter<"CustomerAddress"> | string | null
    shipping_city?: StringFilter<"CustomerAddress"> | string
    shipping_state?: StringFilter<"CustomerAddress"> | string
    shipping_zip?: StringFilter<"CustomerAddress"> | string
    shipping_country?: StringFilter<"CustomerAddress"> | string
    is_default?: BoolFilter<"CustomerAddress"> | boolean
    created_at?: DateTimeFilter<"CustomerAddress"> | Date | string
    updated_at?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerAddressOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    billing_address?: SortOrder
    billing_address2?: SortOrderInput | SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    shipping_address?: SortOrder
    shipping_address2?: SortOrderInput | SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_zip?: SortOrder
    shipping_country?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomerAddressCountOrderByAggregateInput
    _max?: CustomerAddressMaxOrderByAggregateInput
    _min?: CustomerAddressMinOrderByAggregateInput
  }

  export type CustomerAddressScalarWhereWithAggregatesInput = {
    AND?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    OR?: CustomerAddressScalarWhereWithAggregatesInput[]
    NOT?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerAddress"> | string
    customer_id?: StringWithAggregatesFilter<"CustomerAddress"> | string
    billing_address?: StringWithAggregatesFilter<"CustomerAddress"> | string
    billing_address2?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    billing_city?: StringWithAggregatesFilter<"CustomerAddress"> | string
    billing_state?: StringWithAggregatesFilter<"CustomerAddress"> | string
    billing_zip?: StringWithAggregatesFilter<"CustomerAddress"> | string
    billing_country?: StringWithAggregatesFilter<"CustomerAddress"> | string
    shipping_address?: StringWithAggregatesFilter<"CustomerAddress"> | string
    shipping_address2?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    shipping_city?: StringWithAggregatesFilter<"CustomerAddress"> | string
    shipping_state?: StringWithAggregatesFilter<"CustomerAddress"> | string
    shipping_zip?: StringWithAggregatesFilter<"CustomerAddress"> | string
    shipping_country?: StringWithAggregatesFilter<"CustomerAddress"> | string
    is_default?: BoolWithAggregatesFilter<"CustomerAddress"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
  }

  export type CustomerTaxInfoWhereInput = {
    AND?: CustomerTaxInfoWhereInput | CustomerTaxInfoWhereInput[]
    OR?: CustomerTaxInfoWhereInput[]
    NOT?: CustomerTaxInfoWhereInput | CustomerTaxInfoWhereInput[]
    id?: StringFilter<"CustomerTaxInfo"> | string
    customer_id?: StringFilter<"CustomerTaxInfo"> | string
    tax_number?: StringNullableFilter<"CustomerTaxInfo"> | string | null
    default_tax?: FloatNullableFilter<"CustomerTaxInfo"> | number | null
    currency?: StringFilter<"CustomerTaxInfo"> | string
    payment_terms?: StringFilter<"CustomerTaxInfo"> | string
    credit_limit?: FloatNullableFilter<"CustomerTaxInfo"> | number | null
    created_at?: DateTimeFilter<"CustomerTaxInfo"> | Date | string
    updated_at?: DateTimeFilter<"CustomerTaxInfo"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerTaxInfoOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    tax_number?: SortOrderInput | SortOrder
    default_tax?: SortOrderInput | SortOrder
    currency?: SortOrder
    payment_terms?: SortOrder
    credit_limit?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerTaxInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customer_id?: string
    AND?: CustomerTaxInfoWhereInput | CustomerTaxInfoWhereInput[]
    OR?: CustomerTaxInfoWhereInput[]
    NOT?: CustomerTaxInfoWhereInput | CustomerTaxInfoWhereInput[]
    tax_number?: StringNullableFilter<"CustomerTaxInfo"> | string | null
    default_tax?: FloatNullableFilter<"CustomerTaxInfo"> | number | null
    currency?: StringFilter<"CustomerTaxInfo"> | string
    payment_terms?: StringFilter<"CustomerTaxInfo"> | string
    credit_limit?: FloatNullableFilter<"CustomerTaxInfo"> | number | null
    created_at?: DateTimeFilter<"CustomerTaxInfo"> | Date | string
    updated_at?: DateTimeFilter<"CustomerTaxInfo"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "customer_id">

  export type CustomerTaxInfoOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    tax_number?: SortOrderInput | SortOrder
    default_tax?: SortOrderInput | SortOrder
    currency?: SortOrder
    payment_terms?: SortOrder
    credit_limit?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomerTaxInfoCountOrderByAggregateInput
    _avg?: CustomerTaxInfoAvgOrderByAggregateInput
    _max?: CustomerTaxInfoMaxOrderByAggregateInput
    _min?: CustomerTaxInfoMinOrderByAggregateInput
    _sum?: CustomerTaxInfoSumOrderByAggregateInput
  }

  export type CustomerTaxInfoScalarWhereWithAggregatesInput = {
    AND?: CustomerTaxInfoScalarWhereWithAggregatesInput | CustomerTaxInfoScalarWhereWithAggregatesInput[]
    OR?: CustomerTaxInfoScalarWhereWithAggregatesInput[]
    NOT?: CustomerTaxInfoScalarWhereWithAggregatesInput | CustomerTaxInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerTaxInfo"> | string
    customer_id?: StringWithAggregatesFilter<"CustomerTaxInfo"> | string
    tax_number?: StringNullableWithAggregatesFilter<"CustomerTaxInfo"> | string | null
    default_tax?: FloatNullableWithAggregatesFilter<"CustomerTaxInfo"> | number | null
    currency?: StringWithAggregatesFilter<"CustomerTaxInfo"> | string
    payment_terms?: StringWithAggregatesFilter<"CustomerTaxInfo"> | string
    credit_limit?: FloatNullableWithAggregatesFilter<"CustomerTaxInfo"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"CustomerTaxInfo"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CustomerTaxInfo"> | Date | string
  }

  export type CustomerContactWhereInput = {
    AND?: CustomerContactWhereInput | CustomerContactWhereInput[]
    OR?: CustomerContactWhereInput[]
    NOT?: CustomerContactWhereInput | CustomerContactWhereInput[]
    id?: StringFilter<"CustomerContact"> | string
    customer_id?: StringFilter<"CustomerContact"> | string
    customer_name?: StringFilter<"CustomerContact"> | string
    contact_name?: StringNullableFilter<"CustomerContact"> | string | null
    job_title?: StringNullableFilter<"CustomerContact"> | string | null
    contact_email?: StringNullableFilter<"CustomerContact"> | string | null
    contact_phone?: StringNullableFilter<"CustomerContact"> | string | null
    is_primary?: BoolFilter<"CustomerContact"> | boolean
    created_at?: DateTimeFilter<"CustomerContact"> | Date | string
    updated_at?: DateTimeFilter<"CustomerContact"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerContactOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    contact_name?: SortOrderInput | SortOrder
    job_title?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    contact_phone?: SortOrderInput | SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerContactWhereInput | CustomerContactWhereInput[]
    OR?: CustomerContactWhereInput[]
    NOT?: CustomerContactWhereInput | CustomerContactWhereInput[]
    customer_id?: StringFilter<"CustomerContact"> | string
    customer_name?: StringFilter<"CustomerContact"> | string
    contact_name?: StringNullableFilter<"CustomerContact"> | string | null
    job_title?: StringNullableFilter<"CustomerContact"> | string | null
    contact_email?: StringNullableFilter<"CustomerContact"> | string | null
    contact_phone?: StringNullableFilter<"CustomerContact"> | string | null
    is_primary?: BoolFilter<"CustomerContact"> | boolean
    created_at?: DateTimeFilter<"CustomerContact"> | Date | string
    updated_at?: DateTimeFilter<"CustomerContact"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerContactOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    contact_name?: SortOrderInput | SortOrder
    job_title?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    contact_phone?: SortOrderInput | SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomerContactCountOrderByAggregateInput
    _max?: CustomerContactMaxOrderByAggregateInput
    _min?: CustomerContactMinOrderByAggregateInput
  }

  export type CustomerContactScalarWhereWithAggregatesInput = {
    AND?: CustomerContactScalarWhereWithAggregatesInput | CustomerContactScalarWhereWithAggregatesInput[]
    OR?: CustomerContactScalarWhereWithAggregatesInput[]
    NOT?: CustomerContactScalarWhereWithAggregatesInput | CustomerContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerContact"> | string
    customer_id?: StringWithAggregatesFilter<"CustomerContact"> | string
    customer_name?: StringWithAggregatesFilter<"CustomerContact"> | string
    contact_name?: StringNullableWithAggregatesFilter<"CustomerContact"> | string | null
    job_title?: StringNullableWithAggregatesFilter<"CustomerContact"> | string | null
    contact_email?: StringNullableWithAggregatesFilter<"CustomerContact"> | string | null
    contact_phone?: StringNullableWithAggregatesFilter<"CustomerContact"> | string | null
    is_primary?: BoolWithAggregatesFilter<"CustomerContact"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"CustomerContact"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CustomerContact"> | Date | string
  }

  export type CustomerOperationalInfoWhereInput = {
    AND?: CustomerOperationalInfoWhereInput | CustomerOperationalInfoWhereInput[]
    OR?: CustomerOperationalInfoWhereInput[]
    NOT?: CustomerOperationalInfoWhereInput | CustomerOperationalInfoWhereInput[]
    id?: StringFilter<"CustomerOperationalInfo"> | string
    customer_id?: StringFilter<"CustomerOperationalInfo"> | string
    delivery_method?: StringNullableFilter<"CustomerOperationalInfo"> | string | null
    quote_format?: StringNullableFilter<"CustomerOperationalInfo"> | string | null
    created_at?: DateTimeFilter<"CustomerOperationalInfo"> | Date | string
    updated_at?: DateTimeFilter<"CustomerOperationalInfo"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerOperationalInfoOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    delivery_method?: SortOrderInput | SortOrder
    quote_format?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerOperationalInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customer_id?: string
    AND?: CustomerOperationalInfoWhereInput | CustomerOperationalInfoWhereInput[]
    OR?: CustomerOperationalInfoWhereInput[]
    NOT?: CustomerOperationalInfoWhereInput | CustomerOperationalInfoWhereInput[]
    delivery_method?: StringNullableFilter<"CustomerOperationalInfo"> | string | null
    quote_format?: StringNullableFilter<"CustomerOperationalInfo"> | string | null
    created_at?: DateTimeFilter<"CustomerOperationalInfo"> | Date | string
    updated_at?: DateTimeFilter<"CustomerOperationalInfo"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "customer_id">

  export type CustomerOperationalInfoOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    delivery_method?: SortOrderInput | SortOrder
    quote_format?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomerOperationalInfoCountOrderByAggregateInput
    _max?: CustomerOperationalInfoMaxOrderByAggregateInput
    _min?: CustomerOperationalInfoMinOrderByAggregateInput
  }

  export type CustomerOperationalInfoScalarWhereWithAggregatesInput = {
    AND?: CustomerOperationalInfoScalarWhereWithAggregatesInput | CustomerOperationalInfoScalarWhereWithAggregatesInput[]
    OR?: CustomerOperationalInfoScalarWhereWithAggregatesInput[]
    NOT?: CustomerOperationalInfoScalarWhereWithAggregatesInput | CustomerOperationalInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerOperationalInfo"> | string
    customer_id?: StringWithAggregatesFilter<"CustomerOperationalInfo"> | string
    delivery_method?: StringNullableWithAggregatesFilter<"CustomerOperationalInfo"> | string | null
    quote_format?: StringNullableWithAggregatesFilter<"CustomerOperationalInfo"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CustomerOperationalInfo"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CustomerOperationalInfo"> | Date | string
  }

  export type CustomerNotesAndAttachmentsWhereInput = {
    AND?: CustomerNotesAndAttachmentsWhereInput | CustomerNotesAndAttachmentsWhereInput[]
    OR?: CustomerNotesAndAttachmentsWhereInput[]
    NOT?: CustomerNotesAndAttachmentsWhereInput | CustomerNotesAndAttachmentsWhereInput[]
    id?: StringFilter<"CustomerNotesAndAttachments"> | string
    customer_id?: StringFilter<"CustomerNotesAndAttachments"> | string
    internal_notes?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    tags?: StringNullableListFilter<"CustomerNotesAndAttachments">
    file_url?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    file_name?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    created_at?: DateTimeFilter<"CustomerNotesAndAttachments"> | Date | string
    updated_at?: DateTimeFilter<"CustomerNotesAndAttachments"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerNotesAndAttachmentsOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    internal_notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    file_url?: SortOrderInput | SortOrder
    file_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerNotesAndAttachmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerNotesAndAttachmentsWhereInput | CustomerNotesAndAttachmentsWhereInput[]
    OR?: CustomerNotesAndAttachmentsWhereInput[]
    NOT?: CustomerNotesAndAttachmentsWhereInput | CustomerNotesAndAttachmentsWhereInput[]
    customer_id?: StringFilter<"CustomerNotesAndAttachments"> | string
    internal_notes?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    tags?: StringNullableListFilter<"CustomerNotesAndAttachments">
    file_url?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    file_name?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    created_at?: DateTimeFilter<"CustomerNotesAndAttachments"> | Date | string
    updated_at?: DateTimeFilter<"CustomerNotesAndAttachments"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerNotesAndAttachmentsOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    internal_notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    file_url?: SortOrderInput | SortOrder
    file_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomerNotesAndAttachmentsCountOrderByAggregateInput
    _max?: CustomerNotesAndAttachmentsMaxOrderByAggregateInput
    _min?: CustomerNotesAndAttachmentsMinOrderByAggregateInput
  }

  export type CustomerNotesAndAttachmentsScalarWhereWithAggregatesInput = {
    AND?: CustomerNotesAndAttachmentsScalarWhereWithAggregatesInput | CustomerNotesAndAttachmentsScalarWhereWithAggregatesInput[]
    OR?: CustomerNotesAndAttachmentsScalarWhereWithAggregatesInput[]
    NOT?: CustomerNotesAndAttachmentsScalarWhereWithAggregatesInput | CustomerNotesAndAttachmentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerNotesAndAttachments"> | string
    customer_id?: StringWithAggregatesFilter<"CustomerNotesAndAttachments"> | string
    internal_notes?: StringNullableWithAggregatesFilter<"CustomerNotesAndAttachments"> | string | null
    tags?: StringNullableListFilter<"CustomerNotesAndAttachments">
    file_url?: StringNullableWithAggregatesFilter<"CustomerNotesAndAttachments"> | string | null
    file_name?: StringNullableWithAggregatesFilter<"CustomerNotesAndAttachments"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CustomerNotesAndAttachments"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CustomerNotesAndAttachments"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    vendor_id?: IntFilter<"Vendor"> | number
    first_name?: StringFilter<"Vendor"> | string
    last_name?: StringFilter<"Vendor"> | string
    vendor_name?: StringFilter<"Vendor"> | string
    vendor_type?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    password?: StringFilter<"Vendor"> | string
    phone?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    user_id?: StringNullableFilter<"Vendor"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    contacts?: XOR<VendorContactNullableScalarRelationFilter, VendorContactWhereInput> | null
    addresses?: XOR<VendorAddressNullableScalarRelationFilter, VendorAddressWhereInput> | null
    taxCompliances?: XOR<VendorTaxComplianceNullableScalarRelationFilter, VendorTaxComplianceWhereInput> | null
    financials?: XOR<VendorFinancialNullableScalarRelationFilter, VendorFinancialWhereInput> | null
    operationalSetting?: XOR<VendorOperationalSettingNullableScalarRelationFilter, VendorOperationalSettingWhereInput> | null
    metadata?: XOR<VendorMetadataNullableScalarRelationFilter, VendorMetadataWhereInput> | null
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    vendor_name?: SortOrder
    vendor_type?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    contacts?: VendorContactOrderByWithRelationInput
    addresses?: VendorAddressOrderByWithRelationInput
    taxCompliances?: VendorTaxComplianceOrderByWithRelationInput
    financials?: VendorFinancialOrderByWithRelationInput
    operationalSetting?: VendorOperationalSettingOrderByWithRelationInput
    metadata?: VendorMetadataOrderByWithRelationInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendor_id?: number
    email?: string
    user_id?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    first_name?: StringFilter<"Vendor"> | string
    last_name?: StringFilter<"Vendor"> | string
    vendor_name?: StringFilter<"Vendor"> | string
    vendor_type?: StringNullableFilter<"Vendor"> | string | null
    password?: StringFilter<"Vendor"> | string
    phone?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    contacts?: XOR<VendorContactNullableScalarRelationFilter, VendorContactWhereInput> | null
    addresses?: XOR<VendorAddressNullableScalarRelationFilter, VendorAddressWhereInput> | null
    taxCompliances?: XOR<VendorTaxComplianceNullableScalarRelationFilter, VendorTaxComplianceWhereInput> | null
    financials?: XOR<VendorFinancialNullableScalarRelationFilter, VendorFinancialWhereInput> | null
    operationalSetting?: XOR<VendorOperationalSettingNullableScalarRelationFilter, VendorOperationalSettingWhereInput> | null
    metadata?: XOR<VendorMetadataNullableScalarRelationFilter, VendorMetadataWhereInput> | null
  }, "id" | "vendor_id" | "email" | "user_id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    vendor_name?: SortOrder
    vendor_type?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    vendor_id?: IntWithAggregatesFilter<"Vendor"> | number
    first_name?: StringWithAggregatesFilter<"Vendor"> | string
    last_name?: StringWithAggregatesFilter<"Vendor"> | string
    vendor_name?: StringWithAggregatesFilter<"Vendor"> | string
    vendor_type?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    password?: StringWithAggregatesFilter<"Vendor"> | string
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    website?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
    user_id?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
  }

  export type VendorContactWhereInput = {
    AND?: VendorContactWhereInput | VendorContactWhereInput[]
    OR?: VendorContactWhereInput[]
    NOT?: VendorContactWhereInput | VendorContactWhereInput[]
    id?: StringFilter<"VendorContact"> | string
    vendor_id?: StringFilter<"VendorContact"> | string
    contact_name?: StringFilter<"VendorContact"> | string
    job_title?: StringNullableFilter<"VendorContact"> | string | null
    email?: StringNullableFilter<"VendorContact"> | string | null
    phone?: StringNullableFilter<"VendorContact"> | string | null
    created_at?: DateTimeFilter<"VendorContact"> | Date | string
    updated_at?: DateTimeFilter<"VendorContact"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorContactOrderByWithRelationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    contact_name?: SortOrder
    job_title?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendor_id?: string
    AND?: VendorContactWhereInput | VendorContactWhereInput[]
    OR?: VendorContactWhereInput[]
    NOT?: VendorContactWhereInput | VendorContactWhereInput[]
    contact_name?: StringFilter<"VendorContact"> | string
    job_title?: StringNullableFilter<"VendorContact"> | string | null
    email?: StringNullableFilter<"VendorContact"> | string | null
    phone?: StringNullableFilter<"VendorContact"> | string | null
    created_at?: DateTimeFilter<"VendorContact"> | Date | string
    updated_at?: DateTimeFilter<"VendorContact"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id" | "vendor_id">

  export type VendorContactOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    contact_name?: SortOrder
    job_title?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorContactCountOrderByAggregateInput
    _max?: VendorContactMaxOrderByAggregateInput
    _min?: VendorContactMinOrderByAggregateInput
  }

  export type VendorContactScalarWhereWithAggregatesInput = {
    AND?: VendorContactScalarWhereWithAggregatesInput | VendorContactScalarWhereWithAggregatesInput[]
    OR?: VendorContactScalarWhereWithAggregatesInput[]
    NOT?: VendorContactScalarWhereWithAggregatesInput | VendorContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorContact"> | string
    vendor_id?: StringWithAggregatesFilter<"VendorContact"> | string
    contact_name?: StringWithAggregatesFilter<"VendorContact"> | string
    job_title?: StringNullableWithAggregatesFilter<"VendorContact"> | string | null
    email?: StringNullableWithAggregatesFilter<"VendorContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"VendorContact"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"VendorContact"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VendorContact"> | Date | string
  }

  export type VendorAddressWhereInput = {
    AND?: VendorAddressWhereInput | VendorAddressWhereInput[]
    OR?: VendorAddressWhereInput[]
    NOT?: VendorAddressWhereInput | VendorAddressWhereInput[]
    id?: StringFilter<"VendorAddress"> | string
    vendor_id?: StringFilter<"VendorAddress"> | string
    address_1?: StringFilter<"VendorAddress"> | string
    address_2?: StringNullableFilter<"VendorAddress"> | string | null
    city?: StringFilter<"VendorAddress"> | string
    state?: StringFilter<"VendorAddress"> | string
    zip?: StringFilter<"VendorAddress"> | string
    country?: StringFilter<"VendorAddress"> | string
    created_at?: DateTimeFilter<"VendorAddress"> | Date | string
    updated_at?: DateTimeFilter<"VendorAddress"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorAddressOrderByWithRelationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendor_id?: string
    AND?: VendorAddressWhereInput | VendorAddressWhereInput[]
    OR?: VendorAddressWhereInput[]
    NOT?: VendorAddressWhereInput | VendorAddressWhereInput[]
    address_1?: StringFilter<"VendorAddress"> | string
    address_2?: StringNullableFilter<"VendorAddress"> | string | null
    city?: StringFilter<"VendorAddress"> | string
    state?: StringFilter<"VendorAddress"> | string
    zip?: StringFilter<"VendorAddress"> | string
    country?: StringFilter<"VendorAddress"> | string
    created_at?: DateTimeFilter<"VendorAddress"> | Date | string
    updated_at?: DateTimeFilter<"VendorAddress"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id" | "vendor_id">

  export type VendorAddressOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorAddressCountOrderByAggregateInput
    _max?: VendorAddressMaxOrderByAggregateInput
    _min?: VendorAddressMinOrderByAggregateInput
  }

  export type VendorAddressScalarWhereWithAggregatesInput = {
    AND?: VendorAddressScalarWhereWithAggregatesInput | VendorAddressScalarWhereWithAggregatesInput[]
    OR?: VendorAddressScalarWhereWithAggregatesInput[]
    NOT?: VendorAddressScalarWhereWithAggregatesInput | VendorAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorAddress"> | string
    vendor_id?: StringWithAggregatesFilter<"VendorAddress"> | string
    address_1?: StringWithAggregatesFilter<"VendorAddress"> | string
    address_2?: StringNullableWithAggregatesFilter<"VendorAddress"> | string | null
    city?: StringWithAggregatesFilter<"VendorAddress"> | string
    state?: StringWithAggregatesFilter<"VendorAddress"> | string
    zip?: StringWithAggregatesFilter<"VendorAddress"> | string
    country?: StringWithAggregatesFilter<"VendorAddress"> | string
    created_at?: DateTimeWithAggregatesFilter<"VendorAddress"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VendorAddress"> | Date | string
  }

  export type VendorTaxComplianceWhereInput = {
    AND?: VendorTaxComplianceWhereInput | VendorTaxComplianceWhereInput[]
    OR?: VendorTaxComplianceWhereInput[]
    NOT?: VendorTaxComplianceWhereInput | VendorTaxComplianceWhereInput[]
    id?: StringFilter<"VendorTaxCompliance"> | string
    vendor_id?: StringFilter<"VendorTaxCompliance"> | string
    tax_number?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    vat_number?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    company_number?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    compliance_type?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    file_name?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    file_url?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    created_at?: DateTimeFilter<"VendorTaxCompliance"> | Date | string
    updated_at?: DateTimeFilter<"VendorTaxCompliance"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorTaxComplianceOrderByWithRelationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    tax_number?: SortOrderInput | SortOrder
    vat_number?: SortOrderInput | SortOrder
    company_number?: SortOrderInput | SortOrder
    compliance_type?: SortOrderInput | SortOrder
    file_name?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorTaxComplianceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendor_id?: string
    AND?: VendorTaxComplianceWhereInput | VendorTaxComplianceWhereInput[]
    OR?: VendorTaxComplianceWhereInput[]
    NOT?: VendorTaxComplianceWhereInput | VendorTaxComplianceWhereInput[]
    tax_number?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    vat_number?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    company_number?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    compliance_type?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    file_name?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    file_url?: StringNullableFilter<"VendorTaxCompliance"> | string | null
    created_at?: DateTimeFilter<"VendorTaxCompliance"> | Date | string
    updated_at?: DateTimeFilter<"VendorTaxCompliance"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id" | "vendor_id">

  export type VendorTaxComplianceOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    tax_number?: SortOrderInput | SortOrder
    vat_number?: SortOrderInput | SortOrder
    company_number?: SortOrderInput | SortOrder
    compliance_type?: SortOrderInput | SortOrder
    file_name?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorTaxComplianceCountOrderByAggregateInput
    _max?: VendorTaxComplianceMaxOrderByAggregateInput
    _min?: VendorTaxComplianceMinOrderByAggregateInput
  }

  export type VendorTaxComplianceScalarWhereWithAggregatesInput = {
    AND?: VendorTaxComplianceScalarWhereWithAggregatesInput | VendorTaxComplianceScalarWhereWithAggregatesInput[]
    OR?: VendorTaxComplianceScalarWhereWithAggregatesInput[]
    NOT?: VendorTaxComplianceScalarWhereWithAggregatesInput | VendorTaxComplianceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorTaxCompliance"> | string
    vendor_id?: StringWithAggregatesFilter<"VendorTaxCompliance"> | string
    tax_number?: StringNullableWithAggregatesFilter<"VendorTaxCompliance"> | string | null
    vat_number?: StringNullableWithAggregatesFilter<"VendorTaxCompliance"> | string | null
    company_number?: StringNullableWithAggregatesFilter<"VendorTaxCompliance"> | string | null
    compliance_type?: StringNullableWithAggregatesFilter<"VendorTaxCompliance"> | string | null
    file_name?: StringNullableWithAggregatesFilter<"VendorTaxCompliance"> | string | null
    file_url?: StringNullableWithAggregatesFilter<"VendorTaxCompliance"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"VendorTaxCompliance"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VendorTaxCompliance"> | Date | string
  }

  export type VendorFinancialWhereInput = {
    AND?: VendorFinancialWhereInput | VendorFinancialWhereInput[]
    OR?: VendorFinancialWhereInput[]
    NOT?: VendorFinancialWhereInput | VendorFinancialWhereInput[]
    id?: StringFilter<"VendorFinancial"> | string
    vendor_id?: StringFilter<"VendorFinancial"> | string
    bank_name?: StringNullableFilter<"VendorFinancial"> | string | null
    bank_account_number?: StringNullableFilter<"VendorFinancial"> | string | null
    swift_iban_code?: StringNullableFilter<"VendorFinancial"> | string | null
    preferred_currency?: StringFilter<"VendorFinancial"> | string
    payment_terms?: StringFilter<"VendorFinancial"> | string
    default_tax_rate?: StringNullableFilter<"VendorFinancial"> | string | null
    credit_limit?: FloatNullableFilter<"VendorFinancial"> | number | null
    created_at?: DateTimeFilter<"VendorFinancial"> | Date | string
    updated_at?: DateTimeFilter<"VendorFinancial"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorFinancialOrderByWithRelationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    bank_name?: SortOrderInput | SortOrder
    bank_account_number?: SortOrderInput | SortOrder
    swift_iban_code?: SortOrderInput | SortOrder
    preferred_currency?: SortOrder
    payment_terms?: SortOrder
    default_tax_rate?: SortOrderInput | SortOrder
    credit_limit?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorFinancialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendor_id?: string
    AND?: VendorFinancialWhereInput | VendorFinancialWhereInput[]
    OR?: VendorFinancialWhereInput[]
    NOT?: VendorFinancialWhereInput | VendorFinancialWhereInput[]
    bank_name?: StringNullableFilter<"VendorFinancial"> | string | null
    bank_account_number?: StringNullableFilter<"VendorFinancial"> | string | null
    swift_iban_code?: StringNullableFilter<"VendorFinancial"> | string | null
    preferred_currency?: StringFilter<"VendorFinancial"> | string
    payment_terms?: StringFilter<"VendorFinancial"> | string
    default_tax_rate?: StringNullableFilter<"VendorFinancial"> | string | null
    credit_limit?: FloatNullableFilter<"VendorFinancial"> | number | null
    created_at?: DateTimeFilter<"VendorFinancial"> | Date | string
    updated_at?: DateTimeFilter<"VendorFinancial"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id" | "vendor_id">

  export type VendorFinancialOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    bank_name?: SortOrderInput | SortOrder
    bank_account_number?: SortOrderInput | SortOrder
    swift_iban_code?: SortOrderInput | SortOrder
    preferred_currency?: SortOrder
    payment_terms?: SortOrder
    default_tax_rate?: SortOrderInput | SortOrder
    credit_limit?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorFinancialCountOrderByAggregateInput
    _avg?: VendorFinancialAvgOrderByAggregateInput
    _max?: VendorFinancialMaxOrderByAggregateInput
    _min?: VendorFinancialMinOrderByAggregateInput
    _sum?: VendorFinancialSumOrderByAggregateInput
  }

  export type VendorFinancialScalarWhereWithAggregatesInput = {
    AND?: VendorFinancialScalarWhereWithAggregatesInput | VendorFinancialScalarWhereWithAggregatesInput[]
    OR?: VendorFinancialScalarWhereWithAggregatesInput[]
    NOT?: VendorFinancialScalarWhereWithAggregatesInput | VendorFinancialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorFinancial"> | string
    vendor_id?: StringWithAggregatesFilter<"VendorFinancial"> | string
    bank_name?: StringNullableWithAggregatesFilter<"VendorFinancial"> | string | null
    bank_account_number?: StringNullableWithAggregatesFilter<"VendorFinancial"> | string | null
    swift_iban_code?: StringNullableWithAggregatesFilter<"VendorFinancial"> | string | null
    preferred_currency?: StringWithAggregatesFilter<"VendorFinancial"> | string
    payment_terms?: StringWithAggregatesFilter<"VendorFinancial"> | string
    default_tax_rate?: StringNullableWithAggregatesFilter<"VendorFinancial"> | string | null
    credit_limit?: FloatNullableWithAggregatesFilter<"VendorFinancial"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"VendorFinancial"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VendorFinancial"> | Date | string
  }

  export type VendorOperationalSettingWhereInput = {
    AND?: VendorOperationalSettingWhereInput | VendorOperationalSettingWhereInput[]
    OR?: VendorOperationalSettingWhereInput[]
    NOT?: VendorOperationalSettingWhereInput | VendorOperationalSettingWhereInput[]
    id?: StringFilter<"VendorOperationalSetting"> | string
    vendor_id?: StringFilter<"VendorOperationalSetting"> | string
    status?: StringNullableFilter<"VendorOperationalSetting"> | string | null
    shipping_method?: StringNullableFilter<"VendorOperationalSetting"> | string | null
    lead_time?: IntNullableFilter<"VendorOperationalSetting"> | number | null
    minimum_order_quantity?: IntNullableFilter<"VendorOperationalSetting"> | number | null
    categories?: StringNullableListFilter<"VendorOperationalSetting">
    manager?: StringFilter<"VendorOperationalSetting"> | string
    created_at?: DateTimeFilter<"VendorOperationalSetting"> | Date | string
    updated_at?: DateTimeFilter<"VendorOperationalSetting"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorOperationalSettingOrderByWithRelationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    status?: SortOrderInput | SortOrder
    shipping_method?: SortOrderInput | SortOrder
    lead_time?: SortOrderInput | SortOrder
    minimum_order_quantity?: SortOrderInput | SortOrder
    categories?: SortOrder
    manager?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorOperationalSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendor_id?: string
    AND?: VendorOperationalSettingWhereInput | VendorOperationalSettingWhereInput[]
    OR?: VendorOperationalSettingWhereInput[]
    NOT?: VendorOperationalSettingWhereInput | VendorOperationalSettingWhereInput[]
    status?: StringNullableFilter<"VendorOperationalSetting"> | string | null
    shipping_method?: StringNullableFilter<"VendorOperationalSetting"> | string | null
    lead_time?: IntNullableFilter<"VendorOperationalSetting"> | number | null
    minimum_order_quantity?: IntNullableFilter<"VendorOperationalSetting"> | number | null
    categories?: StringNullableListFilter<"VendorOperationalSetting">
    manager?: StringFilter<"VendorOperationalSetting"> | string
    created_at?: DateTimeFilter<"VendorOperationalSetting"> | Date | string
    updated_at?: DateTimeFilter<"VendorOperationalSetting"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id" | "vendor_id">

  export type VendorOperationalSettingOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    status?: SortOrderInput | SortOrder
    shipping_method?: SortOrderInput | SortOrder
    lead_time?: SortOrderInput | SortOrder
    minimum_order_quantity?: SortOrderInput | SortOrder
    categories?: SortOrder
    manager?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorOperationalSettingCountOrderByAggregateInput
    _avg?: VendorOperationalSettingAvgOrderByAggregateInput
    _max?: VendorOperationalSettingMaxOrderByAggregateInput
    _min?: VendorOperationalSettingMinOrderByAggregateInput
    _sum?: VendorOperationalSettingSumOrderByAggregateInput
  }

  export type VendorOperationalSettingScalarWhereWithAggregatesInput = {
    AND?: VendorOperationalSettingScalarWhereWithAggregatesInput | VendorOperationalSettingScalarWhereWithAggregatesInput[]
    OR?: VendorOperationalSettingScalarWhereWithAggregatesInput[]
    NOT?: VendorOperationalSettingScalarWhereWithAggregatesInput | VendorOperationalSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorOperationalSetting"> | string
    vendor_id?: StringWithAggregatesFilter<"VendorOperationalSetting"> | string
    status?: StringNullableWithAggregatesFilter<"VendorOperationalSetting"> | string | null
    shipping_method?: StringNullableWithAggregatesFilter<"VendorOperationalSetting"> | string | null
    lead_time?: IntNullableWithAggregatesFilter<"VendorOperationalSetting"> | number | null
    minimum_order_quantity?: IntNullableWithAggregatesFilter<"VendorOperationalSetting"> | number | null
    categories?: StringNullableListFilter<"VendorOperationalSetting">
    manager?: StringWithAggregatesFilter<"VendorOperationalSetting"> | string
    created_at?: DateTimeWithAggregatesFilter<"VendorOperationalSetting"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VendorOperationalSetting"> | Date | string
  }

  export type VendorMetadataWhereInput = {
    AND?: VendorMetadataWhereInput | VendorMetadataWhereInput[]
    OR?: VendorMetadataWhereInput[]
    NOT?: VendorMetadataWhereInput | VendorMetadataWhereInput[]
    id?: StringFilter<"VendorMetadata"> | string
    vendor_id?: StringFilter<"VendorMetadata"> | string
    notes?: StringNullableFilter<"VendorMetadata"> | string | null
    tags?: StringNullableListFilter<"VendorMetadata">
    score?: IntNullableFilter<"VendorMetadata"> | number | null
    last_order?: DateTimeFilter<"VendorMetadata"> | Date | string
    next_review?: DateTimeNullableFilter<"VendorMetadata"> | Date | string | null
    created_at?: DateTimeFilter<"VendorMetadata"> | Date | string
    updated_at?: DateTimeFilter<"VendorMetadata"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorMetadataOrderByWithRelationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    score?: SortOrderInput | SortOrder
    last_order?: SortOrder
    next_review?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendor_id?: string
    AND?: VendorMetadataWhereInput | VendorMetadataWhereInput[]
    OR?: VendorMetadataWhereInput[]
    NOT?: VendorMetadataWhereInput | VendorMetadataWhereInput[]
    notes?: StringNullableFilter<"VendorMetadata"> | string | null
    tags?: StringNullableListFilter<"VendorMetadata">
    score?: IntNullableFilter<"VendorMetadata"> | number | null
    last_order?: DateTimeFilter<"VendorMetadata"> | Date | string
    next_review?: DateTimeNullableFilter<"VendorMetadata"> | Date | string | null
    created_at?: DateTimeFilter<"VendorMetadata"> | Date | string
    updated_at?: DateTimeFilter<"VendorMetadata"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id" | "vendor_id">

  export type VendorMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    score?: SortOrderInput | SortOrder
    last_order?: SortOrder
    next_review?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorMetadataCountOrderByAggregateInput
    _avg?: VendorMetadataAvgOrderByAggregateInput
    _max?: VendorMetadataMaxOrderByAggregateInput
    _min?: VendorMetadataMinOrderByAggregateInput
    _sum?: VendorMetadataSumOrderByAggregateInput
  }

  export type VendorMetadataScalarWhereWithAggregatesInput = {
    AND?: VendorMetadataScalarWhereWithAggregatesInput | VendorMetadataScalarWhereWithAggregatesInput[]
    OR?: VendorMetadataScalarWhereWithAggregatesInput[]
    NOT?: VendorMetadataScalarWhereWithAggregatesInput | VendorMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorMetadata"> | string
    vendor_id?: StringWithAggregatesFilter<"VendorMetadata"> | string
    notes?: StringNullableWithAggregatesFilter<"VendorMetadata"> | string | null
    tags?: StringNullableListFilter<"VendorMetadata">
    score?: IntNullableWithAggregatesFilter<"VendorMetadata"> | number | null
    last_order?: DateTimeWithAggregatesFilter<"VendorMetadata"> | Date | string
    next_review?: DateTimeNullableWithAggregatesFilter<"VendorMetadata"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"VendorMetadata"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VendorMetadata"> | Date | string
  }

  export type company_vendor_capabilitiesWhereInput = {
    AND?: company_vendor_capabilitiesWhereInput | company_vendor_capabilitiesWhereInput[]
    OR?: company_vendor_capabilitiesWhereInput[]
    NOT?: company_vendor_capabilitiesWhereInput | company_vendor_capabilitiesWhereInput[]
    id?: StringFilter<"company_vendor_capabilities"> | string
    name?: StringFilter<"company_vendor_capabilities"> | string
    is_active?: BoolFilter<"company_vendor_capabilities"> | boolean
    created_at?: DateTimeFilter<"company_vendor_capabilities"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_capabilities"> | Date | string
    subCategories?: Company_vendor_capability_sub_categoriesListRelationFilter
  }

  export type company_vendor_capabilitiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subCategories?: company_vendor_capability_sub_categoriesOrderByRelationAggregateInput
  }

  export type company_vendor_capabilitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: company_vendor_capabilitiesWhereInput | company_vendor_capabilitiesWhereInput[]
    OR?: company_vendor_capabilitiesWhereInput[]
    NOT?: company_vendor_capabilitiesWhereInput | company_vendor_capabilitiesWhereInput[]
    name?: StringFilter<"company_vendor_capabilities"> | string
    is_active?: BoolFilter<"company_vendor_capabilities"> | boolean
    created_at?: DateTimeFilter<"company_vendor_capabilities"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_capabilities"> | Date | string
    subCategories?: Company_vendor_capability_sub_categoriesListRelationFilter
  }, "id">

  export type company_vendor_capabilitiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: company_vendor_capabilitiesCountOrderByAggregateInput
    _max?: company_vendor_capabilitiesMaxOrderByAggregateInput
    _min?: company_vendor_capabilitiesMinOrderByAggregateInput
  }

  export type company_vendor_capabilitiesScalarWhereWithAggregatesInput = {
    AND?: company_vendor_capabilitiesScalarWhereWithAggregatesInput | company_vendor_capabilitiesScalarWhereWithAggregatesInput[]
    OR?: company_vendor_capabilitiesScalarWhereWithAggregatesInput[]
    NOT?: company_vendor_capabilitiesScalarWhereWithAggregatesInput | company_vendor_capabilitiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"company_vendor_capabilities"> | string
    name?: StringWithAggregatesFilter<"company_vendor_capabilities"> | string
    is_active?: BoolWithAggregatesFilter<"company_vendor_capabilities"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"company_vendor_capabilities"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"company_vendor_capabilities"> | Date | string
  }

  export type company_vendor_capability_sub_categoriesWhereInput = {
    AND?: company_vendor_capability_sub_categoriesWhereInput | company_vendor_capability_sub_categoriesWhereInput[]
    OR?: company_vendor_capability_sub_categoriesWhereInput[]
    NOT?: company_vendor_capability_sub_categoriesWhereInput | company_vendor_capability_sub_categoriesWhereInput[]
    id?: StringFilter<"company_vendor_capability_sub_categories"> | string
    name?: StringFilter<"company_vendor_capability_sub_categories"> | string
    vendor_capability_id?: StringFilter<"company_vendor_capability_sub_categories"> | string
    is_active?: BoolFilter<"company_vendor_capability_sub_categories"> | boolean
    created_at?: DateTimeFilter<"company_vendor_capability_sub_categories"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_capability_sub_categories"> | Date | string
    capability?: XOR<Company_vendor_capabilitiesScalarRelationFilter, company_vendor_capabilitiesWhereInput>
  }

  export type company_vendor_capability_sub_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    vendor_capability_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    capability?: company_vendor_capabilitiesOrderByWithRelationInput
  }

  export type company_vendor_capability_sub_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: company_vendor_capability_sub_categoriesWhereInput | company_vendor_capability_sub_categoriesWhereInput[]
    OR?: company_vendor_capability_sub_categoriesWhereInput[]
    NOT?: company_vendor_capability_sub_categoriesWhereInput | company_vendor_capability_sub_categoriesWhereInput[]
    name?: StringFilter<"company_vendor_capability_sub_categories"> | string
    vendor_capability_id?: StringFilter<"company_vendor_capability_sub_categories"> | string
    is_active?: BoolFilter<"company_vendor_capability_sub_categories"> | boolean
    created_at?: DateTimeFilter<"company_vendor_capability_sub_categories"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_capability_sub_categories"> | Date | string
    capability?: XOR<Company_vendor_capabilitiesScalarRelationFilter, company_vendor_capabilitiesWhereInput>
  }, "id">

  export type company_vendor_capability_sub_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    vendor_capability_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: company_vendor_capability_sub_categoriesCountOrderByAggregateInput
    _max?: company_vendor_capability_sub_categoriesMaxOrderByAggregateInput
    _min?: company_vendor_capability_sub_categoriesMinOrderByAggregateInput
  }

  export type company_vendor_capability_sub_categoriesScalarWhereWithAggregatesInput = {
    AND?: company_vendor_capability_sub_categoriesScalarWhereWithAggregatesInput | company_vendor_capability_sub_categoriesScalarWhereWithAggregatesInput[]
    OR?: company_vendor_capability_sub_categoriesScalarWhereWithAggregatesInput[]
    NOT?: company_vendor_capability_sub_categoriesScalarWhereWithAggregatesInput | company_vendor_capability_sub_categoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"company_vendor_capability_sub_categories"> | string
    name?: StringWithAggregatesFilter<"company_vendor_capability_sub_categories"> | string
    vendor_capability_id?: StringWithAggregatesFilter<"company_vendor_capability_sub_categories"> | string
    is_active?: BoolWithAggregatesFilter<"company_vendor_capability_sub_categories"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"company_vendor_capability_sub_categories"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"company_vendor_capability_sub_categories"> | Date | string
  }

  export type company_vendor_certificationsWhereInput = {
    AND?: company_vendor_certificationsWhereInput | company_vendor_certificationsWhereInput[]
    OR?: company_vendor_certificationsWhereInput[]
    NOT?: company_vendor_certificationsWhereInput | company_vendor_certificationsWhereInput[]
    id?: StringFilter<"company_vendor_certifications"> | string
    name?: StringFilter<"company_vendor_certifications"> | string
    is_active?: BoolFilter<"company_vendor_certifications"> | boolean
    created_at?: DateTimeFilter<"company_vendor_certifications"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_certifications"> | Date | string
  }

  export type company_vendor_certificationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_certificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: company_vendor_certificationsWhereInput | company_vendor_certificationsWhereInput[]
    OR?: company_vendor_certificationsWhereInput[]
    NOT?: company_vendor_certificationsWhereInput | company_vendor_certificationsWhereInput[]
    name?: StringFilter<"company_vendor_certifications"> | string
    is_active?: BoolFilter<"company_vendor_certifications"> | boolean
    created_at?: DateTimeFilter<"company_vendor_certifications"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_certifications"> | Date | string
  }, "id">

  export type company_vendor_certificationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: company_vendor_certificationsCountOrderByAggregateInput
    _max?: company_vendor_certificationsMaxOrderByAggregateInput
    _min?: company_vendor_certificationsMinOrderByAggregateInput
  }

  export type company_vendor_certificationsScalarWhereWithAggregatesInput = {
    AND?: company_vendor_certificationsScalarWhereWithAggregatesInput | company_vendor_certificationsScalarWhereWithAggregatesInput[]
    OR?: company_vendor_certificationsScalarWhereWithAggregatesInput[]
    NOT?: company_vendor_certificationsScalarWhereWithAggregatesInput | company_vendor_certificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"company_vendor_certifications"> | string
    name?: StringWithAggregatesFilter<"company_vendor_certifications"> | string
    is_active?: BoolWithAggregatesFilter<"company_vendor_certifications"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"company_vendor_certifications"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"company_vendor_certifications"> | Date | string
  }

  export type company_vendor_flagsWhereInput = {
    AND?: company_vendor_flagsWhereInput | company_vendor_flagsWhereInput[]
    OR?: company_vendor_flagsWhereInput[]
    NOT?: company_vendor_flagsWhereInput | company_vendor_flagsWhereInput[]
    id?: StringFilter<"company_vendor_flags"> | string
    name?: StringFilter<"company_vendor_flags"> | string
    is_active?: BoolFilter<"company_vendor_flags"> | boolean
    created_at?: DateTimeFilter<"company_vendor_flags"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_flags"> | Date | string
  }

  export type company_vendor_flagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_flagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: company_vendor_flagsWhereInput | company_vendor_flagsWhereInput[]
    OR?: company_vendor_flagsWhereInput[]
    NOT?: company_vendor_flagsWhereInput | company_vendor_flagsWhereInput[]
    name?: StringFilter<"company_vendor_flags"> | string
    is_active?: BoolFilter<"company_vendor_flags"> | boolean
    created_at?: DateTimeFilter<"company_vendor_flags"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_flags"> | Date | string
  }, "id">

  export type company_vendor_flagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: company_vendor_flagsCountOrderByAggregateInput
    _max?: company_vendor_flagsMaxOrderByAggregateInput
    _min?: company_vendor_flagsMinOrderByAggregateInput
  }

  export type company_vendor_flagsScalarWhereWithAggregatesInput = {
    AND?: company_vendor_flagsScalarWhereWithAggregatesInput | company_vendor_flagsScalarWhereWithAggregatesInput[]
    OR?: company_vendor_flagsScalarWhereWithAggregatesInput[]
    NOT?: company_vendor_flagsScalarWhereWithAggregatesInput | company_vendor_flagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"company_vendor_flags"> | string
    name?: StringWithAggregatesFilter<"company_vendor_flags"> | string
    is_active?: BoolWithAggregatesFilter<"company_vendor_flags"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"company_vendor_flags"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"company_vendor_flags"> | Date | string
  }

  export type company_schoolWhereInput = {
    AND?: company_schoolWhereInput | company_schoolWhereInput[]
    OR?: company_schoolWhereInput[]
    NOT?: company_schoolWhereInput | company_schoolWhereInput[]
    id?: StringFilter<"company_school"> | string
    name?: StringFilter<"company_school"> | string
    class?: StringFilter<"company_school"> | string
    roll_no?: StringFilter<"company_school"> | string
  }

  export type company_schoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    roll_no?: SortOrder
  }

  export type company_schoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: company_schoolWhereInput | company_schoolWhereInput[]
    OR?: company_schoolWhereInput[]
    NOT?: company_schoolWhereInput | company_schoolWhereInput[]
    name?: StringFilter<"company_school"> | string
    class?: StringFilter<"company_school"> | string
    roll_no?: StringFilter<"company_school"> | string
  }, "id">

  export type company_schoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    roll_no?: SortOrder
    _count?: company_schoolCountOrderByAggregateInput
    _max?: company_schoolMaxOrderByAggregateInput
    _min?: company_schoolMinOrderByAggregateInput
  }

  export type company_schoolScalarWhereWithAggregatesInput = {
    AND?: company_schoolScalarWhereWithAggregatesInput | company_schoolScalarWhereWithAggregatesInput[]
    OR?: company_schoolScalarWhereWithAggregatesInput[]
    NOT?: company_schoolScalarWhereWithAggregatesInput | company_schoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"company_school"> | string
    name?: StringWithAggregatesFilter<"company_school"> | string
    class?: StringWithAggregatesFilter<"company_school"> | string
    roll_no?: StringWithAggregatesFilter<"company_school"> | string
  }

  export type UserCreateInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerCreateNestedOneWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    quotes?: QuoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    quotes?: QuoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateInput = {
    id?: string
    quote_item_id?: number
    status?: string | null
    payment_status?: string | null
    quote_type?: $Enums.QuoteType
    tax?: string | null
    deposit_paid?: string | null
    shipping?: string | null
    tax_buy_price?: string | null
    shipping_buy_price?: string | null
    lead_time?: string | null
    payable?: string | null
    freight_condition?: string | null
    freight_condition_dismiss?: boolean | null
    customer_email?: string | null
    emails?: string | null
    invoice_date?: Date | string | null
    invoice_email?: string | null
    billing_name?: string | null
    billing_company?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_country?: string | null
    billing_zip?: string | null
    billing_phone?: string | null
    billing_fax?: string | null
    shipping_name?: string | null
    shipping_company?: string | null
    shipping_address?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_country?: string | null
    shipping_zip?: string | null
    shipping_phone?: string | null
    shipping_email?: string | null
    shipping_fax?: string | null
    sales_person?: number | null
    project_manager?: number | null
    accept_agreement?: number | null
    date_created?: Date | string | null
    created_month?: string | null
    created_year?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    User?: UserCreateNestedOneWithoutQuotesInput
    QuoteItems?: QuoteItemCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: string
    user_id: string
    quote_item_id?: number
    status?: string | null
    payment_status?: string | null
    quote_type?: $Enums.QuoteType
    tax?: string | null
    deposit_paid?: string | null
    shipping?: string | null
    tax_buy_price?: string | null
    shipping_buy_price?: string | null
    lead_time?: string | null
    payable?: string | null
    freight_condition?: string | null
    freight_condition_dismiss?: boolean | null
    customer_email?: string | null
    emails?: string | null
    invoice_date?: Date | string | null
    invoice_email?: string | null
    billing_name?: string | null
    billing_company?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_country?: string | null
    billing_zip?: string | null
    billing_phone?: string | null
    billing_fax?: string | null
    shipping_name?: string | null
    shipping_company?: string | null
    shipping_address?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_country?: string | null
    shipping_zip?: string | null
    shipping_phone?: string | null
    shipping_email?: string | null
    shipping_fax?: string | null
    sales_person?: number | null
    project_manager?: number | null
    accept_agreement?: number | null
    date_created?: Date | string | null
    created_month?: string | null
    created_year?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    QuoteItems?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    User?: UserUpdateOneWithoutQuotesNestedInput
    QuoteItems?: QuoteItemUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    quote_item_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    QuoteItems?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteCreateManyInput = {
    id?: string
    user_id: string
    quote_item_id?: number
    status?: string | null
    payment_status?: string | null
    quote_type?: $Enums.QuoteType
    tax?: string | null
    deposit_paid?: string | null
    shipping?: string | null
    tax_buy_price?: string | null
    shipping_buy_price?: string | null
    lead_time?: string | null
    payable?: string | null
    freight_condition?: string | null
    freight_condition_dismiss?: boolean | null
    customer_email?: string | null
    emails?: string | null
    invoice_date?: Date | string | null
    invoice_email?: string | null
    billing_name?: string | null
    billing_company?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_country?: string | null
    billing_zip?: string | null
    billing_phone?: string | null
    billing_fax?: string | null
    shipping_name?: string | null
    shipping_company?: string | null
    shipping_address?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_country?: string | null
    shipping_zip?: string | null
    shipping_phone?: string | null
    shipping_email?: string | null
    shipping_fax?: string | null
    sales_person?: number | null
    project_manager?: number | null
    accept_agreement?: number | null
    date_created?: Date | string | null
    created_month?: string | null
    created_year?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
  }

  export type QuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    quote_item_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QuoteItemCreateInput = {
    id?: string
    file_name?: string | null
    file_url?: string | null
    status?: boolean
    quantity?: number
    service?: string | null
    material?: string | null
    finish?: string | null
    description?: string | null
    process?: string | null
    specification?: string | null
    price?: string | null
    cost?: string | null
    cost_shipping_price?: string | null
    cost_shipping_total?: string | null
    custom_shipping_total?: string | null
    buy_price?: string | null
    buy_shipping_price?: string | null
    buy_shipping_total?: string | null
    quantity_owed?: string | null
    invoiced?: boolean | null
    non_taxable?: number | null
    non_shipping?: number | null
    is_deleted?: boolean | null
    vendor_id?: string | null
    vendor_details?: string | null
    last_updated_by?: number | null
    work_instructions?: string | null
    add_vendor?: boolean | null
    markings?: string | null
    part_item_number?: string | null
    file_year?: string | null
    file_month?: string | null
    tab_open?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    quote: QuoteCreateNestedOneWithoutQuoteItemsInput
  }

  export type QuoteItemUncheckedCreateInput = {
    id?: string
    quote_id: string
    file_name?: string | null
    file_url?: string | null
    status?: boolean
    quantity?: number
    service?: string | null
    material?: string | null
    finish?: string | null
    description?: string | null
    process?: string | null
    specification?: string | null
    price?: string | null
    cost?: string | null
    cost_shipping_price?: string | null
    cost_shipping_total?: string | null
    custom_shipping_total?: string | null
    buy_price?: string | null
    buy_shipping_price?: string | null
    buy_shipping_total?: string | null
    quantity_owed?: string | null
    invoiced?: boolean | null
    non_taxable?: number | null
    non_shipping?: number | null
    is_deleted?: boolean | null
    vendor_id?: string | null
    vendor_details?: string | null
    last_updated_by?: number | null
    work_instructions?: string | null
    add_vendor?: boolean | null
    markings?: string | null
    part_item_number?: string | null
    file_year?: string | null
    file_month?: string | null
    tab_open?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuoteItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    service?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    custom_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_owed?: NullableStringFieldUpdateOperationsInput | string | null
    invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    non_taxable?: NullableIntFieldUpdateOperationsInput | number | null
    non_shipping?: NullableIntFieldUpdateOperationsInput | number | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_details?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    work_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    add_vendor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    markings?: NullableStringFieldUpdateOperationsInput | string | null
    part_item_number?: NullableStringFieldUpdateOperationsInput | string | null
    file_year?: NullableStringFieldUpdateOperationsInput | string | null
    file_month?: NullableStringFieldUpdateOperationsInput | string | null
    tab_open?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quote?: QuoteUpdateOneRequiredWithoutQuoteItemsNestedInput
  }

  export type QuoteItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    service?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    custom_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_owed?: NullableStringFieldUpdateOperationsInput | string | null
    invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    non_taxable?: NullableIntFieldUpdateOperationsInput | number | null
    non_shipping?: NullableIntFieldUpdateOperationsInput | number | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_details?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    work_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    add_vendor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    markings?: NullableStringFieldUpdateOperationsInput | string | null
    part_item_number?: NullableStringFieldUpdateOperationsInput | string | null
    file_year?: NullableStringFieldUpdateOperationsInput | string | null
    file_month?: NullableStringFieldUpdateOperationsInput | string | null
    tab_open?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteItemCreateManyInput = {
    id?: string
    quote_id: string
    file_name?: string | null
    file_url?: string | null
    status?: boolean
    quantity?: number
    service?: string | null
    material?: string | null
    finish?: string | null
    description?: string | null
    process?: string | null
    specification?: string | null
    price?: string | null
    cost?: string | null
    cost_shipping_price?: string | null
    cost_shipping_total?: string | null
    custom_shipping_total?: string | null
    buy_price?: string | null
    buy_shipping_price?: string | null
    buy_shipping_total?: string | null
    quantity_owed?: string | null
    invoiced?: boolean | null
    non_taxable?: number | null
    non_shipping?: number | null
    is_deleted?: boolean | null
    vendor_id?: string | null
    vendor_details?: string | null
    last_updated_by?: number | null
    work_instructions?: string | null
    add_vendor?: boolean | null
    markings?: string | null
    part_item_number?: string | null
    file_year?: string | null
    file_month?: string | null
    tab_open?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuoteItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    service?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    custom_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_owed?: NullableStringFieldUpdateOperationsInput | string | null
    invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    non_taxable?: NullableIntFieldUpdateOperationsInput | number | null
    non_shipping?: NullableIntFieldUpdateOperationsInput | number | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_details?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    work_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    add_vendor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    markings?: NullableStringFieldUpdateOperationsInput | string | null
    part_item_number?: NullableStringFieldUpdateOperationsInput | string | null
    file_year?: NullableStringFieldUpdateOperationsInput | string | null
    file_month?: NullableStringFieldUpdateOperationsInput | string | null
    tab_open?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_id?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    service?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    custom_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_owed?: NullableStringFieldUpdateOperationsInput | string | null
    invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    non_taxable?: NullableIntFieldUpdateOperationsInput | number | null
    non_shipping?: NullableIntFieldUpdateOperationsInput | number | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_details?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    work_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    add_vendor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    markings?: NullableStringFieldUpdateOperationsInput | string | null
    part_item_number?: NullableStringFieldUpdateOperationsInput | string | null
    file_year?: NullableStringFieldUpdateOperationsInput | string | null
    file_month?: NullableStringFieldUpdateOperationsInput | string | null
    tab_open?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetOTPCreateInput = {
    id?: string
    email: string
    otp: string
    request_id: string
    expires_at: Date | string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutOtpsInput
  }

  export type PasswordResetOTPUncheckedCreateInput = {
    id?: string
    email: string
    otp: string
    request_id: string
    expires_at: Date | string
    created_at?: Date | string
    user_id: string
  }

  export type PasswordResetOTPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOtpsNestedInput
  }

  export type PasswordResetOTPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type PasswordResetOTPCreateManyInput = {
    id?: string
    email: string
    otp: string
    request_id: string
    expires_at: Date | string
    created_at?: Date | string
    user_id: string
  }

  export type PasswordResetOTPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetOTPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    expires_at: Date | string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    user_id: string
    token: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    user_id: string
    token: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantCurrencyCreateInput = {
    id?: string
    currency_id?: number
    code: string
    name: string
    symbol: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantCurrencyUncheckedCreateInput = {
    id?: string
    currency_id?: number
    code: string
    name: string
    symbol: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantCurrencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantCurrencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantCurrencyCreateManyInput = {
    id?: string
    currency_id?: number
    code: string
    name: string
    symbol: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantCurrencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantCurrencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantPaymentTermsCreateInput = {
    id?: string
    payment_terms_id?: number
    name: string
    description?: string | null
    due_days?: number
    discount_days?: number
    discount_percent?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantPaymentTermsUncheckedCreateInput = {
    id?: string
    payment_terms_id?: number
    name: string
    description?: string | null
    due_days?: number
    discount_days?: number
    discount_percent?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantPaymentTermsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_days?: IntFieldUpdateOperationsInput | number
    discount_days?: IntFieldUpdateOperationsInput | number
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantPaymentTermsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_days?: IntFieldUpdateOperationsInput | number
    discount_days?: IntFieldUpdateOperationsInput | number
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantPaymentTermsCreateManyInput = {
    id?: string
    payment_terms_id?: number
    name: string
    description?: string | null
    due_days?: number
    discount_days?: number
    discount_percent?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantPaymentTermsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_days?: IntFieldUpdateOperationsInput | number
    discount_days?: IntFieldUpdateOperationsInput | number
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantPaymentTermsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_days?: IntFieldUpdateOperationsInput | number
    discount_days?: IntFieldUpdateOperationsInput | number
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantPaymentStatusCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantPaymentStatusUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantPaymentStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantPaymentStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantPaymentStatusCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantPaymentStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantPaymentStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantQuoteStatusCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantQuoteStatusUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantQuoteStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantQuoteStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantQuoteStatusCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantQuoteStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantQuoteStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantOrderStatusCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantOrderStatusUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantOrderStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantOrderStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantOrderStatusCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantOrderStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantOrderStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantLogisticsStatusCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantLogisticsStatusUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantLogisticsStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantLogisticsStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantLogisticsStatusCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantLogisticsStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantLogisticsStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantFinanceStatusCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantFinanceStatusUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantFinanceStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantFinanceStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantFinanceStatusCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenantFinanceStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenantFinanceStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoUncheckedCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoUncheckedCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUncheckedUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUncheckedUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companyServiceCreateInput = {
    id?: string
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    materials?: companyMaterialCreateNestedManyWithoutServiceInput
    finishes?: companyFinishCreateNestedManyWithoutServiceInput
  }

  export type companyServiceUncheckedCreateInput = {
    id?: string
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    materials?: companyMaterialUncheckedCreateNestedManyWithoutServiceInput
    finishes?: companyFinishUncheckedCreateNestedManyWithoutServiceInput
  }

  export type companyServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exclude_inspection?: BoolFieldUpdateOperationsInput | boolean
    invoice50?: BoolFieldUpdateOperationsInput | boolean
    fob_china?: BoolFieldUpdateOperationsInput | boolean
    require_deposit_invoice?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: companyMaterialUpdateManyWithoutServiceNestedInput
    finishes?: companyFinishUpdateManyWithoutServiceNestedInput
  }

  export type companyServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exclude_inspection?: BoolFieldUpdateOperationsInput | boolean
    invoice50?: BoolFieldUpdateOperationsInput | boolean
    fob_china?: BoolFieldUpdateOperationsInput | boolean
    require_deposit_invoice?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: companyMaterialUncheckedUpdateManyWithoutServiceNestedInput
    finishes?: companyFinishUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type companyServiceCreateManyInput = {
    id?: string
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exclude_inspection?: BoolFieldUpdateOperationsInput | boolean
    invoice50?: BoolFieldUpdateOperationsInput | boolean
    fob_china?: BoolFieldUpdateOperationsInput | boolean
    require_deposit_invoice?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exclude_inspection?: BoolFieldUpdateOperationsInput | boolean
    invoice50?: BoolFieldUpdateOperationsInput | boolean
    fob_china?: BoolFieldUpdateOperationsInput | boolean
    require_deposit_invoice?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyMaterialCreateInput = {
    id?: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    service: companyServiceCreateNestedOneWithoutMaterialsInput
  }

  export type companyMaterialUncheckedCreateInput = {
    id?: string
    service_id: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyMaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: companyServiceUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type companyMaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyMaterialCreateManyInput = {
    id?: string
    service_id: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyMaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyMaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyFinishCreateInput = {
    id?: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    service: companyServiceCreateNestedOneWithoutFinishesInput
  }

  export type companyFinishUncheckedCreateInput = {
    id?: string
    service_id: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyFinishUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: companyServiceUpdateOneRequiredWithoutFinishesNestedInput
  }

  export type companyFinishUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyFinishCreateManyInput = {
    id?: string
    service_id: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyFinishUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyFinishUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateInput = {
    id?: string
    billing_address: string
    billing_address2?: string | null
    billing_city: string
    billing_state: string
    billing_zip: string
    billing_country: string
    shipping_address: string
    shipping_address2?: string | null
    shipping_city: string
    shipping_state: string
    shipping_zip: string
    shipping_country: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutAddressesInput
  }

  export type CustomerAddressUncheckedCreateInput = {
    id?: string
    customer_id: string
    billing_address: string
    billing_address2?: string | null
    billing_city: string
    billing_state: string
    billing_zip: string
    billing_country: string
    shipping_address: string
    shipping_address2?: string | null
    shipping_city: string
    shipping_state: string
    shipping_zip: string
    shipping_country: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_address?: StringFieldUpdateOperationsInput | string
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: StringFieldUpdateOperationsInput | string
    billing_state?: StringFieldUpdateOperationsInput | string
    billing_zip?: StringFieldUpdateOperationsInput | string
    billing_country?: StringFieldUpdateOperationsInput | string
    shipping_address?: StringFieldUpdateOperationsInput | string
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_zip?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type CustomerAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    billing_address?: StringFieldUpdateOperationsInput | string
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: StringFieldUpdateOperationsInput | string
    billing_state?: StringFieldUpdateOperationsInput | string
    billing_zip?: StringFieldUpdateOperationsInput | string
    billing_country?: StringFieldUpdateOperationsInput | string
    shipping_address?: StringFieldUpdateOperationsInput | string
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_zip?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateManyInput = {
    id?: string
    customer_id: string
    billing_address: string
    billing_address2?: string | null
    billing_city: string
    billing_state: string
    billing_zip: string
    billing_country: string
    shipping_address: string
    shipping_address2?: string | null
    shipping_city: string
    shipping_state: string
    shipping_zip: string
    shipping_country: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_address?: StringFieldUpdateOperationsInput | string
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: StringFieldUpdateOperationsInput | string
    billing_state?: StringFieldUpdateOperationsInput | string
    billing_zip?: StringFieldUpdateOperationsInput | string
    billing_country?: StringFieldUpdateOperationsInput | string
    shipping_address?: StringFieldUpdateOperationsInput | string
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_zip?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    billing_address?: StringFieldUpdateOperationsInput | string
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: StringFieldUpdateOperationsInput | string
    billing_state?: StringFieldUpdateOperationsInput | string
    billing_zip?: StringFieldUpdateOperationsInput | string
    billing_country?: StringFieldUpdateOperationsInput | string
    shipping_address?: StringFieldUpdateOperationsInput | string
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_zip?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaxInfoCreateInput = {
    id?: string
    tax_number?: string | null
    default_tax?: number | null
    currency: string
    payment_terms: string
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutTax_infoInput
  }

  export type CustomerTaxInfoUncheckedCreateInput = {
    id?: string
    customer_id: string
    tax_number?: string | null
    default_tax?: number | null
    currency: string
    payment_terms: string
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerTaxInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    default_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutTax_infoNestedInput
  }

  export type CustomerTaxInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    default_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaxInfoCreateManyInput = {
    id?: string
    customer_id: string
    tax_number?: string | null
    default_tax?: number | null
    currency: string
    payment_terms: string
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerTaxInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    default_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaxInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    default_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactCreateInput = {
    id?: string
    customer_name: string
    contact_name?: string | null
    job_title?: string | null
    contact_email?: string | null
    contact_phone?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutContactsInput
  }

  export type CustomerContactUncheckedCreateInput = {
    id?: string
    customer_id: string
    customer_name: string
    contact_name?: string | null
    job_title?: string | null
    contact_email?: string | null
    contact_phone?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutContactsNestedInput
  }

  export type CustomerContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactCreateManyInput = {
    id?: string
    customer_id: string
    customer_name: string
    contact_name?: string | null
    job_title?: string | null
    contact_email?: string | null
    contact_phone?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerOperationalInfoCreateInput = {
    id?: string
    delivery_method?: string | null
    quote_format?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutOperationalInput
  }

  export type CustomerOperationalInfoUncheckedCreateInput = {
    id?: string
    customer_id: string
    delivery_method?: string | null
    quote_format?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerOperationalInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_method?: NullableStringFieldUpdateOperationsInput | string | null
    quote_format?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOperationalNestedInput
  }

  export type CustomerOperationalInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    delivery_method?: NullableStringFieldUpdateOperationsInput | string | null
    quote_format?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerOperationalInfoCreateManyInput = {
    id?: string
    customer_id: string
    delivery_method?: string | null
    quote_format?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerOperationalInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_method?: NullableStringFieldUpdateOperationsInput | string | null
    quote_format?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerOperationalInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    delivery_method?: NullableStringFieldUpdateOperationsInput | string | null
    quote_format?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNotesAndAttachmentsCreateInput = {
    id?: string
    internal_notes?: string | null
    tags?: CustomerNotesAndAttachmentsCreatetagsInput | string[]
    file_url?: string | null
    file_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutAttachmentsInput
  }

  export type CustomerNotesAndAttachmentsUncheckedCreateInput = {
    id?: string
    customer_id: string
    internal_notes?: string | null
    tags?: CustomerNotesAndAttachmentsCreatetagsInput | string[]
    file_url?: string | null
    file_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerNotesAndAttachmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerNotesAndAttachmentsUpdatetagsInput | string[]
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type CustomerNotesAndAttachmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerNotesAndAttachmentsUpdatetagsInput | string[]
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNotesAndAttachmentsCreateManyInput = {
    id?: string
    customer_id: string
    internal_notes?: string | null
    tags?: CustomerNotesAndAttachmentsCreatetagsInput | string[]
    file_url?: string | null
    file_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerNotesAndAttachmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerNotesAndAttachmentsUpdatetagsInput | string[]
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNotesAndAttachmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerNotesAndAttachmentsUpdatetagsInput | string[]
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutVendorInput
    contacts?: VendorContactCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    contacts?: VendorContactUncheckedCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressUncheckedCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceUncheckedCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialUncheckedCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingUncheckedCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVendorNestedInput
    contacts?: VendorContactUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: VendorContactUncheckedUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUncheckedUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUncheckedUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUncheckedUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUncheckedUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorContactCreateInput = {
    id?: string
    contact_name: string
    job_title?: string | null
    email?: string | null
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutContactsInput
  }

  export type VendorContactUncheckedCreateInput = {
    id?: string
    vendor_id: string
    contact_name: string
    job_title?: string | null
    email?: string | null
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutContactsNestedInput
  }

  export type VendorContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorContactCreateManyInput = {
    id?: string
    vendor_id: string
    contact_name: string
    job_title?: string | null
    email?: string | null
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAddressCreateInput = {
    id?: string
    address_1: string
    address_2?: string | null
    city: string
    state: string
    zip: string
    country: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutAddressesInput
  }

  export type VendorAddressUncheckedCreateInput = {
    id?: string
    vendor_id: string
    address_1: string
    address_2?: string | null
    city: string
    state: string
    zip: string
    country: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address_1?: StringFieldUpdateOperationsInput | string
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type VendorAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    address_1?: StringFieldUpdateOperationsInput | string
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAddressCreateManyInput = {
    id?: string
    vendor_id: string
    address_1: string
    address_2?: string | null
    city: string
    state: string
    zip: string
    country: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address_1?: StringFieldUpdateOperationsInput | string
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    address_1?: StringFieldUpdateOperationsInput | string
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorTaxComplianceCreateInput = {
    id?: string
    tax_number?: string | null
    vat_number?: string | null
    company_number?: string | null
    compliance_type?: string | null
    file_name?: string | null
    file_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutTaxCompliancesInput
  }

  export type VendorTaxComplianceUncheckedCreateInput = {
    id?: string
    vendor_id: string
    tax_number?: string | null
    vat_number?: string | null
    company_number?: string | null
    compliance_type?: string | null
    file_name?: string | null
    file_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorTaxComplianceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_number?: NullableStringFieldUpdateOperationsInput | string | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutTaxCompliancesNestedInput
  }

  export type VendorTaxComplianceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_number?: NullableStringFieldUpdateOperationsInput | string | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorTaxComplianceCreateManyInput = {
    id?: string
    vendor_id: string
    tax_number?: string | null
    vat_number?: string | null
    company_number?: string | null
    compliance_type?: string | null
    file_name?: string | null
    file_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorTaxComplianceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_number?: NullableStringFieldUpdateOperationsInput | string | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorTaxComplianceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_number?: NullableStringFieldUpdateOperationsInput | string | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFinancialCreateInput = {
    id?: string
    bank_name?: string | null
    bank_account_number?: string | null
    swift_iban_code?: string | null
    preferred_currency: string
    payment_terms: string
    default_tax_rate?: string | null
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutFinancialsInput
  }

  export type VendorFinancialUncheckedCreateInput = {
    id?: string
    vendor_id: string
    bank_name?: string | null
    bank_account_number?: string | null
    swift_iban_code?: string | null
    preferred_currency: string
    payment_terms: string
    default_tax_rate?: string | null
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorFinancialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    swift_iban_code?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    default_tax_rate?: NullableStringFieldUpdateOperationsInput | string | null
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutFinancialsNestedInput
  }

  export type VendorFinancialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    swift_iban_code?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    default_tax_rate?: NullableStringFieldUpdateOperationsInput | string | null
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFinancialCreateManyInput = {
    id?: string
    vendor_id: string
    bank_name?: string | null
    bank_account_number?: string | null
    swift_iban_code?: string | null
    preferred_currency: string
    payment_terms: string
    default_tax_rate?: string | null
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorFinancialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    swift_iban_code?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    default_tax_rate?: NullableStringFieldUpdateOperationsInput | string | null
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFinancialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    swift_iban_code?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    default_tax_rate?: NullableStringFieldUpdateOperationsInput | string | null
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorOperationalSettingCreateInput = {
    id?: string
    status?: string | null
    shipping_method?: string | null
    lead_time?: number | null
    minimum_order_quantity?: number | null
    categories?: VendorOperationalSettingCreatecategoriesInput | string[]
    manager: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutOperationalSettingInput
  }

  export type VendorOperationalSettingUncheckedCreateInput = {
    id?: string
    vendor_id: string
    status?: string | null
    shipping_method?: string | null
    lead_time?: number | null
    minimum_order_quantity?: number | null
    categories?: VendorOperationalSettingCreatecategoriesInput | string[]
    manager: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorOperationalSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableIntFieldUpdateOperationsInput | number | null
    minimum_order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: VendorOperationalSettingUpdatecategoriesInput | string[]
    manager?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutOperationalSettingNestedInput
  }

  export type VendorOperationalSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableIntFieldUpdateOperationsInput | number | null
    minimum_order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: VendorOperationalSettingUpdatecategoriesInput | string[]
    manager?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorOperationalSettingCreateManyInput = {
    id?: string
    vendor_id: string
    status?: string | null
    shipping_method?: string | null
    lead_time?: number | null
    minimum_order_quantity?: number | null
    categories?: VendorOperationalSettingCreatecategoriesInput | string[]
    manager: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorOperationalSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableIntFieldUpdateOperationsInput | number | null
    minimum_order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: VendorOperationalSettingUpdatecategoriesInput | string[]
    manager?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorOperationalSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableIntFieldUpdateOperationsInput | number | null
    minimum_order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: VendorOperationalSettingUpdatecategoriesInput | string[]
    manager?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorMetadataCreateInput = {
    id?: string
    notes?: string | null
    tags?: VendorMetadataCreatetagsInput | string[]
    score?: number | null
    last_order?: Date | string
    next_review?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutMetadataInput
  }

  export type VendorMetadataUncheckedCreateInput = {
    id?: string
    vendor_id: string
    notes?: string | null
    tags?: VendorMetadataCreatetagsInput | string[]
    score?: number | null
    last_order?: Date | string
    next_review?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VendorMetadataUpdatetagsInput | string[]
    score?: NullableIntFieldUpdateOperationsInput | number | null
    last_order?: DateTimeFieldUpdateOperationsInput | Date | string
    next_review?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutMetadataNestedInput
  }

  export type VendorMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VendorMetadataUpdatetagsInput | string[]
    score?: NullableIntFieldUpdateOperationsInput | number | null
    last_order?: DateTimeFieldUpdateOperationsInput | Date | string
    next_review?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorMetadataCreateManyInput = {
    id?: string
    vendor_id: string
    notes?: string | null
    tags?: VendorMetadataCreatetagsInput | string[]
    score?: number | null
    last_order?: Date | string
    next_review?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VendorMetadataUpdatetagsInput | string[]
    score?: NullableIntFieldUpdateOperationsInput | number | null
    last_order?: DateTimeFieldUpdateOperationsInput | Date | string
    next_review?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VendorMetadataUpdatetagsInput | string[]
    score?: NullableIntFieldUpdateOperationsInput | number | null
    last_order?: DateTimeFieldUpdateOperationsInput | Date | string
    next_review?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capabilitiesCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    subCategories?: company_vendor_capability_sub_categoriesCreateNestedManyWithoutCapabilityInput
  }

  export type company_vendor_capabilitiesUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    subCategories?: company_vendor_capability_sub_categoriesUncheckedCreateNestedManyWithoutCapabilityInput
  }

  export type company_vendor_capabilitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: company_vendor_capability_sub_categoriesUpdateManyWithoutCapabilityNestedInput
  }

  export type company_vendor_capabilitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: company_vendor_capability_sub_categoriesUncheckedUpdateManyWithoutCapabilityNestedInput
  }

  export type company_vendor_capabilitiesCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_capabilitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capabilitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capability_sub_categoriesCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    capability: company_vendor_capabilitiesCreateNestedOneWithoutSubCategoriesInput
  }

  export type company_vendor_capability_sub_categoriesUncheckedCreateInput = {
    id?: string
    name: string
    vendor_capability_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_capability_sub_categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    capability?: company_vendor_capabilitiesUpdateOneRequiredWithoutSubCategoriesNestedInput
  }

  export type company_vendor_capability_sub_categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor_capability_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capability_sub_categoriesCreateManyInput = {
    id?: string
    name: string
    vendor_capability_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_capability_sub_categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capability_sub_categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor_capability_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_certificationsCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_certificationsUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_certificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_certificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_certificationsCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_certificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_certificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_flagsCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_flagsUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_flagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_flagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_flagsCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_flagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_flagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_schoolCreateInput = {
    id?: string
    name: string
    class: string
    roll_no: string
  }

  export type company_schoolUncheckedCreateInput = {
    id?: string
    name: string
    class: string
    roll_no: string
  }

  export type company_schoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    roll_no?: StringFieldUpdateOperationsInput | string
  }

  export type company_schoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    roll_no?: StringFieldUpdateOperationsInput | string
  }

  export type company_schoolCreateManyInput = {
    id?: string
    name: string
    class: string
    roll_no: string
  }

  export type company_schoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    roll_no?: StringFieldUpdateOperationsInput | string
  }

  export type company_schoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    roll_no?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type VendorNullableScalarRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type PasswordResetOTPListRelationFilter = {
    every?: PasswordResetOTPWhereInput
    some?: PasswordResetOTPWhereInput
    none?: PasswordResetOTPWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PasswordResetOTPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    roles?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumQuoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteType | EnumQuoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteType[] | ListEnumQuoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteType[] | ListEnumQuoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteTypeFilter<$PrismaModel> | $Enums.QuoteType
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type QuoteItemListRelationFilter = {
    every?: QuoteItemWhereInput
    some?: QuoteItemWhereInput
    none?: QuoteItemWhereInput
  }

  export type QuoteItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quote_item_id?: SortOrder
    status?: SortOrder
    payment_status?: SortOrder
    quote_type?: SortOrder
    tax?: SortOrder
    deposit_paid?: SortOrder
    shipping?: SortOrder
    tax_buy_price?: SortOrder
    shipping_buy_price?: SortOrder
    lead_time?: SortOrder
    payable?: SortOrder
    freight_condition?: SortOrder
    freight_condition_dismiss?: SortOrder
    customer_email?: SortOrder
    emails?: SortOrder
    invoice_date?: SortOrder
    invoice_email?: SortOrder
    billing_name?: SortOrder
    billing_company?: SortOrder
    billing_address?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_country?: SortOrder
    billing_zip?: SortOrder
    billing_phone?: SortOrder
    billing_fax?: SortOrder
    shipping_name?: SortOrder
    shipping_company?: SortOrder
    shipping_address?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_country?: SortOrder
    shipping_zip?: SortOrder
    shipping_phone?: SortOrder
    shipping_email?: SortOrder
    shipping_fax?: SortOrder
    sales_person?: SortOrder
    project_manager?: SortOrder
    accept_agreement?: SortOrder
    date_created?: SortOrder
    created_month?: SortOrder
    created_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type QuoteAvgOrderByAggregateInput = {
    quote_item_id?: SortOrder
    sales_person?: SortOrder
    project_manager?: SortOrder
    accept_agreement?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quote_item_id?: SortOrder
    status?: SortOrder
    payment_status?: SortOrder
    quote_type?: SortOrder
    tax?: SortOrder
    deposit_paid?: SortOrder
    shipping?: SortOrder
    tax_buy_price?: SortOrder
    shipping_buy_price?: SortOrder
    lead_time?: SortOrder
    payable?: SortOrder
    freight_condition?: SortOrder
    freight_condition_dismiss?: SortOrder
    customer_email?: SortOrder
    emails?: SortOrder
    invoice_date?: SortOrder
    invoice_email?: SortOrder
    billing_name?: SortOrder
    billing_company?: SortOrder
    billing_address?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_country?: SortOrder
    billing_zip?: SortOrder
    billing_phone?: SortOrder
    billing_fax?: SortOrder
    shipping_name?: SortOrder
    shipping_company?: SortOrder
    shipping_address?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_country?: SortOrder
    shipping_zip?: SortOrder
    shipping_phone?: SortOrder
    shipping_email?: SortOrder
    shipping_fax?: SortOrder
    sales_person?: SortOrder
    project_manager?: SortOrder
    accept_agreement?: SortOrder
    date_created?: SortOrder
    created_month?: SortOrder
    created_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quote_item_id?: SortOrder
    status?: SortOrder
    payment_status?: SortOrder
    quote_type?: SortOrder
    tax?: SortOrder
    deposit_paid?: SortOrder
    shipping?: SortOrder
    tax_buy_price?: SortOrder
    shipping_buy_price?: SortOrder
    lead_time?: SortOrder
    payable?: SortOrder
    freight_condition?: SortOrder
    freight_condition_dismiss?: SortOrder
    customer_email?: SortOrder
    emails?: SortOrder
    invoice_date?: SortOrder
    invoice_email?: SortOrder
    billing_name?: SortOrder
    billing_company?: SortOrder
    billing_address?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_country?: SortOrder
    billing_zip?: SortOrder
    billing_phone?: SortOrder
    billing_fax?: SortOrder
    shipping_name?: SortOrder
    shipping_company?: SortOrder
    shipping_address?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_country?: SortOrder
    shipping_zip?: SortOrder
    shipping_phone?: SortOrder
    shipping_email?: SortOrder
    shipping_fax?: SortOrder
    sales_person?: SortOrder
    project_manager?: SortOrder
    accept_agreement?: SortOrder
    date_created?: SortOrder
    created_month?: SortOrder
    created_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type QuoteSumOrderByAggregateInput = {
    quote_item_id?: SortOrder
    sales_person?: SortOrder
    project_manager?: SortOrder
    accept_agreement?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumQuoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteType | EnumQuoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteType[] | ListEnumQuoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteType[] | ListEnumQuoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteTypeFilter<$PrismaModel>
    _max?: NestedEnumQuoteTypeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QuoteScalarRelationFilter = {
    is?: QuoteWhereInput
    isNot?: QuoteWhereInput
  }

  export type QuoteItemCountOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    status?: SortOrder
    quantity?: SortOrder
    service?: SortOrder
    material?: SortOrder
    finish?: SortOrder
    description?: SortOrder
    process?: SortOrder
    specification?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    cost_shipping_price?: SortOrder
    cost_shipping_total?: SortOrder
    custom_shipping_total?: SortOrder
    buy_price?: SortOrder
    buy_shipping_price?: SortOrder
    buy_shipping_total?: SortOrder
    quantity_owed?: SortOrder
    invoiced?: SortOrder
    non_taxable?: SortOrder
    non_shipping?: SortOrder
    is_deleted?: SortOrder
    vendor_id?: SortOrder
    vendor_details?: SortOrder
    last_updated_by?: SortOrder
    work_instructions?: SortOrder
    add_vendor?: SortOrder
    markings?: SortOrder
    part_item_number?: SortOrder
    file_year?: SortOrder
    file_month?: SortOrder
    tab_open?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type QuoteItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    non_taxable?: SortOrder
    non_shipping?: SortOrder
    last_updated_by?: SortOrder
  }

  export type QuoteItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    status?: SortOrder
    quantity?: SortOrder
    service?: SortOrder
    material?: SortOrder
    finish?: SortOrder
    description?: SortOrder
    process?: SortOrder
    specification?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    cost_shipping_price?: SortOrder
    cost_shipping_total?: SortOrder
    custom_shipping_total?: SortOrder
    buy_price?: SortOrder
    buy_shipping_price?: SortOrder
    buy_shipping_total?: SortOrder
    quantity_owed?: SortOrder
    invoiced?: SortOrder
    non_taxable?: SortOrder
    non_shipping?: SortOrder
    is_deleted?: SortOrder
    vendor_id?: SortOrder
    vendor_details?: SortOrder
    last_updated_by?: SortOrder
    work_instructions?: SortOrder
    add_vendor?: SortOrder
    markings?: SortOrder
    part_item_number?: SortOrder
    file_year?: SortOrder
    file_month?: SortOrder
    tab_open?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type QuoteItemMinOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    status?: SortOrder
    quantity?: SortOrder
    service?: SortOrder
    material?: SortOrder
    finish?: SortOrder
    description?: SortOrder
    process?: SortOrder
    specification?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    cost_shipping_price?: SortOrder
    cost_shipping_total?: SortOrder
    custom_shipping_total?: SortOrder
    buy_price?: SortOrder
    buy_shipping_price?: SortOrder
    buy_shipping_total?: SortOrder
    quantity_owed?: SortOrder
    invoiced?: SortOrder
    non_taxable?: SortOrder
    non_shipping?: SortOrder
    is_deleted?: SortOrder
    vendor_id?: SortOrder
    vendor_details?: SortOrder
    last_updated_by?: SortOrder
    work_instructions?: SortOrder
    add_vendor?: SortOrder
    markings?: SortOrder
    part_item_number?: SortOrder
    file_year?: SortOrder
    file_month?: SortOrder
    tab_open?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type QuoteItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    non_taxable?: SortOrder
    non_shipping?: SortOrder
    last_updated_by?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PasswordResetOTPCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    request_id?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type PasswordResetOTPMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    request_id?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type PasswordResetOTPMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    request_id?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type tenantCurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    currency_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantCurrencyAvgOrderByAggregateInput = {
    currency_id?: SortOrder
  }

  export type tenantCurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    currency_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantCurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    currency_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantCurrencySumOrderByAggregateInput = {
    currency_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type tenantPaymentTermsCountOrderByAggregateInput = {
    id?: SortOrder
    payment_terms_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    due_days?: SortOrder
    discount_days?: SortOrder
    discount_percent?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantPaymentTermsAvgOrderByAggregateInput = {
    payment_terms_id?: SortOrder
    due_days?: SortOrder
    discount_days?: SortOrder
    discount_percent?: SortOrder
  }

  export type tenantPaymentTermsMaxOrderByAggregateInput = {
    id?: SortOrder
    payment_terms_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    due_days?: SortOrder
    discount_days?: SortOrder
    discount_percent?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantPaymentTermsMinOrderByAggregateInput = {
    id?: SortOrder
    payment_terms_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    due_days?: SortOrder
    discount_days?: SortOrder
    discount_percent?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantPaymentTermsSumOrderByAggregateInput = {
    payment_terms_id?: SortOrder
    due_days?: SortOrder
    discount_days?: SortOrder
    discount_percent?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type tenantPaymentStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantPaymentStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantPaymentStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantQuoteStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantQuoteStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantQuoteStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantOrderStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantOrderStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantOrderStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantLogisticsStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantLogisticsStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantLogisticsStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantFinanceStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantFinanceStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenantFinanceStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerAddressListRelationFilter = {
    every?: CustomerAddressWhereInput
    some?: CustomerAddressWhereInput
    none?: CustomerAddressWhereInput
  }

  export type CustomerTaxInfoNullableScalarRelationFilter = {
    is?: CustomerTaxInfoWhereInput | null
    isNot?: CustomerTaxInfoWhereInput | null
  }

  export type CustomerContactListRelationFilter = {
    every?: CustomerContactWhereInput
    some?: CustomerContactWhereInput
    none?: CustomerContactWhereInput
  }

  export type CustomerOperationalInfoNullableScalarRelationFilter = {
    is?: CustomerOperationalInfoWhereInput | null
    isNot?: CustomerOperationalInfoWhereInput | null
  }

  export type CustomerNotesAndAttachmentsListRelationFilter = {
    every?: CustomerNotesAndAttachmentsWhereInput
    some?: CustomerNotesAndAttachmentsWhereInput
    none?: CustomerNotesAndAttachmentsWhereInput
  }

  export type CustomerAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerNotesAndAttachmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    customer_name?: SortOrder
    company_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    website?: SortOrder
    is_active?: SortOrder
    notes?: SortOrder
    sorting?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    customer_id?: SortOrder
    sorting?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    customer_name?: SortOrder
    company_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    website?: SortOrder
    is_active?: SortOrder
    notes?: SortOrder
    sorting?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    customer_name?: SortOrder
    company_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    website?: SortOrder
    is_active?: SortOrder
    notes?: SortOrder
    sorting?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    customer_id?: SortOrder
    sorting?: SortOrder
  }

  export type CompanyMaterialListRelationFilter = {
    every?: companyMaterialWhereInput
    some?: companyMaterialWhereInput
    none?: companyMaterialWhereInput
  }

  export type CompanyFinishListRelationFilter = {
    every?: companyFinishWhereInput
    some?: companyFinishWhereInput
    none?: companyFinishWhereInput
  }

  export type companyMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companyFinishOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companyServiceCountOrderByAggregateInput = {
    id?: SortOrder
    exclude_inspection?: SortOrder
    invoice50?: SortOrder
    fob_china?: SortOrder
    require_deposit_invoice?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companyServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    exclude_inspection?: SortOrder
    invoice50?: SortOrder
    fob_china?: SortOrder
    require_deposit_invoice?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companyServiceMinOrderByAggregateInput = {
    id?: SortOrder
    exclude_inspection?: SortOrder
    invoice50?: SortOrder
    fob_china?: SortOrder
    require_deposit_invoice?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CompanyServiceScalarRelationFilter = {
    is?: companyServiceWhereInput
    isNot?: companyServiceWhereInput
  }

  export type companyMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companyMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companyMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companyFinishCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companyFinishMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companyFinishMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerAddressCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    billing_address?: SortOrder
    billing_address2?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    shipping_address?: SortOrder
    shipping_address2?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_zip?: SortOrder
    shipping_country?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    billing_address?: SortOrder
    billing_address2?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    shipping_address?: SortOrder
    shipping_address2?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_zip?: SortOrder
    shipping_country?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerAddressMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    billing_address?: SortOrder
    billing_address2?: SortOrder
    billing_city?: SortOrder
    billing_state?: SortOrder
    billing_zip?: SortOrder
    billing_country?: SortOrder
    shipping_address?: SortOrder
    shipping_address2?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_zip?: SortOrder
    shipping_country?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerTaxInfoCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    tax_number?: SortOrder
    default_tax?: SortOrder
    currency?: SortOrder
    payment_terms?: SortOrder
    credit_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerTaxInfoAvgOrderByAggregateInput = {
    default_tax?: SortOrder
    credit_limit?: SortOrder
  }

  export type CustomerTaxInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    tax_number?: SortOrder
    default_tax?: SortOrder
    currency?: SortOrder
    payment_terms?: SortOrder
    credit_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerTaxInfoMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    tax_number?: SortOrder
    default_tax?: SortOrder
    currency?: SortOrder
    payment_terms?: SortOrder
    credit_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerTaxInfoSumOrderByAggregateInput = {
    default_tax?: SortOrder
    credit_limit?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CustomerContactCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    contact_name?: SortOrder
    job_title?: SortOrder
    contact_email?: SortOrder
    contact_phone?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerContactMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    contact_name?: SortOrder
    job_title?: SortOrder
    contact_email?: SortOrder
    contact_phone?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerContactMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    contact_name?: SortOrder
    job_title?: SortOrder
    contact_email?: SortOrder
    contact_phone?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerOperationalInfoCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    delivery_method?: SortOrder
    quote_format?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerOperationalInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    delivery_method?: SortOrder
    quote_format?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerOperationalInfoMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    delivery_method?: SortOrder
    quote_format?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CustomerNotesAndAttachmentsCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    internal_notes?: SortOrder
    tags?: SortOrder
    file_url?: SortOrder
    file_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerNotesAndAttachmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    internal_notes?: SortOrder
    file_url?: SortOrder
    file_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerNotesAndAttachmentsMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    internal_notes?: SortOrder
    file_url?: SortOrder
    file_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorContactNullableScalarRelationFilter = {
    is?: VendorContactWhereInput | null
    isNot?: VendorContactWhereInput | null
  }

  export type VendorAddressNullableScalarRelationFilter = {
    is?: VendorAddressWhereInput | null
    isNot?: VendorAddressWhereInput | null
  }

  export type VendorTaxComplianceNullableScalarRelationFilter = {
    is?: VendorTaxComplianceWhereInput | null
    isNot?: VendorTaxComplianceWhereInput | null
  }

  export type VendorFinancialNullableScalarRelationFilter = {
    is?: VendorFinancialWhereInput | null
    isNot?: VendorFinancialWhereInput | null
  }

  export type VendorOperationalSettingNullableScalarRelationFilter = {
    is?: VendorOperationalSettingWhereInput | null
    isNot?: VendorOperationalSettingWhereInput | null
  }

  export type VendorMetadataNullableScalarRelationFilter = {
    is?: VendorMetadataWhereInput | null
    isNot?: VendorMetadataWhereInput | null
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    vendor_name?: SortOrder
    vendor_type?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    vendor_id?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    vendor_name?: SortOrder
    vendor_type?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    vendor_name?: SortOrder
    vendor_type?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    vendor_id?: SortOrder
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type VendorContactCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    contact_name?: SortOrder
    job_title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorContactMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    contact_name?: SortOrder
    job_title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorContactMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    contact_name?: SortOrder
    job_title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorAddressCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorAddressMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorTaxComplianceCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    tax_number?: SortOrder
    vat_number?: SortOrder
    company_number?: SortOrder
    compliance_type?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorTaxComplianceMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    tax_number?: SortOrder
    vat_number?: SortOrder
    company_number?: SortOrder
    compliance_type?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorTaxComplianceMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    tax_number?: SortOrder
    vat_number?: SortOrder
    company_number?: SortOrder
    compliance_type?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorFinancialCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    bank_name?: SortOrder
    bank_account_number?: SortOrder
    swift_iban_code?: SortOrder
    preferred_currency?: SortOrder
    payment_terms?: SortOrder
    default_tax_rate?: SortOrder
    credit_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorFinancialAvgOrderByAggregateInput = {
    credit_limit?: SortOrder
  }

  export type VendorFinancialMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    bank_name?: SortOrder
    bank_account_number?: SortOrder
    swift_iban_code?: SortOrder
    preferred_currency?: SortOrder
    payment_terms?: SortOrder
    default_tax_rate?: SortOrder
    credit_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorFinancialMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    bank_name?: SortOrder
    bank_account_number?: SortOrder
    swift_iban_code?: SortOrder
    preferred_currency?: SortOrder
    payment_terms?: SortOrder
    default_tax_rate?: SortOrder
    credit_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorFinancialSumOrderByAggregateInput = {
    credit_limit?: SortOrder
  }

  export type VendorOperationalSettingCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    status?: SortOrder
    shipping_method?: SortOrder
    lead_time?: SortOrder
    minimum_order_quantity?: SortOrder
    categories?: SortOrder
    manager?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorOperationalSettingAvgOrderByAggregateInput = {
    lead_time?: SortOrder
    minimum_order_quantity?: SortOrder
  }

  export type VendorOperationalSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    status?: SortOrder
    shipping_method?: SortOrder
    lead_time?: SortOrder
    minimum_order_quantity?: SortOrder
    manager?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorOperationalSettingMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    status?: SortOrder
    shipping_method?: SortOrder
    lead_time?: SortOrder
    minimum_order_quantity?: SortOrder
    manager?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorOperationalSettingSumOrderByAggregateInput = {
    lead_time?: SortOrder
    minimum_order_quantity?: SortOrder
  }

  export type VendorMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    score?: SortOrder
    last_order?: SortOrder
    next_review?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorMetadataAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type VendorMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    notes?: SortOrder
    score?: SortOrder
    last_order?: SortOrder
    next_review?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_id?: SortOrder
    notes?: SortOrder
    score?: SortOrder
    last_order?: SortOrder
    next_review?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorMetadataSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type Company_vendor_capability_sub_categoriesListRelationFilter = {
    every?: company_vendor_capability_sub_categoriesWhereInput
    some?: company_vendor_capability_sub_categoriesWhereInput
    none?: company_vendor_capability_sub_categoriesWhereInput
  }

  export type company_vendor_capability_sub_categoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_vendor_capabilitiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_capabilitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_capabilitiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Company_vendor_capabilitiesScalarRelationFilter = {
    is?: company_vendor_capabilitiesWhereInput
    isNot?: company_vendor_capabilitiesWhereInput
  }

  export type company_vendor_capability_sub_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vendor_capability_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_capability_sub_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vendor_capability_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_capability_sub_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vendor_capability_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_certificationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_certificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_certificationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_flagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_flagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_vendor_flagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_schoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    roll_no?: SortOrder
  }

  export type company_schoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    roll_no?: SortOrder
  }

  export type company_schoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    roll_no?: SortOrder
  }

  export type CustomerCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    connect?: CustomerWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutUserInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    connect?: VendorWhereUniqueInput
  }

  export type PasswordResetOTPCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetOTPCreateWithoutUserInput, PasswordResetOTPUncheckedCreateWithoutUserInput> | PasswordResetOTPCreateWithoutUserInput[] | PasswordResetOTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetOTPCreateOrConnectWithoutUserInput | PasswordResetOTPCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetOTPCreateManyUserInputEnvelope
    connect?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutUserInput = {
    create?: XOR<QuoteCreateWithoutUserInput, QuoteUncheckedCreateWithoutUserInput> | QuoteCreateWithoutUserInput[] | QuoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutUserInput | QuoteCreateOrConnectWithoutUserInput[]
    createMany?: QuoteCreateManyUserInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    connect?: CustomerWhereUniqueInput
  }

  export type VendorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    connect?: VendorWhereUniqueInput
  }

  export type PasswordResetOTPUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetOTPCreateWithoutUserInput, PasswordResetOTPUncheckedCreateWithoutUserInput> | PasswordResetOTPCreateWithoutUserInput[] | PasswordResetOTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetOTPCreateOrConnectWithoutUserInput | PasswordResetOTPCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetOTPCreateManyUserInputEnvelope
    connect?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuoteCreateWithoutUserInput, QuoteUncheckedCreateWithoutUserInput> | QuoteCreateWithoutUserInput[] | QuoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutUserInput | QuoteCreateOrConnectWithoutUserInput[]
    createMany?: QuoteCreateManyUserInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomerUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    upsert?: CustomerUpsertWithoutUserInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserInput, CustomerUpdateWithoutUserInput>, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type VendorUpdateOneWithoutUserNestedInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    upsert?: VendorUpsertWithoutUserInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutUserInput, VendorUpdateWithoutUserInput>, VendorUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetOTPUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetOTPCreateWithoutUserInput, PasswordResetOTPUncheckedCreateWithoutUserInput> | PasswordResetOTPCreateWithoutUserInput[] | PasswordResetOTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetOTPCreateOrConnectWithoutUserInput | PasswordResetOTPCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetOTPUpsertWithWhereUniqueWithoutUserInput | PasswordResetOTPUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetOTPCreateManyUserInputEnvelope
    set?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
    disconnect?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
    delete?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
    connect?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
    update?: PasswordResetOTPUpdateWithWhereUniqueWithoutUserInput | PasswordResetOTPUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetOTPUpdateManyWithWhereWithoutUserInput | PasswordResetOTPUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetOTPScalarWhereInput | PasswordResetOTPScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuoteCreateWithoutUserInput, QuoteUncheckedCreateWithoutUserInput> | QuoteCreateWithoutUserInput[] | QuoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutUserInput | QuoteCreateOrConnectWithoutUserInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutUserInput | QuoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuoteCreateManyUserInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutUserInput | QuoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutUserInput | QuoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    upsert?: CustomerUpsertWithoutUserInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserInput, CustomerUpdateWithoutUserInput>, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type VendorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    upsert?: VendorUpsertWithoutUserInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutUserInput, VendorUpdateWithoutUserInput>, VendorUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetOTPUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetOTPCreateWithoutUserInput, PasswordResetOTPUncheckedCreateWithoutUserInput> | PasswordResetOTPCreateWithoutUserInput[] | PasswordResetOTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetOTPCreateOrConnectWithoutUserInput | PasswordResetOTPCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetOTPUpsertWithWhereUniqueWithoutUserInput | PasswordResetOTPUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetOTPCreateManyUserInputEnvelope
    set?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
    disconnect?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
    delete?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
    connect?: PasswordResetOTPWhereUniqueInput | PasswordResetOTPWhereUniqueInput[]
    update?: PasswordResetOTPUpdateWithWhereUniqueWithoutUserInput | PasswordResetOTPUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetOTPUpdateManyWithWhereWithoutUserInput | PasswordResetOTPUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetOTPScalarWhereInput | PasswordResetOTPScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuoteCreateWithoutUserInput, QuoteUncheckedCreateWithoutUserInput> | QuoteCreateWithoutUserInput[] | QuoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutUserInput | QuoteCreateOrConnectWithoutUserInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutUserInput | QuoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuoteCreateManyUserInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutUserInput | QuoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutUserInput | QuoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutQuotesInput = {
    create?: XOR<UserCreateWithoutQuotesInput, UserUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotesInput
    connect?: UserWhereUniqueInput
  }

  export type QuoteItemCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type QuoteItemUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type EnumQuoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuoteType
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<UserCreateWithoutQuotesInput, UserUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotesInput
    upsert?: UserUpsertWithoutQuotesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuotesInput, UserUpdateWithoutQuotesInput>, UserUncheckedUpdateWithoutQuotesInput>
  }

  export type QuoteItemUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutQuoteInput | QuoteItemUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutQuoteInput | QuoteItemUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutQuoteInput | QuoteItemUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutQuoteInput | QuoteItemUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutQuoteInput | QuoteItemUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutQuoteInput | QuoteItemUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type QuoteCreateNestedOneWithoutQuoteItemsInput = {
    create?: XOR<QuoteCreateWithoutQuoteItemsInput, QuoteUncheckedCreateWithoutQuoteItemsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutQuoteItemsInput
    connect?: QuoteWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type QuoteUpdateOneRequiredWithoutQuoteItemsNestedInput = {
    create?: XOR<QuoteCreateWithoutQuoteItemsInput, QuoteUncheckedCreateWithoutQuoteItemsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutQuoteItemsInput
    upsert?: QuoteUpsertWithoutQuoteItemsInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutQuoteItemsInput, QuoteUpdateWithoutQuoteItemsInput>, QuoteUncheckedUpdateWithoutQuoteItemsInput>
  }

  export type UserCreateNestedOneWithoutOtpsInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOtpsNestedInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    upsert?: UserUpsertWithoutOtpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpsInput, UserUpdateWithoutOtpsInput>, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserCreateNestedOneWithoutResetTokensInput = {
    create?: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokensInput
    upsert?: UserUpsertWithoutResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResetTokensInput, UserUpdateWithoutResetTokensInput>, UserUncheckedUpdateWithoutResetTokensInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerAddressCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type CustomerTaxInfoCreateNestedOneWithoutCustomerInput = {
    create?: XOR<CustomerTaxInfoCreateWithoutCustomerInput, CustomerTaxInfoUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerTaxInfoCreateOrConnectWithoutCustomerInput
    connect?: CustomerTaxInfoWhereUniqueInput
  }

  export type CustomerContactCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput> | CustomerContactCreateWithoutCustomerInput[] | CustomerContactUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerContactCreateOrConnectWithoutCustomerInput | CustomerContactCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerContactCreateManyCustomerInputEnvelope
    connect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
  }

  export type CustomerOperationalInfoCreateNestedOneWithoutCustomerInput = {
    create?: XOR<CustomerOperationalInfoCreateWithoutCustomerInput, CustomerOperationalInfoUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerOperationalInfoCreateOrConnectWithoutCustomerInput
    connect?: CustomerOperationalInfoWhereUniqueInput
  }

  export type CustomerNotesAndAttachmentsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerNotesAndAttachmentsCreateWithoutCustomerInput, CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput> | CustomerNotesAndAttachmentsCreateWithoutCustomerInput[] | CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput | CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerNotesAndAttachmentsCreateManyCustomerInputEnvelope
    connect?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
  }

  export type CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type CustomerTaxInfoUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<CustomerTaxInfoCreateWithoutCustomerInput, CustomerTaxInfoUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerTaxInfoCreateOrConnectWithoutCustomerInput
    connect?: CustomerTaxInfoWhereUniqueInput
  }

  export type CustomerContactUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput> | CustomerContactCreateWithoutCustomerInput[] | CustomerContactUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerContactCreateOrConnectWithoutCustomerInput | CustomerContactCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerContactCreateManyCustomerInputEnvelope
    connect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
  }

  export type CustomerOperationalInfoUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<CustomerOperationalInfoCreateWithoutCustomerInput, CustomerOperationalInfoUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerOperationalInfoCreateOrConnectWithoutCustomerInput
    connect?: CustomerOperationalInfoWhereUniqueInput
  }

  export type CustomerNotesAndAttachmentsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerNotesAndAttachmentsCreateWithoutCustomerInput, CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput> | CustomerNotesAndAttachmentsCreateWithoutCustomerInput[] | CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput | CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerNotesAndAttachmentsCreateManyCustomerInputEnvelope
    connect?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    upsert?: UserUpsertWithoutCustomerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerInput, UserUpdateWithoutCustomerInput>, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type CustomerTaxInfoUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<CustomerTaxInfoCreateWithoutCustomerInput, CustomerTaxInfoUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerTaxInfoCreateOrConnectWithoutCustomerInput
    upsert?: CustomerTaxInfoUpsertWithoutCustomerInput
    disconnect?: CustomerTaxInfoWhereInput | boolean
    delete?: CustomerTaxInfoWhereInput | boolean
    connect?: CustomerTaxInfoWhereUniqueInput
    update?: XOR<XOR<CustomerTaxInfoUpdateToOneWithWhereWithoutCustomerInput, CustomerTaxInfoUpdateWithoutCustomerInput>, CustomerTaxInfoUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerContactUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput> | CustomerContactCreateWithoutCustomerInput[] | CustomerContactUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerContactCreateOrConnectWithoutCustomerInput | CustomerContactCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerContactUpsertWithWhereUniqueWithoutCustomerInput | CustomerContactUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerContactCreateManyCustomerInputEnvelope
    set?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    disconnect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    delete?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    connect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    update?: CustomerContactUpdateWithWhereUniqueWithoutCustomerInput | CustomerContactUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerContactUpdateManyWithWhereWithoutCustomerInput | CustomerContactUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerContactScalarWhereInput | CustomerContactScalarWhereInput[]
  }

  export type CustomerOperationalInfoUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<CustomerOperationalInfoCreateWithoutCustomerInput, CustomerOperationalInfoUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerOperationalInfoCreateOrConnectWithoutCustomerInput
    upsert?: CustomerOperationalInfoUpsertWithoutCustomerInput
    disconnect?: CustomerOperationalInfoWhereInput | boolean
    delete?: CustomerOperationalInfoWhereInput | boolean
    connect?: CustomerOperationalInfoWhereUniqueInput
    update?: XOR<XOR<CustomerOperationalInfoUpdateToOneWithWhereWithoutCustomerInput, CustomerOperationalInfoUpdateWithoutCustomerInput>, CustomerOperationalInfoUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerNotesAndAttachmentsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerNotesAndAttachmentsCreateWithoutCustomerInput, CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput> | CustomerNotesAndAttachmentsCreateWithoutCustomerInput[] | CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput | CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerNotesAndAttachmentsUpsertWithWhereUniqueWithoutCustomerInput | CustomerNotesAndAttachmentsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerNotesAndAttachmentsCreateManyCustomerInputEnvelope
    set?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
    disconnect?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
    delete?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
    connect?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
    update?: CustomerNotesAndAttachmentsUpdateWithWhereUniqueWithoutCustomerInput | CustomerNotesAndAttachmentsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerNotesAndAttachmentsUpdateManyWithWhereWithoutCustomerInput | CustomerNotesAndAttachmentsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerNotesAndAttachmentsScalarWhereInput | CustomerNotesAndAttachmentsScalarWhereInput[]
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type CustomerTaxInfoUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<CustomerTaxInfoCreateWithoutCustomerInput, CustomerTaxInfoUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerTaxInfoCreateOrConnectWithoutCustomerInput
    upsert?: CustomerTaxInfoUpsertWithoutCustomerInput
    disconnect?: CustomerTaxInfoWhereInput | boolean
    delete?: CustomerTaxInfoWhereInput | boolean
    connect?: CustomerTaxInfoWhereUniqueInput
    update?: XOR<XOR<CustomerTaxInfoUpdateToOneWithWhereWithoutCustomerInput, CustomerTaxInfoUpdateWithoutCustomerInput>, CustomerTaxInfoUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput> | CustomerContactCreateWithoutCustomerInput[] | CustomerContactUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerContactCreateOrConnectWithoutCustomerInput | CustomerContactCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerContactUpsertWithWhereUniqueWithoutCustomerInput | CustomerContactUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerContactCreateManyCustomerInputEnvelope
    set?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    disconnect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    delete?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    connect?: CustomerContactWhereUniqueInput | CustomerContactWhereUniqueInput[]
    update?: CustomerContactUpdateWithWhereUniqueWithoutCustomerInput | CustomerContactUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerContactUpdateManyWithWhereWithoutCustomerInput | CustomerContactUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerContactScalarWhereInput | CustomerContactScalarWhereInput[]
  }

  export type CustomerOperationalInfoUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<CustomerOperationalInfoCreateWithoutCustomerInput, CustomerOperationalInfoUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerOperationalInfoCreateOrConnectWithoutCustomerInput
    upsert?: CustomerOperationalInfoUpsertWithoutCustomerInput
    disconnect?: CustomerOperationalInfoWhereInput | boolean
    delete?: CustomerOperationalInfoWhereInput | boolean
    connect?: CustomerOperationalInfoWhereUniqueInput
    update?: XOR<XOR<CustomerOperationalInfoUpdateToOneWithWhereWithoutCustomerInput, CustomerOperationalInfoUpdateWithoutCustomerInput>, CustomerOperationalInfoUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerNotesAndAttachmentsCreateWithoutCustomerInput, CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput> | CustomerNotesAndAttachmentsCreateWithoutCustomerInput[] | CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput | CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerNotesAndAttachmentsUpsertWithWhereUniqueWithoutCustomerInput | CustomerNotesAndAttachmentsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerNotesAndAttachmentsCreateManyCustomerInputEnvelope
    set?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
    disconnect?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
    delete?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
    connect?: CustomerNotesAndAttachmentsWhereUniqueInput | CustomerNotesAndAttachmentsWhereUniqueInput[]
    update?: CustomerNotesAndAttachmentsUpdateWithWhereUniqueWithoutCustomerInput | CustomerNotesAndAttachmentsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerNotesAndAttachmentsUpdateManyWithWhereWithoutCustomerInput | CustomerNotesAndAttachmentsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerNotesAndAttachmentsScalarWhereInput | CustomerNotesAndAttachmentsScalarWhereInput[]
  }

  export type companyMaterialCreateNestedManyWithoutServiceInput = {
    create?: XOR<companyMaterialCreateWithoutServiceInput, companyMaterialUncheckedCreateWithoutServiceInput> | companyMaterialCreateWithoutServiceInput[] | companyMaterialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: companyMaterialCreateOrConnectWithoutServiceInput | companyMaterialCreateOrConnectWithoutServiceInput[]
    createMany?: companyMaterialCreateManyServiceInputEnvelope
    connect?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
  }

  export type companyFinishCreateNestedManyWithoutServiceInput = {
    create?: XOR<companyFinishCreateWithoutServiceInput, companyFinishUncheckedCreateWithoutServiceInput> | companyFinishCreateWithoutServiceInput[] | companyFinishUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: companyFinishCreateOrConnectWithoutServiceInput | companyFinishCreateOrConnectWithoutServiceInput[]
    createMany?: companyFinishCreateManyServiceInputEnvelope
    connect?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
  }

  export type companyMaterialUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<companyMaterialCreateWithoutServiceInput, companyMaterialUncheckedCreateWithoutServiceInput> | companyMaterialCreateWithoutServiceInput[] | companyMaterialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: companyMaterialCreateOrConnectWithoutServiceInput | companyMaterialCreateOrConnectWithoutServiceInput[]
    createMany?: companyMaterialCreateManyServiceInputEnvelope
    connect?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
  }

  export type companyFinishUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<companyFinishCreateWithoutServiceInput, companyFinishUncheckedCreateWithoutServiceInput> | companyFinishCreateWithoutServiceInput[] | companyFinishUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: companyFinishCreateOrConnectWithoutServiceInput | companyFinishCreateOrConnectWithoutServiceInput[]
    createMany?: companyFinishCreateManyServiceInputEnvelope
    connect?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
  }

  export type companyMaterialUpdateManyWithoutServiceNestedInput = {
    create?: XOR<companyMaterialCreateWithoutServiceInput, companyMaterialUncheckedCreateWithoutServiceInput> | companyMaterialCreateWithoutServiceInput[] | companyMaterialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: companyMaterialCreateOrConnectWithoutServiceInput | companyMaterialCreateOrConnectWithoutServiceInput[]
    upsert?: companyMaterialUpsertWithWhereUniqueWithoutServiceInput | companyMaterialUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: companyMaterialCreateManyServiceInputEnvelope
    set?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
    disconnect?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
    delete?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
    connect?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
    update?: companyMaterialUpdateWithWhereUniqueWithoutServiceInput | companyMaterialUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: companyMaterialUpdateManyWithWhereWithoutServiceInput | companyMaterialUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: companyMaterialScalarWhereInput | companyMaterialScalarWhereInput[]
  }

  export type companyFinishUpdateManyWithoutServiceNestedInput = {
    create?: XOR<companyFinishCreateWithoutServiceInput, companyFinishUncheckedCreateWithoutServiceInput> | companyFinishCreateWithoutServiceInput[] | companyFinishUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: companyFinishCreateOrConnectWithoutServiceInput | companyFinishCreateOrConnectWithoutServiceInput[]
    upsert?: companyFinishUpsertWithWhereUniqueWithoutServiceInput | companyFinishUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: companyFinishCreateManyServiceInputEnvelope
    set?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
    disconnect?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
    delete?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
    connect?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
    update?: companyFinishUpdateWithWhereUniqueWithoutServiceInput | companyFinishUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: companyFinishUpdateManyWithWhereWithoutServiceInput | companyFinishUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: companyFinishScalarWhereInput | companyFinishScalarWhereInput[]
  }

  export type companyMaterialUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<companyMaterialCreateWithoutServiceInput, companyMaterialUncheckedCreateWithoutServiceInput> | companyMaterialCreateWithoutServiceInput[] | companyMaterialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: companyMaterialCreateOrConnectWithoutServiceInput | companyMaterialCreateOrConnectWithoutServiceInput[]
    upsert?: companyMaterialUpsertWithWhereUniqueWithoutServiceInput | companyMaterialUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: companyMaterialCreateManyServiceInputEnvelope
    set?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
    disconnect?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
    delete?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
    connect?: companyMaterialWhereUniqueInput | companyMaterialWhereUniqueInput[]
    update?: companyMaterialUpdateWithWhereUniqueWithoutServiceInput | companyMaterialUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: companyMaterialUpdateManyWithWhereWithoutServiceInput | companyMaterialUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: companyMaterialScalarWhereInput | companyMaterialScalarWhereInput[]
  }

  export type companyFinishUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<companyFinishCreateWithoutServiceInput, companyFinishUncheckedCreateWithoutServiceInput> | companyFinishCreateWithoutServiceInput[] | companyFinishUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: companyFinishCreateOrConnectWithoutServiceInput | companyFinishCreateOrConnectWithoutServiceInput[]
    upsert?: companyFinishUpsertWithWhereUniqueWithoutServiceInput | companyFinishUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: companyFinishCreateManyServiceInputEnvelope
    set?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
    disconnect?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
    delete?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
    connect?: companyFinishWhereUniqueInput | companyFinishWhereUniqueInput[]
    update?: companyFinishUpdateWithWhereUniqueWithoutServiceInput | companyFinishUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: companyFinishUpdateManyWithWhereWithoutServiceInput | companyFinishUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: companyFinishScalarWhereInput | companyFinishScalarWhereInput[]
  }

  export type companyServiceCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<companyServiceCreateWithoutMaterialsInput, companyServiceUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: companyServiceCreateOrConnectWithoutMaterialsInput
    connect?: companyServiceWhereUniqueInput
  }

  export type companyServiceUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<companyServiceCreateWithoutMaterialsInput, companyServiceUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: companyServiceCreateOrConnectWithoutMaterialsInput
    upsert?: companyServiceUpsertWithoutMaterialsInput
    connect?: companyServiceWhereUniqueInput
    update?: XOR<XOR<companyServiceUpdateToOneWithWhereWithoutMaterialsInput, companyServiceUpdateWithoutMaterialsInput>, companyServiceUncheckedUpdateWithoutMaterialsInput>
  }

  export type companyServiceCreateNestedOneWithoutFinishesInput = {
    create?: XOR<companyServiceCreateWithoutFinishesInput, companyServiceUncheckedCreateWithoutFinishesInput>
    connectOrCreate?: companyServiceCreateOrConnectWithoutFinishesInput
    connect?: companyServiceWhereUniqueInput
  }

  export type companyServiceUpdateOneRequiredWithoutFinishesNestedInput = {
    create?: XOR<companyServiceCreateWithoutFinishesInput, companyServiceUncheckedCreateWithoutFinishesInput>
    connectOrCreate?: companyServiceCreateOrConnectWithoutFinishesInput
    upsert?: companyServiceUpsertWithoutFinishesInput
    connect?: companyServiceWhereUniqueInput
    update?: XOR<XOR<companyServiceUpdateToOneWithWhereWithoutFinishesInput, companyServiceUpdateWithoutFinishesInput>, companyServiceUncheckedUpdateWithoutFinishesInput>
  }

  export type CustomerCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    upsert?: CustomerUpsertWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAddressesInput, CustomerUpdateWithoutAddressesInput>, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type CustomerCreateNestedOneWithoutTax_infoInput = {
    create?: XOR<CustomerCreateWithoutTax_infoInput, CustomerUncheckedCreateWithoutTax_infoInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTax_infoInput
    connect?: CustomerWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutTax_infoNestedInput = {
    create?: XOR<CustomerCreateWithoutTax_infoInput, CustomerUncheckedCreateWithoutTax_infoInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTax_infoInput
    upsert?: CustomerUpsertWithoutTax_infoInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTax_infoInput, CustomerUpdateWithoutTax_infoInput>, CustomerUncheckedUpdateWithoutTax_infoInput>
  }

  export type CustomerCreateNestedOneWithoutContactsInput = {
    create?: XOR<CustomerCreateWithoutContactsInput, CustomerUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutContactsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<CustomerCreateWithoutContactsInput, CustomerUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutContactsInput
    upsert?: CustomerUpsertWithoutContactsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutContactsInput, CustomerUpdateWithoutContactsInput>, CustomerUncheckedUpdateWithoutContactsInput>
  }

  export type CustomerCreateNestedOneWithoutOperationalInput = {
    create?: XOR<CustomerCreateWithoutOperationalInput, CustomerUncheckedCreateWithoutOperationalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOperationalInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutOperationalNestedInput = {
    create?: XOR<CustomerCreateWithoutOperationalInput, CustomerUncheckedCreateWithoutOperationalInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOperationalInput
    upsert?: CustomerUpsertWithoutOperationalInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOperationalInput, CustomerUpdateWithoutOperationalInput>, CustomerUncheckedUpdateWithoutOperationalInput>
  }

  export type CustomerNotesAndAttachmentsCreatetagsInput = {
    set: string[]
  }

  export type CustomerCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<CustomerCreateWithoutAttachmentsInput, CustomerUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAttachmentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerNotesAndAttachmentsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomerUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<CustomerCreateWithoutAttachmentsInput, CustomerUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAttachmentsInput
    upsert?: CustomerUpsertWithoutAttachmentsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAttachmentsInput, CustomerUpdateWithoutAttachmentsInput>, CustomerUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutVendorInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput
    connect?: UserWhereUniqueInput
  }

  export type VendorContactCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorContactCreateWithoutVendorInput, VendorContactUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorContactCreateOrConnectWithoutVendorInput
    connect?: VendorContactWhereUniqueInput
  }

  export type VendorAddressCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorAddressCreateWithoutVendorInput, VendorAddressUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorAddressCreateOrConnectWithoutVendorInput
    connect?: VendorAddressWhereUniqueInput
  }

  export type VendorTaxComplianceCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorTaxComplianceCreateWithoutVendorInput, VendorTaxComplianceUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorTaxComplianceCreateOrConnectWithoutVendorInput
    connect?: VendorTaxComplianceWhereUniqueInput
  }

  export type VendorFinancialCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorFinancialCreateWithoutVendorInput, VendorFinancialUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorFinancialCreateOrConnectWithoutVendorInput
    connect?: VendorFinancialWhereUniqueInput
  }

  export type VendorOperationalSettingCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorOperationalSettingCreateWithoutVendorInput, VendorOperationalSettingUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorOperationalSettingCreateOrConnectWithoutVendorInput
    connect?: VendorOperationalSettingWhereUniqueInput
  }

  export type VendorMetadataCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorMetadataCreateWithoutVendorInput, VendorMetadataUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorMetadataCreateOrConnectWithoutVendorInput
    connect?: VendorMetadataWhereUniqueInput
  }

  export type VendorContactUncheckedCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorContactCreateWithoutVendorInput, VendorContactUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorContactCreateOrConnectWithoutVendorInput
    connect?: VendorContactWhereUniqueInput
  }

  export type VendorAddressUncheckedCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorAddressCreateWithoutVendorInput, VendorAddressUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorAddressCreateOrConnectWithoutVendorInput
    connect?: VendorAddressWhereUniqueInput
  }

  export type VendorTaxComplianceUncheckedCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorTaxComplianceCreateWithoutVendorInput, VendorTaxComplianceUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorTaxComplianceCreateOrConnectWithoutVendorInput
    connect?: VendorTaxComplianceWhereUniqueInput
  }

  export type VendorFinancialUncheckedCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorFinancialCreateWithoutVendorInput, VendorFinancialUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorFinancialCreateOrConnectWithoutVendorInput
    connect?: VendorFinancialWhereUniqueInput
  }

  export type VendorOperationalSettingUncheckedCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorOperationalSettingCreateWithoutVendorInput, VendorOperationalSettingUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorOperationalSettingCreateOrConnectWithoutVendorInput
    connect?: VendorOperationalSettingWhereUniqueInput
  }

  export type VendorMetadataUncheckedCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorMetadataCreateWithoutVendorInput, VendorMetadataUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorMetadataCreateOrConnectWithoutVendorInput
    connect?: VendorMetadataWhereUniqueInput
  }

  export type UserUpdateOneWithoutVendorNestedInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput
    upsert?: UserUpsertWithoutVendorInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorInput, UserUpdateWithoutVendorInput>, UserUncheckedUpdateWithoutVendorInput>
  }

  export type VendorContactUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorContactCreateWithoutVendorInput, VendorContactUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorContactCreateOrConnectWithoutVendorInput
    upsert?: VendorContactUpsertWithoutVendorInput
    disconnect?: VendorContactWhereInput | boolean
    delete?: VendorContactWhereInput | boolean
    connect?: VendorContactWhereUniqueInput
    update?: XOR<XOR<VendorContactUpdateToOneWithWhereWithoutVendorInput, VendorContactUpdateWithoutVendorInput>, VendorContactUncheckedUpdateWithoutVendorInput>
  }

  export type VendorAddressUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorAddressCreateWithoutVendorInput, VendorAddressUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorAddressCreateOrConnectWithoutVendorInput
    upsert?: VendorAddressUpsertWithoutVendorInput
    disconnect?: VendorAddressWhereInput | boolean
    delete?: VendorAddressWhereInput | boolean
    connect?: VendorAddressWhereUniqueInput
    update?: XOR<XOR<VendorAddressUpdateToOneWithWhereWithoutVendorInput, VendorAddressUpdateWithoutVendorInput>, VendorAddressUncheckedUpdateWithoutVendorInput>
  }

  export type VendorTaxComplianceUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorTaxComplianceCreateWithoutVendorInput, VendorTaxComplianceUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorTaxComplianceCreateOrConnectWithoutVendorInput
    upsert?: VendorTaxComplianceUpsertWithoutVendorInput
    disconnect?: VendorTaxComplianceWhereInput | boolean
    delete?: VendorTaxComplianceWhereInput | boolean
    connect?: VendorTaxComplianceWhereUniqueInput
    update?: XOR<XOR<VendorTaxComplianceUpdateToOneWithWhereWithoutVendorInput, VendorTaxComplianceUpdateWithoutVendorInput>, VendorTaxComplianceUncheckedUpdateWithoutVendorInput>
  }

  export type VendorFinancialUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorFinancialCreateWithoutVendorInput, VendorFinancialUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorFinancialCreateOrConnectWithoutVendorInput
    upsert?: VendorFinancialUpsertWithoutVendorInput
    disconnect?: VendorFinancialWhereInput | boolean
    delete?: VendorFinancialWhereInput | boolean
    connect?: VendorFinancialWhereUniqueInput
    update?: XOR<XOR<VendorFinancialUpdateToOneWithWhereWithoutVendorInput, VendorFinancialUpdateWithoutVendorInput>, VendorFinancialUncheckedUpdateWithoutVendorInput>
  }

  export type VendorOperationalSettingUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorOperationalSettingCreateWithoutVendorInput, VendorOperationalSettingUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorOperationalSettingCreateOrConnectWithoutVendorInput
    upsert?: VendorOperationalSettingUpsertWithoutVendorInput
    disconnect?: VendorOperationalSettingWhereInput | boolean
    delete?: VendorOperationalSettingWhereInput | boolean
    connect?: VendorOperationalSettingWhereUniqueInput
    update?: XOR<XOR<VendorOperationalSettingUpdateToOneWithWhereWithoutVendorInput, VendorOperationalSettingUpdateWithoutVendorInput>, VendorOperationalSettingUncheckedUpdateWithoutVendorInput>
  }

  export type VendorMetadataUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorMetadataCreateWithoutVendorInput, VendorMetadataUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorMetadataCreateOrConnectWithoutVendorInput
    upsert?: VendorMetadataUpsertWithoutVendorInput
    disconnect?: VendorMetadataWhereInput | boolean
    delete?: VendorMetadataWhereInput | boolean
    connect?: VendorMetadataWhereUniqueInput
    update?: XOR<XOR<VendorMetadataUpdateToOneWithWhereWithoutVendorInput, VendorMetadataUpdateWithoutVendorInput>, VendorMetadataUncheckedUpdateWithoutVendorInput>
  }

  export type VendorContactUncheckedUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorContactCreateWithoutVendorInput, VendorContactUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorContactCreateOrConnectWithoutVendorInput
    upsert?: VendorContactUpsertWithoutVendorInput
    disconnect?: VendorContactWhereInput | boolean
    delete?: VendorContactWhereInput | boolean
    connect?: VendorContactWhereUniqueInput
    update?: XOR<XOR<VendorContactUpdateToOneWithWhereWithoutVendorInput, VendorContactUpdateWithoutVendorInput>, VendorContactUncheckedUpdateWithoutVendorInput>
  }

  export type VendorAddressUncheckedUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorAddressCreateWithoutVendorInput, VendorAddressUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorAddressCreateOrConnectWithoutVendorInput
    upsert?: VendorAddressUpsertWithoutVendorInput
    disconnect?: VendorAddressWhereInput | boolean
    delete?: VendorAddressWhereInput | boolean
    connect?: VendorAddressWhereUniqueInput
    update?: XOR<XOR<VendorAddressUpdateToOneWithWhereWithoutVendorInput, VendorAddressUpdateWithoutVendorInput>, VendorAddressUncheckedUpdateWithoutVendorInput>
  }

  export type VendorTaxComplianceUncheckedUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorTaxComplianceCreateWithoutVendorInput, VendorTaxComplianceUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorTaxComplianceCreateOrConnectWithoutVendorInput
    upsert?: VendorTaxComplianceUpsertWithoutVendorInput
    disconnect?: VendorTaxComplianceWhereInput | boolean
    delete?: VendorTaxComplianceWhereInput | boolean
    connect?: VendorTaxComplianceWhereUniqueInput
    update?: XOR<XOR<VendorTaxComplianceUpdateToOneWithWhereWithoutVendorInput, VendorTaxComplianceUpdateWithoutVendorInput>, VendorTaxComplianceUncheckedUpdateWithoutVendorInput>
  }

  export type VendorFinancialUncheckedUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorFinancialCreateWithoutVendorInput, VendorFinancialUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorFinancialCreateOrConnectWithoutVendorInput
    upsert?: VendorFinancialUpsertWithoutVendorInput
    disconnect?: VendorFinancialWhereInput | boolean
    delete?: VendorFinancialWhereInput | boolean
    connect?: VendorFinancialWhereUniqueInput
    update?: XOR<XOR<VendorFinancialUpdateToOneWithWhereWithoutVendorInput, VendorFinancialUpdateWithoutVendorInput>, VendorFinancialUncheckedUpdateWithoutVendorInput>
  }

  export type VendorOperationalSettingUncheckedUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorOperationalSettingCreateWithoutVendorInput, VendorOperationalSettingUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorOperationalSettingCreateOrConnectWithoutVendorInput
    upsert?: VendorOperationalSettingUpsertWithoutVendorInput
    disconnect?: VendorOperationalSettingWhereInput | boolean
    delete?: VendorOperationalSettingWhereInput | boolean
    connect?: VendorOperationalSettingWhereUniqueInput
    update?: XOR<XOR<VendorOperationalSettingUpdateToOneWithWhereWithoutVendorInput, VendorOperationalSettingUpdateWithoutVendorInput>, VendorOperationalSettingUncheckedUpdateWithoutVendorInput>
  }

  export type VendorMetadataUncheckedUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorMetadataCreateWithoutVendorInput, VendorMetadataUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorMetadataCreateOrConnectWithoutVendorInput
    upsert?: VendorMetadataUpsertWithoutVendorInput
    disconnect?: VendorMetadataWhereInput | boolean
    delete?: VendorMetadataWhereInput | boolean
    connect?: VendorMetadataWhereUniqueInput
    update?: XOR<XOR<VendorMetadataUpdateToOneWithWhereWithoutVendorInput, VendorMetadataUpdateWithoutVendorInput>, VendorMetadataUncheckedUpdateWithoutVendorInput>
  }

  export type VendorCreateNestedOneWithoutContactsInput = {
    create?: XOR<VendorCreateWithoutContactsInput, VendorUncheckedCreateWithoutContactsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutContactsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<VendorCreateWithoutContactsInput, VendorUncheckedCreateWithoutContactsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutContactsInput
    upsert?: VendorUpsertWithoutContactsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutContactsInput, VendorUpdateWithoutContactsInput>, VendorUncheckedUpdateWithoutContactsInput>
  }

  export type VendorCreateNestedOneWithoutAddressesInput = {
    create?: XOR<VendorCreateWithoutAddressesInput, VendorUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAddressesInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<VendorCreateWithoutAddressesInput, VendorUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAddressesInput
    upsert?: VendorUpsertWithoutAddressesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutAddressesInput, VendorUpdateWithoutAddressesInput>, VendorUncheckedUpdateWithoutAddressesInput>
  }

  export type VendorCreateNestedOneWithoutTaxCompliancesInput = {
    create?: XOR<VendorCreateWithoutTaxCompliancesInput, VendorUncheckedCreateWithoutTaxCompliancesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutTaxCompliancesInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutTaxCompliancesNestedInput = {
    create?: XOR<VendorCreateWithoutTaxCompliancesInput, VendorUncheckedCreateWithoutTaxCompliancesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutTaxCompliancesInput
    upsert?: VendorUpsertWithoutTaxCompliancesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutTaxCompliancesInput, VendorUpdateWithoutTaxCompliancesInput>, VendorUncheckedUpdateWithoutTaxCompliancesInput>
  }

  export type VendorCreateNestedOneWithoutFinancialsInput = {
    create?: XOR<VendorCreateWithoutFinancialsInput, VendorUncheckedCreateWithoutFinancialsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutFinancialsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutFinancialsNestedInput = {
    create?: XOR<VendorCreateWithoutFinancialsInput, VendorUncheckedCreateWithoutFinancialsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutFinancialsInput
    upsert?: VendorUpsertWithoutFinancialsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutFinancialsInput, VendorUpdateWithoutFinancialsInput>, VendorUncheckedUpdateWithoutFinancialsInput>
  }

  export type VendorOperationalSettingCreatecategoriesInput = {
    set: string[]
  }

  export type VendorCreateNestedOneWithoutOperationalSettingInput = {
    create?: XOR<VendorCreateWithoutOperationalSettingInput, VendorUncheckedCreateWithoutOperationalSettingInput>
    connectOrCreate?: VendorCreateOrConnectWithoutOperationalSettingInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorOperationalSettingUpdatecategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VendorUpdateOneRequiredWithoutOperationalSettingNestedInput = {
    create?: XOR<VendorCreateWithoutOperationalSettingInput, VendorUncheckedCreateWithoutOperationalSettingInput>
    connectOrCreate?: VendorCreateOrConnectWithoutOperationalSettingInput
    upsert?: VendorUpsertWithoutOperationalSettingInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutOperationalSettingInput, VendorUpdateWithoutOperationalSettingInput>, VendorUncheckedUpdateWithoutOperationalSettingInput>
  }

  export type VendorMetadataCreatetagsInput = {
    set: string[]
  }

  export type VendorCreateNestedOneWithoutMetadataInput = {
    create?: XOR<VendorCreateWithoutMetadataInput, VendorUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: VendorCreateOrConnectWithoutMetadataInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorMetadataUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VendorUpdateOneRequiredWithoutMetadataNestedInput = {
    create?: XOR<VendorCreateWithoutMetadataInput, VendorUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: VendorCreateOrConnectWithoutMetadataInput
    upsert?: VendorUpsertWithoutMetadataInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutMetadataInput, VendorUpdateWithoutMetadataInput>, VendorUncheckedUpdateWithoutMetadataInput>
  }

  export type company_vendor_capability_sub_categoriesCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput, company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput> | company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput[] | company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput | company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput[]
    createMany?: company_vendor_capability_sub_categoriesCreateManyCapabilityInputEnvelope
    connect?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
  }

  export type company_vendor_capability_sub_categoriesUncheckedCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput, company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput> | company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput[] | company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput | company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput[]
    createMany?: company_vendor_capability_sub_categoriesCreateManyCapabilityInputEnvelope
    connect?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
  }

  export type company_vendor_capability_sub_categoriesUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput, company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput> | company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput[] | company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput | company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput[]
    upsert?: company_vendor_capability_sub_categoriesUpsertWithWhereUniqueWithoutCapabilityInput | company_vendor_capability_sub_categoriesUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: company_vendor_capability_sub_categoriesCreateManyCapabilityInputEnvelope
    set?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
    disconnect?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
    delete?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
    connect?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
    update?: company_vendor_capability_sub_categoriesUpdateWithWhereUniqueWithoutCapabilityInput | company_vendor_capability_sub_categoriesUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: company_vendor_capability_sub_categoriesUpdateManyWithWhereWithoutCapabilityInput | company_vendor_capability_sub_categoriesUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: company_vendor_capability_sub_categoriesScalarWhereInput | company_vendor_capability_sub_categoriesScalarWhereInput[]
  }

  export type company_vendor_capability_sub_categoriesUncheckedUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput, company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput> | company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput[] | company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput | company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput[]
    upsert?: company_vendor_capability_sub_categoriesUpsertWithWhereUniqueWithoutCapabilityInput | company_vendor_capability_sub_categoriesUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: company_vendor_capability_sub_categoriesCreateManyCapabilityInputEnvelope
    set?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
    disconnect?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
    delete?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
    connect?: company_vendor_capability_sub_categoriesWhereUniqueInput | company_vendor_capability_sub_categoriesWhereUniqueInput[]
    update?: company_vendor_capability_sub_categoriesUpdateWithWhereUniqueWithoutCapabilityInput | company_vendor_capability_sub_categoriesUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: company_vendor_capability_sub_categoriesUpdateManyWithWhereWithoutCapabilityInput | company_vendor_capability_sub_categoriesUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: company_vendor_capability_sub_categoriesScalarWhereInput | company_vendor_capability_sub_categoriesScalarWhereInput[]
  }

  export type company_vendor_capabilitiesCreateNestedOneWithoutSubCategoriesInput = {
    create?: XOR<company_vendor_capabilitiesCreateWithoutSubCategoriesInput, company_vendor_capabilitiesUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: company_vendor_capabilitiesCreateOrConnectWithoutSubCategoriesInput
    connect?: company_vendor_capabilitiesWhereUniqueInput
  }

  export type company_vendor_capabilitiesUpdateOneRequiredWithoutSubCategoriesNestedInput = {
    create?: XOR<company_vendor_capabilitiesCreateWithoutSubCategoriesInput, company_vendor_capabilitiesUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: company_vendor_capabilitiesCreateOrConnectWithoutSubCategoriesInput
    upsert?: company_vendor_capabilitiesUpsertWithoutSubCategoriesInput
    connect?: company_vendor_capabilitiesWhereUniqueInput
    update?: XOR<XOR<company_vendor_capabilitiesUpdateToOneWithWhereWithoutSubCategoriesInput, company_vendor_capabilitiesUpdateWithoutSubCategoriesInput>, company_vendor_capabilitiesUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumQuoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteType | EnumQuoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteType[] | ListEnumQuoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteType[] | ListEnumQuoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteTypeFilter<$PrismaModel> | $Enums.QuoteType
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumQuoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteType | EnumQuoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteType[] | ListEnumQuoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteType[] | ListEnumQuoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteTypeFilter<$PrismaModel>
    _max?: NestedEnumQuoteTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CustomerCreateWithoutUserInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutUserInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoUncheckedCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoUncheckedCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutUserInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
  }

  export type VendorCreateWithoutUserInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    contacts?: VendorContactCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutUserInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    contacts?: VendorContactUncheckedCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressUncheckedCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceUncheckedCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialUncheckedCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingUncheckedCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutUserInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetOTPCreateWithoutUserInput = {
    id?: string
    email: string
    otp: string
    request_id: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type PasswordResetOTPUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    otp: string
    request_id: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type PasswordResetOTPCreateOrConnectWithoutUserInput = {
    where: PasswordResetOTPWhereUniqueInput
    create: XOR<PasswordResetOTPCreateWithoutUserInput, PasswordResetOTPUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetOTPCreateManyUserInputEnvelope = {
    data: PasswordResetOTPCreateManyUserInput | PasswordResetOTPCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutUserInput = {
    id?: string
    quote_item_id?: number
    status?: string | null
    payment_status?: string | null
    quote_type?: $Enums.QuoteType
    tax?: string | null
    deposit_paid?: string | null
    shipping?: string | null
    tax_buy_price?: string | null
    shipping_buy_price?: string | null
    lead_time?: string | null
    payable?: string | null
    freight_condition?: string | null
    freight_condition_dismiss?: boolean | null
    customer_email?: string | null
    emails?: string | null
    invoice_date?: Date | string | null
    invoice_email?: string | null
    billing_name?: string | null
    billing_company?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_country?: string | null
    billing_zip?: string | null
    billing_phone?: string | null
    billing_fax?: string | null
    shipping_name?: string | null
    shipping_company?: string | null
    shipping_address?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_country?: string | null
    shipping_zip?: string | null
    shipping_phone?: string | null
    shipping_email?: string | null
    shipping_fax?: string | null
    sales_person?: number | null
    project_manager?: number | null
    accept_agreement?: number | null
    date_created?: Date | string | null
    created_month?: string | null
    created_year?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    QuoteItems?: QuoteItemCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutUserInput = {
    id?: string
    quote_item_id?: number
    status?: string | null
    payment_status?: string | null
    quote_type?: $Enums.QuoteType
    tax?: string | null
    deposit_paid?: string | null
    shipping?: string | null
    tax_buy_price?: string | null
    shipping_buy_price?: string | null
    lead_time?: string | null
    payable?: string | null
    freight_condition?: string | null
    freight_condition_dismiss?: boolean | null
    customer_email?: string | null
    emails?: string | null
    invoice_date?: Date | string | null
    invoice_email?: string | null
    billing_name?: string | null
    billing_company?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_country?: string | null
    billing_zip?: string | null
    billing_phone?: string | null
    billing_fax?: string | null
    shipping_name?: string | null
    shipping_company?: string | null
    shipping_address?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_country?: string | null
    shipping_zip?: string | null
    shipping_phone?: string | null
    shipping_email?: string | null
    shipping_fax?: string | null
    sales_person?: number | null
    project_manager?: number | null
    accept_agreement?: number | null
    date_created?: Date | string | null
    created_month?: string | null
    created_year?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    QuoteItems?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutUserInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutUserInput, QuoteUncheckedCreateWithoutUserInput>
  }

  export type QuoteCreateManyUserInputEnvelope = {
    data: QuoteCreateManyUserInput | QuoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutUserInput = {
    update: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutUserInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type CustomerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUncheckedUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUncheckedUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type VendorUpsertWithoutUserInput = {
    update: XOR<VendorUpdateWithoutUserInput, VendorUncheckedUpdateWithoutUserInput>
    create: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutUserInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutUserInput, VendorUncheckedUpdateWithoutUserInput>
  }

  export type VendorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: VendorContactUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: VendorContactUncheckedUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUncheckedUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUncheckedUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUncheckedUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUncheckedUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type PasswordResetOTPUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetOTPWhereUniqueInput
    update: XOR<PasswordResetOTPUpdateWithoutUserInput, PasswordResetOTPUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetOTPCreateWithoutUserInput, PasswordResetOTPUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetOTPUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetOTPWhereUniqueInput
    data: XOR<PasswordResetOTPUpdateWithoutUserInput, PasswordResetOTPUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetOTPUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetOTPScalarWhereInput
    data: XOR<PasswordResetOTPUpdateManyMutationInput, PasswordResetOTPUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetOTPScalarWhereInput = {
    AND?: PasswordResetOTPScalarWhereInput | PasswordResetOTPScalarWhereInput[]
    OR?: PasswordResetOTPScalarWhereInput[]
    NOT?: PasswordResetOTPScalarWhereInput | PasswordResetOTPScalarWhereInput[]
    id?: StringFilter<"PasswordResetOTP"> | string
    email?: StringFilter<"PasswordResetOTP"> | string
    otp?: StringFilter<"PasswordResetOTP"> | string
    request_id?: StringFilter<"PasswordResetOTP"> | string
    expires_at?: DateTimeFilter<"PasswordResetOTP"> | Date | string
    created_at?: DateTimeFilter<"PasswordResetOTP"> | Date | string
    user_id?: StringFilter<"PasswordResetOTP"> | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    user_id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires_at?: DateTimeFilter<"PasswordResetToken"> | Date | string
    created_at?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type QuoteUpsertWithWhereUniqueWithoutUserInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutUserInput, QuoteUncheckedUpdateWithoutUserInput>
    create: XOR<QuoteCreateWithoutUserInput, QuoteUncheckedCreateWithoutUserInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutUserInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutUserInput, QuoteUncheckedUpdateWithoutUserInput>
  }

  export type QuoteUpdateManyWithWhereWithoutUserInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutUserInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: StringFilter<"Quote"> | string
    user_id?: StringFilter<"Quote"> | string
    quote_item_id?: IntFilter<"Quote"> | number
    status?: StringNullableFilter<"Quote"> | string | null
    payment_status?: StringNullableFilter<"Quote"> | string | null
    quote_type?: EnumQuoteTypeFilter<"Quote"> | $Enums.QuoteType
    tax?: StringNullableFilter<"Quote"> | string | null
    deposit_paid?: StringNullableFilter<"Quote"> | string | null
    shipping?: StringNullableFilter<"Quote"> | string | null
    tax_buy_price?: StringNullableFilter<"Quote"> | string | null
    shipping_buy_price?: StringNullableFilter<"Quote"> | string | null
    lead_time?: StringNullableFilter<"Quote"> | string | null
    payable?: StringNullableFilter<"Quote"> | string | null
    freight_condition?: StringNullableFilter<"Quote"> | string | null
    freight_condition_dismiss?: BoolNullableFilter<"Quote"> | boolean | null
    customer_email?: StringNullableFilter<"Quote"> | string | null
    emails?: StringNullableFilter<"Quote"> | string | null
    invoice_date?: DateTimeNullableFilter<"Quote"> | Date | string | null
    invoice_email?: StringNullableFilter<"Quote"> | string | null
    billing_name?: StringNullableFilter<"Quote"> | string | null
    billing_company?: StringNullableFilter<"Quote"> | string | null
    billing_address?: StringNullableFilter<"Quote"> | string | null
    billing_city?: StringNullableFilter<"Quote"> | string | null
    billing_state?: StringNullableFilter<"Quote"> | string | null
    billing_country?: StringNullableFilter<"Quote"> | string | null
    billing_zip?: StringNullableFilter<"Quote"> | string | null
    billing_phone?: StringNullableFilter<"Quote"> | string | null
    billing_fax?: StringNullableFilter<"Quote"> | string | null
    shipping_name?: StringNullableFilter<"Quote"> | string | null
    shipping_company?: StringNullableFilter<"Quote"> | string | null
    shipping_address?: StringNullableFilter<"Quote"> | string | null
    shipping_city?: StringNullableFilter<"Quote"> | string | null
    shipping_state?: StringNullableFilter<"Quote"> | string | null
    shipping_country?: StringNullableFilter<"Quote"> | string | null
    shipping_zip?: StringNullableFilter<"Quote"> | string | null
    shipping_phone?: StringNullableFilter<"Quote"> | string | null
    shipping_email?: StringNullableFilter<"Quote"> | string | null
    shipping_fax?: StringNullableFilter<"Quote"> | string | null
    sales_person?: IntNullableFilter<"Quote"> | number | null
    project_manager?: IntNullableFilter<"Quote"> | number | null
    accept_agreement?: IntNullableFilter<"Quote"> | number | null
    date_created?: DateTimeNullableFilter<"Quote"> | Date | string | null
    created_month?: StringNullableFilter<"Quote"> | string | null
    created_year?: StringNullableFilter<"Quote"> | string | null
    created_at?: DateTimeFilter<"Quote"> | Date | string
    updated_at?: DateTimeFilter<"Quote"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Quote"> | Date | string | null
    is_deleted?: BoolNullableFilter<"Quote"> | boolean | null
  }

  export type UserCreateWithoutQuotesInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerCreateNestedOneWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuotesInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuotesInput, UserUncheckedCreateWithoutQuotesInput>
  }

  export type QuoteItemCreateWithoutQuoteInput = {
    id?: string
    file_name?: string | null
    file_url?: string | null
    status?: boolean
    quantity?: number
    service?: string | null
    material?: string | null
    finish?: string | null
    description?: string | null
    process?: string | null
    specification?: string | null
    price?: string | null
    cost?: string | null
    cost_shipping_price?: string | null
    cost_shipping_total?: string | null
    custom_shipping_total?: string | null
    buy_price?: string | null
    buy_shipping_price?: string | null
    buy_shipping_total?: string | null
    quantity_owed?: string | null
    invoiced?: boolean | null
    non_taxable?: number | null
    non_shipping?: number | null
    is_deleted?: boolean | null
    vendor_id?: string | null
    vendor_details?: string | null
    last_updated_by?: number | null
    work_instructions?: string | null
    add_vendor?: boolean | null
    markings?: string | null
    part_item_number?: string | null
    file_year?: string | null
    file_month?: string | null
    tab_open?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuoteItemUncheckedCreateWithoutQuoteInput = {
    id?: string
    file_name?: string | null
    file_url?: string | null
    status?: boolean
    quantity?: number
    service?: string | null
    material?: string | null
    finish?: string | null
    description?: string | null
    process?: string | null
    specification?: string | null
    price?: string | null
    cost?: string | null
    cost_shipping_price?: string | null
    cost_shipping_total?: string | null
    custom_shipping_total?: string | null
    buy_price?: string | null
    buy_shipping_price?: string | null
    buy_shipping_total?: string | null
    quantity_owed?: string | null
    invoiced?: boolean | null
    non_taxable?: number | null
    non_shipping?: number | null
    is_deleted?: boolean | null
    vendor_id?: string | null
    vendor_details?: string | null
    last_updated_by?: number | null
    work_instructions?: string | null
    add_vendor?: boolean | null
    markings?: string | null
    part_item_number?: string | null
    file_year?: string | null
    file_month?: string | null
    tab_open?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuoteItemCreateOrConnectWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    create: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteItemCreateManyQuoteInputEnvelope = {
    data: QuoteItemCreateManyQuoteInput | QuoteItemCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuotesInput = {
    update: XOR<UserUpdateWithoutQuotesInput, UserUncheckedUpdateWithoutQuotesInput>
    create: XOR<UserCreateWithoutQuotesInput, UserUncheckedCreateWithoutQuotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuotesInput, UserUncheckedUpdateWithoutQuotesInput>
  }

  export type UserUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuoteItemUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    update: XOR<QuoteItemUpdateWithoutQuoteInput, QuoteItemUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteItemUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    data: XOR<QuoteItemUpdateWithoutQuoteInput, QuoteItemUncheckedUpdateWithoutQuoteInput>
  }

  export type QuoteItemUpdateManyWithWhereWithoutQuoteInput = {
    where: QuoteItemScalarWhereInput
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuoteItemScalarWhereInput = {
    AND?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
    OR?: QuoteItemScalarWhereInput[]
    NOT?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
    id?: StringFilter<"QuoteItem"> | string
    quote_id?: StringFilter<"QuoteItem"> | string
    file_name?: StringNullableFilter<"QuoteItem"> | string | null
    file_url?: StringNullableFilter<"QuoteItem"> | string | null
    status?: BoolFilter<"QuoteItem"> | boolean
    quantity?: IntFilter<"QuoteItem"> | number
    service?: StringNullableFilter<"QuoteItem"> | string | null
    material?: StringNullableFilter<"QuoteItem"> | string | null
    finish?: StringNullableFilter<"QuoteItem"> | string | null
    description?: StringNullableFilter<"QuoteItem"> | string | null
    process?: StringNullableFilter<"QuoteItem"> | string | null
    specification?: StringNullableFilter<"QuoteItem"> | string | null
    price?: StringNullableFilter<"QuoteItem"> | string | null
    cost?: StringNullableFilter<"QuoteItem"> | string | null
    cost_shipping_price?: StringNullableFilter<"QuoteItem"> | string | null
    cost_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    custom_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    buy_price?: StringNullableFilter<"QuoteItem"> | string | null
    buy_shipping_price?: StringNullableFilter<"QuoteItem"> | string | null
    buy_shipping_total?: StringNullableFilter<"QuoteItem"> | string | null
    quantity_owed?: StringNullableFilter<"QuoteItem"> | string | null
    invoiced?: BoolNullableFilter<"QuoteItem"> | boolean | null
    non_taxable?: IntNullableFilter<"QuoteItem"> | number | null
    non_shipping?: IntNullableFilter<"QuoteItem"> | number | null
    is_deleted?: BoolNullableFilter<"QuoteItem"> | boolean | null
    vendor_id?: StringNullableFilter<"QuoteItem"> | string | null
    vendor_details?: StringNullableFilter<"QuoteItem"> | string | null
    last_updated_by?: IntNullableFilter<"QuoteItem"> | number | null
    work_instructions?: StringNullableFilter<"QuoteItem"> | string | null
    add_vendor?: BoolNullableFilter<"QuoteItem"> | boolean | null
    markings?: StringNullableFilter<"QuoteItem"> | string | null
    part_item_number?: StringNullableFilter<"QuoteItem"> | string | null
    file_year?: StringNullableFilter<"QuoteItem"> | string | null
    file_month?: StringNullableFilter<"QuoteItem"> | string | null
    tab_open?: BoolNullableFilter<"QuoteItem"> | boolean | null
    created_at?: DateTimeFilter<"QuoteItem"> | Date | string
    updated_at?: DateTimeFilter<"QuoteItem"> | Date | string
    deleted_at?: DateTimeNullableFilter<"QuoteItem"> | Date | string | null
  }

  export type QuoteCreateWithoutQuoteItemsInput = {
    id?: string
    quote_item_id?: number
    status?: string | null
    payment_status?: string | null
    quote_type?: $Enums.QuoteType
    tax?: string | null
    deposit_paid?: string | null
    shipping?: string | null
    tax_buy_price?: string | null
    shipping_buy_price?: string | null
    lead_time?: string | null
    payable?: string | null
    freight_condition?: string | null
    freight_condition_dismiss?: boolean | null
    customer_email?: string | null
    emails?: string | null
    invoice_date?: Date | string | null
    invoice_email?: string | null
    billing_name?: string | null
    billing_company?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_country?: string | null
    billing_zip?: string | null
    billing_phone?: string | null
    billing_fax?: string | null
    shipping_name?: string | null
    shipping_company?: string | null
    shipping_address?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_country?: string | null
    shipping_zip?: string | null
    shipping_phone?: string | null
    shipping_email?: string | null
    shipping_fax?: string | null
    sales_person?: number | null
    project_manager?: number | null
    accept_agreement?: number | null
    date_created?: Date | string | null
    created_month?: string | null
    created_year?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    User?: UserCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateWithoutQuoteItemsInput = {
    id?: string
    user_id: string
    quote_item_id?: number
    status?: string | null
    payment_status?: string | null
    quote_type?: $Enums.QuoteType
    tax?: string | null
    deposit_paid?: string | null
    shipping?: string | null
    tax_buy_price?: string | null
    shipping_buy_price?: string | null
    lead_time?: string | null
    payable?: string | null
    freight_condition?: string | null
    freight_condition_dismiss?: boolean | null
    customer_email?: string | null
    emails?: string | null
    invoice_date?: Date | string | null
    invoice_email?: string | null
    billing_name?: string | null
    billing_company?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_country?: string | null
    billing_zip?: string | null
    billing_phone?: string | null
    billing_fax?: string | null
    shipping_name?: string | null
    shipping_company?: string | null
    shipping_address?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_country?: string | null
    shipping_zip?: string | null
    shipping_phone?: string | null
    shipping_email?: string | null
    shipping_fax?: string | null
    sales_person?: number | null
    project_manager?: number | null
    accept_agreement?: number | null
    date_created?: Date | string | null
    created_month?: string | null
    created_year?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
  }

  export type QuoteCreateOrConnectWithoutQuoteItemsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutQuoteItemsInput, QuoteUncheckedCreateWithoutQuoteItemsInput>
  }

  export type QuoteUpsertWithoutQuoteItemsInput = {
    update: XOR<QuoteUpdateWithoutQuoteItemsInput, QuoteUncheckedUpdateWithoutQuoteItemsInput>
    create: XOR<QuoteCreateWithoutQuoteItemsInput, QuoteUncheckedCreateWithoutQuoteItemsInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutQuoteItemsInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutQuoteItemsInput, QuoteUncheckedUpdateWithoutQuoteItemsInput>
  }

  export type QuoteUpdateWithoutQuoteItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    User?: UserUpdateOneWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateWithoutQuoteItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    quote_item_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserCreateWithoutOtpsInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerCreateNestedOneWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    quotes?: QuoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpsInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
  }

  export type UserUpsertWithoutOtpsInput = {
    update: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    quotes?: QuoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutResetTokensInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerCreateNestedOneWithoutUserInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPCreateNestedManyWithoutUserInput
    quotes?: QuoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResetTokensInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
  }

  export type UserUpsertWithoutResetTokensInput = {
    update: XOR<UserUpdateWithoutResetTokensInput, UserUncheckedUpdateWithoutResetTokensInput>
    create: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResetTokensInput, UserUncheckedUpdateWithoutResetTokensInput>
  }

  export type UserUpdateWithoutResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutUserNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUpdateManyWithoutUserNestedInput
    quotes?: QuoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCustomerInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    vendor?: VendorCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    quotes?: QuoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomerInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    vendor?: VendorUncheckedCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressCreateWithoutCustomerInput = {
    id?: string
    billing_address: string
    billing_address2?: string | null
    billing_city: string
    billing_state: string
    billing_zip: string
    billing_country: string
    shipping_address: string
    shipping_address2?: string | null
    shipping_city: string
    shipping_state: string
    shipping_zip: string
    shipping_country: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerAddressUncheckedCreateWithoutCustomerInput = {
    id?: string
    billing_address: string
    billing_address2?: string | null
    billing_city: string
    billing_state: string
    billing_zip: string
    billing_country: string
    shipping_address: string
    shipping_address2?: string | null
    shipping_city: string
    shipping_state: string
    shipping_zip: string
    shipping_country: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerAddressCreateOrConnectWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressCreateManyCustomerInputEnvelope = {
    data: CustomerAddressCreateManyCustomerInput | CustomerAddressCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerTaxInfoCreateWithoutCustomerInput = {
    id?: string
    tax_number?: string | null
    default_tax?: number | null
    currency: string
    payment_terms: string
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerTaxInfoUncheckedCreateWithoutCustomerInput = {
    id?: string
    tax_number?: string | null
    default_tax?: number | null
    currency: string
    payment_terms: string
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerTaxInfoCreateOrConnectWithoutCustomerInput = {
    where: CustomerTaxInfoWhereUniqueInput
    create: XOR<CustomerTaxInfoCreateWithoutCustomerInput, CustomerTaxInfoUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerContactCreateWithoutCustomerInput = {
    id?: string
    customer_name: string
    contact_name?: string | null
    job_title?: string | null
    contact_email?: string | null
    contact_phone?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerContactUncheckedCreateWithoutCustomerInput = {
    id?: string
    customer_name: string
    contact_name?: string | null
    job_title?: string | null
    contact_email?: string | null
    contact_phone?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerContactCreateOrConnectWithoutCustomerInput = {
    where: CustomerContactWhereUniqueInput
    create: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerContactCreateManyCustomerInputEnvelope = {
    data: CustomerContactCreateManyCustomerInput | CustomerContactCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerOperationalInfoCreateWithoutCustomerInput = {
    id?: string
    delivery_method?: string | null
    quote_format?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerOperationalInfoUncheckedCreateWithoutCustomerInput = {
    id?: string
    delivery_method?: string | null
    quote_format?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerOperationalInfoCreateOrConnectWithoutCustomerInput = {
    where: CustomerOperationalInfoWhereUniqueInput
    create: XOR<CustomerOperationalInfoCreateWithoutCustomerInput, CustomerOperationalInfoUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerNotesAndAttachmentsCreateWithoutCustomerInput = {
    id?: string
    internal_notes?: string | null
    tags?: CustomerNotesAndAttachmentsCreatetagsInput | string[]
    file_url?: string | null
    file_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput = {
    id?: string
    internal_notes?: string | null
    tags?: CustomerNotesAndAttachmentsCreatetagsInput | string[]
    file_url?: string | null
    file_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerNotesAndAttachmentsCreateOrConnectWithoutCustomerInput = {
    where: CustomerNotesAndAttachmentsWhereUniqueInput
    create: XOR<CustomerNotesAndAttachmentsCreateWithoutCustomerInput, CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerNotesAndAttachmentsCreateManyCustomerInputEnvelope = {
    data: CustomerNotesAndAttachmentsCreateManyCustomerInput | CustomerNotesAndAttachmentsCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCustomerInput = {
    update: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type UserUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    quotes?: QuoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUncheckedUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    update: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    data: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerAddressScalarWhereInput
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerAddressScalarWhereInput = {
    AND?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    OR?: CustomerAddressScalarWhereInput[]
    NOT?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customer_id?: StringFilter<"CustomerAddress"> | string
    billing_address?: StringFilter<"CustomerAddress"> | string
    billing_address2?: StringNullableFilter<"CustomerAddress"> | string | null
    billing_city?: StringFilter<"CustomerAddress"> | string
    billing_state?: StringFilter<"CustomerAddress"> | string
    billing_zip?: StringFilter<"CustomerAddress"> | string
    billing_country?: StringFilter<"CustomerAddress"> | string
    shipping_address?: StringFilter<"CustomerAddress"> | string
    shipping_address2?: StringNullableFilter<"CustomerAddress"> | string | null
    shipping_city?: StringFilter<"CustomerAddress"> | string
    shipping_state?: StringFilter<"CustomerAddress"> | string
    shipping_zip?: StringFilter<"CustomerAddress"> | string
    shipping_country?: StringFilter<"CustomerAddress"> | string
    is_default?: BoolFilter<"CustomerAddress"> | boolean
    created_at?: DateTimeFilter<"CustomerAddress"> | Date | string
    updated_at?: DateTimeFilter<"CustomerAddress"> | Date | string
  }

  export type CustomerTaxInfoUpsertWithoutCustomerInput = {
    update: XOR<CustomerTaxInfoUpdateWithoutCustomerInput, CustomerTaxInfoUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerTaxInfoCreateWithoutCustomerInput, CustomerTaxInfoUncheckedCreateWithoutCustomerInput>
    where?: CustomerTaxInfoWhereInput
  }

  export type CustomerTaxInfoUpdateToOneWithWhereWithoutCustomerInput = {
    where?: CustomerTaxInfoWhereInput
    data: XOR<CustomerTaxInfoUpdateWithoutCustomerInput, CustomerTaxInfoUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerTaxInfoUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    default_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTaxInfoUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    default_tax?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerContactWhereUniqueInput
    update: XOR<CustomerContactUpdateWithoutCustomerInput, CustomerContactUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerContactCreateWithoutCustomerInput, CustomerContactUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerContactUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerContactWhereUniqueInput
    data: XOR<CustomerContactUpdateWithoutCustomerInput, CustomerContactUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerContactUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerContactScalarWhereInput
    data: XOR<CustomerContactUpdateManyMutationInput, CustomerContactUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerContactScalarWhereInput = {
    AND?: CustomerContactScalarWhereInput | CustomerContactScalarWhereInput[]
    OR?: CustomerContactScalarWhereInput[]
    NOT?: CustomerContactScalarWhereInput | CustomerContactScalarWhereInput[]
    id?: StringFilter<"CustomerContact"> | string
    customer_id?: StringFilter<"CustomerContact"> | string
    customer_name?: StringFilter<"CustomerContact"> | string
    contact_name?: StringNullableFilter<"CustomerContact"> | string | null
    job_title?: StringNullableFilter<"CustomerContact"> | string | null
    contact_email?: StringNullableFilter<"CustomerContact"> | string | null
    contact_phone?: StringNullableFilter<"CustomerContact"> | string | null
    is_primary?: BoolFilter<"CustomerContact"> | boolean
    created_at?: DateTimeFilter<"CustomerContact"> | Date | string
    updated_at?: DateTimeFilter<"CustomerContact"> | Date | string
  }

  export type CustomerOperationalInfoUpsertWithoutCustomerInput = {
    update: XOR<CustomerOperationalInfoUpdateWithoutCustomerInput, CustomerOperationalInfoUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerOperationalInfoCreateWithoutCustomerInput, CustomerOperationalInfoUncheckedCreateWithoutCustomerInput>
    where?: CustomerOperationalInfoWhereInput
  }

  export type CustomerOperationalInfoUpdateToOneWithWhereWithoutCustomerInput = {
    where?: CustomerOperationalInfoWhereInput
    data: XOR<CustomerOperationalInfoUpdateWithoutCustomerInput, CustomerOperationalInfoUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerOperationalInfoUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_method?: NullableStringFieldUpdateOperationsInput | string | null
    quote_format?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerOperationalInfoUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_method?: NullableStringFieldUpdateOperationsInput | string | null
    quote_format?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNotesAndAttachmentsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerNotesAndAttachmentsWhereUniqueInput
    update: XOR<CustomerNotesAndAttachmentsUpdateWithoutCustomerInput, CustomerNotesAndAttachmentsUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerNotesAndAttachmentsCreateWithoutCustomerInput, CustomerNotesAndAttachmentsUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerNotesAndAttachmentsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerNotesAndAttachmentsWhereUniqueInput
    data: XOR<CustomerNotesAndAttachmentsUpdateWithoutCustomerInput, CustomerNotesAndAttachmentsUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerNotesAndAttachmentsUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerNotesAndAttachmentsScalarWhereInput
    data: XOR<CustomerNotesAndAttachmentsUpdateManyMutationInput, CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerNotesAndAttachmentsScalarWhereInput = {
    AND?: CustomerNotesAndAttachmentsScalarWhereInput | CustomerNotesAndAttachmentsScalarWhereInput[]
    OR?: CustomerNotesAndAttachmentsScalarWhereInput[]
    NOT?: CustomerNotesAndAttachmentsScalarWhereInput | CustomerNotesAndAttachmentsScalarWhereInput[]
    id?: StringFilter<"CustomerNotesAndAttachments"> | string
    customer_id?: StringFilter<"CustomerNotesAndAttachments"> | string
    internal_notes?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    tags?: StringNullableListFilter<"CustomerNotesAndAttachments">
    file_url?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    file_name?: StringNullableFilter<"CustomerNotesAndAttachments"> | string | null
    created_at?: DateTimeFilter<"CustomerNotesAndAttachments"> | Date | string
    updated_at?: DateTimeFilter<"CustomerNotesAndAttachments"> | Date | string
  }

  export type companyMaterialCreateWithoutServiceInput = {
    id?: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyMaterialUncheckedCreateWithoutServiceInput = {
    id?: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyMaterialCreateOrConnectWithoutServiceInput = {
    where: companyMaterialWhereUniqueInput
    create: XOR<companyMaterialCreateWithoutServiceInput, companyMaterialUncheckedCreateWithoutServiceInput>
  }

  export type companyMaterialCreateManyServiceInputEnvelope = {
    data: companyMaterialCreateManyServiceInput | companyMaterialCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type companyFinishCreateWithoutServiceInput = {
    id?: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyFinishUncheckedCreateWithoutServiceInput = {
    id?: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyFinishCreateOrConnectWithoutServiceInput = {
    where: companyFinishWhereUniqueInput
    create: XOR<companyFinishCreateWithoutServiceInput, companyFinishUncheckedCreateWithoutServiceInput>
  }

  export type companyFinishCreateManyServiceInputEnvelope = {
    data: companyFinishCreateManyServiceInput | companyFinishCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type companyMaterialUpsertWithWhereUniqueWithoutServiceInput = {
    where: companyMaterialWhereUniqueInput
    update: XOR<companyMaterialUpdateWithoutServiceInput, companyMaterialUncheckedUpdateWithoutServiceInput>
    create: XOR<companyMaterialCreateWithoutServiceInput, companyMaterialUncheckedCreateWithoutServiceInput>
  }

  export type companyMaterialUpdateWithWhereUniqueWithoutServiceInput = {
    where: companyMaterialWhereUniqueInput
    data: XOR<companyMaterialUpdateWithoutServiceInput, companyMaterialUncheckedUpdateWithoutServiceInput>
  }

  export type companyMaterialUpdateManyWithWhereWithoutServiceInput = {
    where: companyMaterialScalarWhereInput
    data: XOR<companyMaterialUpdateManyMutationInput, companyMaterialUncheckedUpdateManyWithoutServiceInput>
  }

  export type companyMaterialScalarWhereInput = {
    AND?: companyMaterialScalarWhereInput | companyMaterialScalarWhereInput[]
    OR?: companyMaterialScalarWhereInput[]
    NOT?: companyMaterialScalarWhereInput | companyMaterialScalarWhereInput[]
    id?: StringFilter<"companyMaterial"> | string
    service_id?: StringFilter<"companyMaterial"> | string
    name?: StringNullableFilter<"companyMaterial"> | string | null
    created_at?: DateTimeFilter<"companyMaterial"> | Date | string
    updated_at?: DateTimeFilter<"companyMaterial"> | Date | string
  }

  export type companyFinishUpsertWithWhereUniqueWithoutServiceInput = {
    where: companyFinishWhereUniqueInput
    update: XOR<companyFinishUpdateWithoutServiceInput, companyFinishUncheckedUpdateWithoutServiceInput>
    create: XOR<companyFinishCreateWithoutServiceInput, companyFinishUncheckedCreateWithoutServiceInput>
  }

  export type companyFinishUpdateWithWhereUniqueWithoutServiceInput = {
    where: companyFinishWhereUniqueInput
    data: XOR<companyFinishUpdateWithoutServiceInput, companyFinishUncheckedUpdateWithoutServiceInput>
  }

  export type companyFinishUpdateManyWithWhereWithoutServiceInput = {
    where: companyFinishScalarWhereInput
    data: XOR<companyFinishUpdateManyMutationInput, companyFinishUncheckedUpdateManyWithoutServiceInput>
  }

  export type companyFinishScalarWhereInput = {
    AND?: companyFinishScalarWhereInput | companyFinishScalarWhereInput[]
    OR?: companyFinishScalarWhereInput[]
    NOT?: companyFinishScalarWhereInput | companyFinishScalarWhereInput[]
    id?: StringFilter<"companyFinish"> | string
    service_id?: StringFilter<"companyFinish"> | string
    name?: StringNullableFilter<"companyFinish"> | string | null
    created_at?: DateTimeFilter<"companyFinish"> | Date | string
    updated_at?: DateTimeFilter<"companyFinish"> | Date | string
  }

  export type companyServiceCreateWithoutMaterialsInput = {
    id?: string
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    finishes?: companyFinishCreateNestedManyWithoutServiceInput
  }

  export type companyServiceUncheckedCreateWithoutMaterialsInput = {
    id?: string
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    finishes?: companyFinishUncheckedCreateNestedManyWithoutServiceInput
  }

  export type companyServiceCreateOrConnectWithoutMaterialsInput = {
    where: companyServiceWhereUniqueInput
    create: XOR<companyServiceCreateWithoutMaterialsInput, companyServiceUncheckedCreateWithoutMaterialsInput>
  }

  export type companyServiceUpsertWithoutMaterialsInput = {
    update: XOR<companyServiceUpdateWithoutMaterialsInput, companyServiceUncheckedUpdateWithoutMaterialsInput>
    create: XOR<companyServiceCreateWithoutMaterialsInput, companyServiceUncheckedCreateWithoutMaterialsInput>
    where?: companyServiceWhereInput
  }

  export type companyServiceUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: companyServiceWhereInput
    data: XOR<companyServiceUpdateWithoutMaterialsInput, companyServiceUncheckedUpdateWithoutMaterialsInput>
  }

  export type companyServiceUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    exclude_inspection?: BoolFieldUpdateOperationsInput | boolean
    invoice50?: BoolFieldUpdateOperationsInput | boolean
    fob_china?: BoolFieldUpdateOperationsInput | boolean
    require_deposit_invoice?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finishes?: companyFinishUpdateManyWithoutServiceNestedInput
  }

  export type companyServiceUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    exclude_inspection?: BoolFieldUpdateOperationsInput | boolean
    invoice50?: BoolFieldUpdateOperationsInput | boolean
    fob_china?: BoolFieldUpdateOperationsInput | boolean
    require_deposit_invoice?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finishes?: companyFinishUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type companyServiceCreateWithoutFinishesInput = {
    id?: string
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    materials?: companyMaterialCreateNestedManyWithoutServiceInput
  }

  export type companyServiceUncheckedCreateWithoutFinishesInput = {
    id?: string
    exclude_inspection?: boolean
    invoice50?: boolean
    fob_china?: boolean
    require_deposit_invoice?: boolean
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    materials?: companyMaterialUncheckedCreateNestedManyWithoutServiceInput
  }

  export type companyServiceCreateOrConnectWithoutFinishesInput = {
    where: companyServiceWhereUniqueInput
    create: XOR<companyServiceCreateWithoutFinishesInput, companyServiceUncheckedCreateWithoutFinishesInput>
  }

  export type companyServiceUpsertWithoutFinishesInput = {
    update: XOR<companyServiceUpdateWithoutFinishesInput, companyServiceUncheckedUpdateWithoutFinishesInput>
    create: XOR<companyServiceCreateWithoutFinishesInput, companyServiceUncheckedCreateWithoutFinishesInput>
    where?: companyServiceWhereInput
  }

  export type companyServiceUpdateToOneWithWhereWithoutFinishesInput = {
    where?: companyServiceWhereInput
    data: XOR<companyServiceUpdateWithoutFinishesInput, companyServiceUncheckedUpdateWithoutFinishesInput>
  }

  export type companyServiceUpdateWithoutFinishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    exclude_inspection?: BoolFieldUpdateOperationsInput | boolean
    invoice50?: BoolFieldUpdateOperationsInput | boolean
    fob_china?: BoolFieldUpdateOperationsInput | boolean
    require_deposit_invoice?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: companyMaterialUpdateManyWithoutServiceNestedInput
  }

  export type companyServiceUncheckedUpdateWithoutFinishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    exclude_inspection?: BoolFieldUpdateOperationsInput | boolean
    invoice50?: BoolFieldUpdateOperationsInput | boolean
    fob_china?: BoolFieldUpdateOperationsInput | boolean
    require_deposit_invoice?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: companyMaterialUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type CustomerCreateWithoutAddressesInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    tax_info?: CustomerTaxInfoCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAddressesInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    tax_info?: CustomerTaxInfoUncheckedCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoUncheckedCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAddressesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
  }

  export type CustomerUpsertWithoutAddressesInput = {
    update: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type CustomerUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_info?: CustomerTaxInfoUncheckedUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUncheckedUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutTax_infoInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTax_infoInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoUncheckedCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTax_infoInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTax_infoInput, CustomerUncheckedCreateWithoutTax_infoInput>
  }

  export type CustomerUpsertWithoutTax_infoInput = {
    update: XOR<CustomerUpdateWithoutTax_infoInput, CustomerUncheckedUpdateWithoutTax_infoInput>
    create: XOR<CustomerCreateWithoutTax_infoInput, CustomerUncheckedCreateWithoutTax_infoInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTax_infoInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTax_infoInput, CustomerUncheckedUpdateWithoutTax_infoInput>
  }

  export type CustomerUpdateWithoutTax_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTax_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUncheckedUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutContactsInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoCreateNestedOneWithoutCustomerInput
    operational?: CustomerOperationalInfoCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutContactsInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoUncheckedCreateNestedOneWithoutCustomerInput
    operational?: CustomerOperationalInfoUncheckedCreateNestedOneWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutContactsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutContactsInput, CustomerUncheckedCreateWithoutContactsInput>
  }

  export type CustomerUpsertWithoutContactsInput = {
    update: XOR<CustomerUpdateWithoutContactsInput, CustomerUncheckedUpdateWithoutContactsInput>
    create: XOR<CustomerCreateWithoutContactsInput, CustomerUncheckedCreateWithoutContactsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutContactsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutContactsInput, CustomerUncheckedUpdateWithoutContactsInput>
  }

  export type CustomerUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUpdateOneWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUncheckedUpdateOneWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUncheckedUpdateOneWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutOperationalInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOperationalInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoUncheckedCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    attachments?: CustomerNotesAndAttachmentsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOperationalInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOperationalInput, CustomerUncheckedCreateWithoutOperationalInput>
  }

  export type CustomerUpsertWithoutOperationalInput = {
    update: XOR<CustomerUpdateWithoutOperationalInput, CustomerUncheckedUpdateWithoutOperationalInput>
    create: XOR<CustomerCreateWithoutOperationalInput, CustomerUncheckedCreateWithoutOperationalInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOperationalInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOperationalInput, CustomerUncheckedUpdateWithoutOperationalInput>
  }

  export type CustomerUpdateWithoutOperationalInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOperationalInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUncheckedUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    attachments?: CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutAttachmentsInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    customer_id?: number
    first_name: string
    last_name: string
    customer_name: string
    company_name?: string | null
    email: string
    password: string
    phone?: string | null
    type?: string | null
    website?: string | null
    is_active?: string
    notes?: string | null
    sorting?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    tax_info?: CustomerTaxInfoUncheckedCreateNestedOneWithoutCustomerInput
    contacts?: CustomerContactUncheckedCreateNestedManyWithoutCustomerInput
    operational?: CustomerOperationalInfoUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAttachmentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAttachmentsInput, CustomerUncheckedCreateWithoutAttachmentsInput>
  }

  export type CustomerUpsertWithoutAttachmentsInput = {
    update: XOR<CustomerUpdateWithoutAttachmentsInput, CustomerUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<CustomerCreateWithoutAttachmentsInput, CustomerUncheckedCreateWithoutAttachmentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAttachmentsInput, CustomerUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CustomerUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sorting?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    tax_info?: CustomerTaxInfoUncheckedUpdateOneWithoutCustomerNestedInput
    contacts?: CustomerContactUncheckedUpdateManyWithoutCustomerNestedInput
    operational?: CustomerOperationalInfoUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type UserCreateWithoutVendorInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    quotes?: QuoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVendorInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    roles: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    otps?: PasswordResetOTPUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVendorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
  }

  export type VendorContactCreateWithoutVendorInput = {
    id?: string
    contact_name: string
    job_title?: string | null
    email?: string | null
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorContactUncheckedCreateWithoutVendorInput = {
    id?: string
    contact_name: string
    job_title?: string | null
    email?: string | null
    phone?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorContactCreateOrConnectWithoutVendorInput = {
    where: VendorContactWhereUniqueInput
    create: XOR<VendorContactCreateWithoutVendorInput, VendorContactUncheckedCreateWithoutVendorInput>
  }

  export type VendorAddressCreateWithoutVendorInput = {
    id?: string
    address_1: string
    address_2?: string | null
    city: string
    state: string
    zip: string
    country: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorAddressUncheckedCreateWithoutVendorInput = {
    id?: string
    address_1: string
    address_2?: string | null
    city: string
    state: string
    zip: string
    country: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorAddressCreateOrConnectWithoutVendorInput = {
    where: VendorAddressWhereUniqueInput
    create: XOR<VendorAddressCreateWithoutVendorInput, VendorAddressUncheckedCreateWithoutVendorInput>
  }

  export type VendorTaxComplianceCreateWithoutVendorInput = {
    id?: string
    tax_number?: string | null
    vat_number?: string | null
    company_number?: string | null
    compliance_type?: string | null
    file_name?: string | null
    file_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorTaxComplianceUncheckedCreateWithoutVendorInput = {
    id?: string
    tax_number?: string | null
    vat_number?: string | null
    company_number?: string | null
    compliance_type?: string | null
    file_name?: string | null
    file_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorTaxComplianceCreateOrConnectWithoutVendorInput = {
    where: VendorTaxComplianceWhereUniqueInput
    create: XOR<VendorTaxComplianceCreateWithoutVendorInput, VendorTaxComplianceUncheckedCreateWithoutVendorInput>
  }

  export type VendorFinancialCreateWithoutVendorInput = {
    id?: string
    bank_name?: string | null
    bank_account_number?: string | null
    swift_iban_code?: string | null
    preferred_currency: string
    payment_terms: string
    default_tax_rate?: string | null
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorFinancialUncheckedCreateWithoutVendorInput = {
    id?: string
    bank_name?: string | null
    bank_account_number?: string | null
    swift_iban_code?: string | null
    preferred_currency: string
    payment_terms: string
    default_tax_rate?: string | null
    credit_limit?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorFinancialCreateOrConnectWithoutVendorInput = {
    where: VendorFinancialWhereUniqueInput
    create: XOR<VendorFinancialCreateWithoutVendorInput, VendorFinancialUncheckedCreateWithoutVendorInput>
  }

  export type VendorOperationalSettingCreateWithoutVendorInput = {
    id?: string
    status?: string | null
    shipping_method?: string | null
    lead_time?: number | null
    minimum_order_quantity?: number | null
    categories?: VendorOperationalSettingCreatecategoriesInput | string[]
    manager: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorOperationalSettingUncheckedCreateWithoutVendorInput = {
    id?: string
    status?: string | null
    shipping_method?: string | null
    lead_time?: number | null
    minimum_order_quantity?: number | null
    categories?: VendorOperationalSettingCreatecategoriesInput | string[]
    manager: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorOperationalSettingCreateOrConnectWithoutVendorInput = {
    where: VendorOperationalSettingWhereUniqueInput
    create: XOR<VendorOperationalSettingCreateWithoutVendorInput, VendorOperationalSettingUncheckedCreateWithoutVendorInput>
  }

  export type VendorMetadataCreateWithoutVendorInput = {
    id?: string
    notes?: string | null
    tags?: VendorMetadataCreatetagsInput | string[]
    score?: number | null
    last_order?: Date | string
    next_review?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorMetadataUncheckedCreateWithoutVendorInput = {
    id?: string
    notes?: string | null
    tags?: VendorMetadataCreatetagsInput | string[]
    score?: number | null
    last_order?: Date | string
    next_review?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorMetadataCreateOrConnectWithoutVendorInput = {
    where: VendorMetadataWhereUniqueInput
    create: XOR<VendorMetadataCreateWithoutVendorInput, VendorMetadataUncheckedCreateWithoutVendorInput>
  }

  export type UserUpsertWithoutVendorInput = {
    update: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
  }

  export type UserUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    quotes?: QuoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    otps?: PasswordResetOTPUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VendorContactUpsertWithoutVendorInput = {
    update: XOR<VendorContactUpdateWithoutVendorInput, VendorContactUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorContactCreateWithoutVendorInput, VendorContactUncheckedCreateWithoutVendorInput>
    where?: VendorContactWhereInput
  }

  export type VendorContactUpdateToOneWithWhereWithoutVendorInput = {
    where?: VendorContactWhereInput
    data: XOR<VendorContactUpdateWithoutVendorInput, VendorContactUncheckedUpdateWithoutVendorInput>
  }

  export type VendorContactUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorContactUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAddressUpsertWithoutVendorInput = {
    update: XOR<VendorAddressUpdateWithoutVendorInput, VendorAddressUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorAddressCreateWithoutVendorInput, VendorAddressUncheckedCreateWithoutVendorInput>
    where?: VendorAddressWhereInput
  }

  export type VendorAddressUpdateToOneWithWhereWithoutVendorInput = {
    where?: VendorAddressWhereInput
    data: XOR<VendorAddressUpdateWithoutVendorInput, VendorAddressUncheckedUpdateWithoutVendorInput>
  }

  export type VendorAddressUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    address_1?: StringFieldUpdateOperationsInput | string
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAddressUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    address_1?: StringFieldUpdateOperationsInput | string
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorTaxComplianceUpsertWithoutVendorInput = {
    update: XOR<VendorTaxComplianceUpdateWithoutVendorInput, VendorTaxComplianceUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorTaxComplianceCreateWithoutVendorInput, VendorTaxComplianceUncheckedCreateWithoutVendorInput>
    where?: VendorTaxComplianceWhereInput
  }

  export type VendorTaxComplianceUpdateToOneWithWhereWithoutVendorInput = {
    where?: VendorTaxComplianceWhereInput
    data: XOR<VendorTaxComplianceUpdateWithoutVendorInput, VendorTaxComplianceUncheckedUpdateWithoutVendorInput>
  }

  export type VendorTaxComplianceUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_number?: NullableStringFieldUpdateOperationsInput | string | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorTaxComplianceUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_number?: NullableStringFieldUpdateOperationsInput | string | null
    vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_number?: NullableStringFieldUpdateOperationsInput | string | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFinancialUpsertWithoutVendorInput = {
    update: XOR<VendorFinancialUpdateWithoutVendorInput, VendorFinancialUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorFinancialCreateWithoutVendorInput, VendorFinancialUncheckedCreateWithoutVendorInput>
    where?: VendorFinancialWhereInput
  }

  export type VendorFinancialUpdateToOneWithWhereWithoutVendorInput = {
    where?: VendorFinancialWhereInput
    data: XOR<VendorFinancialUpdateWithoutVendorInput, VendorFinancialUncheckedUpdateWithoutVendorInput>
  }

  export type VendorFinancialUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    swift_iban_code?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    default_tax_rate?: NullableStringFieldUpdateOperationsInput | string | null
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFinancialUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    swift_iban_code?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_currency?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    default_tax_rate?: NullableStringFieldUpdateOperationsInput | string | null
    credit_limit?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorOperationalSettingUpsertWithoutVendorInput = {
    update: XOR<VendorOperationalSettingUpdateWithoutVendorInput, VendorOperationalSettingUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorOperationalSettingCreateWithoutVendorInput, VendorOperationalSettingUncheckedCreateWithoutVendorInput>
    where?: VendorOperationalSettingWhereInput
  }

  export type VendorOperationalSettingUpdateToOneWithWhereWithoutVendorInput = {
    where?: VendorOperationalSettingWhereInput
    data: XOR<VendorOperationalSettingUpdateWithoutVendorInput, VendorOperationalSettingUncheckedUpdateWithoutVendorInput>
  }

  export type VendorOperationalSettingUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableIntFieldUpdateOperationsInput | number | null
    minimum_order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: VendorOperationalSettingUpdatecategoriesInput | string[]
    manager?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorOperationalSettingUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableIntFieldUpdateOperationsInput | number | null
    minimum_order_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: VendorOperationalSettingUpdatecategoriesInput | string[]
    manager?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorMetadataUpsertWithoutVendorInput = {
    update: XOR<VendorMetadataUpdateWithoutVendorInput, VendorMetadataUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorMetadataCreateWithoutVendorInput, VendorMetadataUncheckedCreateWithoutVendorInput>
    where?: VendorMetadataWhereInput
  }

  export type VendorMetadataUpdateToOneWithWhereWithoutVendorInput = {
    where?: VendorMetadataWhereInput
    data: XOR<VendorMetadataUpdateWithoutVendorInput, VendorMetadataUncheckedUpdateWithoutVendorInput>
  }

  export type VendorMetadataUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VendorMetadataUpdatetagsInput | string[]
    score?: NullableIntFieldUpdateOperationsInput | number | null
    last_order?: DateTimeFieldUpdateOperationsInput | Date | string
    next_review?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorMetadataUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: VendorMetadataUpdatetagsInput | string[]
    score?: NullableIntFieldUpdateOperationsInput | number | null
    last_order?: DateTimeFieldUpdateOperationsInput | Date | string
    next_review?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateWithoutContactsInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutContactsInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    addresses?: VendorAddressUncheckedCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceUncheckedCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialUncheckedCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingUncheckedCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutContactsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutContactsInput, VendorUncheckedCreateWithoutContactsInput>
  }

  export type VendorUpsertWithoutContactsInput = {
    update: XOR<VendorUpdateWithoutContactsInput, VendorUncheckedUpdateWithoutContactsInput>
    create: XOR<VendorCreateWithoutContactsInput, VendorUncheckedCreateWithoutContactsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutContactsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutContactsInput, VendorUncheckedUpdateWithoutContactsInput>
  }

  export type VendorUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: VendorAddressUncheckedUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUncheckedUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUncheckedUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUncheckedUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateWithoutAddressesInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutVendorInput
    contacts?: VendorContactCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutAddressesInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    contacts?: VendorContactUncheckedCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceUncheckedCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialUncheckedCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingUncheckedCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutAddressesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutAddressesInput, VendorUncheckedCreateWithoutAddressesInput>
  }

  export type VendorUpsertWithoutAddressesInput = {
    update: XOR<VendorUpdateWithoutAddressesInput, VendorUncheckedUpdateWithoutAddressesInput>
    create: XOR<VendorCreateWithoutAddressesInput, VendorUncheckedCreateWithoutAddressesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutAddressesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutAddressesInput, VendorUncheckedUpdateWithoutAddressesInput>
  }

  export type VendorUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVendorNestedInput
    contacts?: VendorContactUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: VendorContactUncheckedUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUncheckedUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUncheckedUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUncheckedUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateWithoutTaxCompliancesInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutVendorInput
    contacts?: VendorContactCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutTaxCompliancesInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    contacts?: VendorContactUncheckedCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressUncheckedCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialUncheckedCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingUncheckedCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutTaxCompliancesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutTaxCompliancesInput, VendorUncheckedCreateWithoutTaxCompliancesInput>
  }

  export type VendorUpsertWithoutTaxCompliancesInput = {
    update: XOR<VendorUpdateWithoutTaxCompliancesInput, VendorUncheckedUpdateWithoutTaxCompliancesInput>
    create: XOR<VendorCreateWithoutTaxCompliancesInput, VendorUncheckedCreateWithoutTaxCompliancesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutTaxCompliancesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutTaxCompliancesInput, VendorUncheckedUpdateWithoutTaxCompliancesInput>
  }

  export type VendorUpdateWithoutTaxCompliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVendorNestedInput
    contacts?: VendorContactUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutTaxCompliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: VendorContactUncheckedUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUncheckedUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUncheckedUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUncheckedUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateWithoutFinancialsInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutVendorInput
    contacts?: VendorContactCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutFinancialsInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    contacts?: VendorContactUncheckedCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressUncheckedCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceUncheckedCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingUncheckedCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutFinancialsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutFinancialsInput, VendorUncheckedCreateWithoutFinancialsInput>
  }

  export type VendorUpsertWithoutFinancialsInput = {
    update: XOR<VendorUpdateWithoutFinancialsInput, VendorUncheckedUpdateWithoutFinancialsInput>
    create: XOR<VendorCreateWithoutFinancialsInput, VendorUncheckedCreateWithoutFinancialsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutFinancialsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutFinancialsInput, VendorUncheckedUpdateWithoutFinancialsInput>
  }

  export type VendorUpdateWithoutFinancialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVendorNestedInput
    contacts?: VendorContactUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutFinancialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: VendorContactUncheckedUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUncheckedUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUncheckedUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUncheckedUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateWithoutOperationalSettingInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutVendorInput
    contacts?: VendorContactCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutOperationalSettingInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    contacts?: VendorContactUncheckedCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressUncheckedCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceUncheckedCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialUncheckedCreateNestedOneWithoutVendorInput
    metadata?: VendorMetadataUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutOperationalSettingInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutOperationalSettingInput, VendorUncheckedCreateWithoutOperationalSettingInput>
  }

  export type VendorUpsertWithoutOperationalSettingInput = {
    update: XOR<VendorUpdateWithoutOperationalSettingInput, VendorUncheckedUpdateWithoutOperationalSettingInput>
    create: XOR<VendorCreateWithoutOperationalSettingInput, VendorUncheckedCreateWithoutOperationalSettingInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutOperationalSettingInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutOperationalSettingInput, VendorUncheckedUpdateWithoutOperationalSettingInput>
  }

  export type VendorUpdateWithoutOperationalSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVendorNestedInput
    contacts?: VendorContactUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutOperationalSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: VendorContactUncheckedUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUncheckedUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUncheckedUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUncheckedUpdateOneWithoutVendorNestedInput
    metadata?: VendorMetadataUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type VendorCreateWithoutMetadataInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user?: UserCreateNestedOneWithoutVendorInput
    contacts?: VendorContactCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingCreateNestedOneWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutMetadataInput = {
    id?: string
    vendor_id?: number
    first_name: string
    last_name: string
    vendor_name: string
    vendor_type?: string | null
    email?: string | null
    password: string
    phone?: string | null
    website?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user_id?: string | null
    contacts?: VendorContactUncheckedCreateNestedOneWithoutVendorInput
    addresses?: VendorAddressUncheckedCreateNestedOneWithoutVendorInput
    taxCompliances?: VendorTaxComplianceUncheckedCreateNestedOneWithoutVendorInput
    financials?: VendorFinancialUncheckedCreateNestedOneWithoutVendorInput
    operationalSetting?: VendorOperationalSettingUncheckedCreateNestedOneWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutMetadataInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutMetadataInput, VendorUncheckedCreateWithoutMetadataInput>
  }

  export type VendorUpsertWithoutMetadataInput = {
    update: XOR<VendorUpdateWithoutMetadataInput, VendorUncheckedUpdateWithoutMetadataInput>
    create: XOR<VendorCreateWithoutMetadataInput, VendorUncheckedCreateWithoutMetadataInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutMetadataInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutMetadataInput, VendorUncheckedUpdateWithoutMetadataInput>
  }

  export type VendorUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVendorNestedInput
    contacts?: VendorContactUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUpdateOneWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    vendor_name?: StringFieldUpdateOperationsInput | string
    vendor_type?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    contacts?: VendorContactUncheckedUpdateOneWithoutVendorNestedInput
    addresses?: VendorAddressUncheckedUpdateOneWithoutVendorNestedInput
    taxCompliances?: VendorTaxComplianceUncheckedUpdateOneWithoutVendorNestedInput
    financials?: VendorFinancialUncheckedUpdateOneWithoutVendorNestedInput
    operationalSetting?: VendorOperationalSettingUncheckedUpdateOneWithoutVendorNestedInput
  }

  export type company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_capability_sub_categoriesCreateOrConnectWithoutCapabilityInput = {
    where: company_vendor_capability_sub_categoriesWhereUniqueInput
    create: XOR<company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput, company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput>
  }

  export type company_vendor_capability_sub_categoriesCreateManyCapabilityInputEnvelope = {
    data: company_vendor_capability_sub_categoriesCreateManyCapabilityInput | company_vendor_capability_sub_categoriesCreateManyCapabilityInput[]
    skipDuplicates?: boolean
  }

  export type company_vendor_capability_sub_categoriesUpsertWithWhereUniqueWithoutCapabilityInput = {
    where: company_vendor_capability_sub_categoriesWhereUniqueInput
    update: XOR<company_vendor_capability_sub_categoriesUpdateWithoutCapabilityInput, company_vendor_capability_sub_categoriesUncheckedUpdateWithoutCapabilityInput>
    create: XOR<company_vendor_capability_sub_categoriesCreateWithoutCapabilityInput, company_vendor_capability_sub_categoriesUncheckedCreateWithoutCapabilityInput>
  }

  export type company_vendor_capability_sub_categoriesUpdateWithWhereUniqueWithoutCapabilityInput = {
    where: company_vendor_capability_sub_categoriesWhereUniqueInput
    data: XOR<company_vendor_capability_sub_categoriesUpdateWithoutCapabilityInput, company_vendor_capability_sub_categoriesUncheckedUpdateWithoutCapabilityInput>
  }

  export type company_vendor_capability_sub_categoriesUpdateManyWithWhereWithoutCapabilityInput = {
    where: company_vendor_capability_sub_categoriesScalarWhereInput
    data: XOR<company_vendor_capability_sub_categoriesUpdateManyMutationInput, company_vendor_capability_sub_categoriesUncheckedUpdateManyWithoutCapabilityInput>
  }

  export type company_vendor_capability_sub_categoriesScalarWhereInput = {
    AND?: company_vendor_capability_sub_categoriesScalarWhereInput | company_vendor_capability_sub_categoriesScalarWhereInput[]
    OR?: company_vendor_capability_sub_categoriesScalarWhereInput[]
    NOT?: company_vendor_capability_sub_categoriesScalarWhereInput | company_vendor_capability_sub_categoriesScalarWhereInput[]
    id?: StringFilter<"company_vendor_capability_sub_categories"> | string
    name?: StringFilter<"company_vendor_capability_sub_categories"> | string
    vendor_capability_id?: StringFilter<"company_vendor_capability_sub_categories"> | string
    is_active?: BoolFilter<"company_vendor_capability_sub_categories"> | boolean
    created_at?: DateTimeFilter<"company_vendor_capability_sub_categories"> | Date | string
    updated_at?: DateTimeFilter<"company_vendor_capability_sub_categories"> | Date | string
  }

  export type company_vendor_capabilitiesCreateWithoutSubCategoriesInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_capabilitiesUncheckedCreateWithoutSubCategoriesInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_capabilitiesCreateOrConnectWithoutSubCategoriesInput = {
    where: company_vendor_capabilitiesWhereUniqueInput
    create: XOR<company_vendor_capabilitiesCreateWithoutSubCategoriesInput, company_vendor_capabilitiesUncheckedCreateWithoutSubCategoriesInput>
  }

  export type company_vendor_capabilitiesUpsertWithoutSubCategoriesInput = {
    update: XOR<company_vendor_capabilitiesUpdateWithoutSubCategoriesInput, company_vendor_capabilitiesUncheckedUpdateWithoutSubCategoriesInput>
    create: XOR<company_vendor_capabilitiesCreateWithoutSubCategoriesInput, company_vendor_capabilitiesUncheckedCreateWithoutSubCategoriesInput>
    where?: company_vendor_capabilitiesWhereInput
  }

  export type company_vendor_capabilitiesUpdateToOneWithWhereWithoutSubCategoriesInput = {
    where?: company_vendor_capabilitiesWhereInput
    data: XOR<company_vendor_capabilitiesUpdateWithoutSubCategoriesInput, company_vendor_capabilitiesUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type company_vendor_capabilitiesUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capabilitiesUncheckedUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetOTPCreateManyUserInput = {
    id?: string
    email: string
    otp: string
    request_id: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type QuoteCreateManyUserInput = {
    id?: string
    quote_item_id?: number
    status?: string | null
    payment_status?: string | null
    quote_type?: $Enums.QuoteType
    tax?: string | null
    deposit_paid?: string | null
    shipping?: string | null
    tax_buy_price?: string | null
    shipping_buy_price?: string | null
    lead_time?: string | null
    payable?: string | null
    freight_condition?: string | null
    freight_condition_dismiss?: boolean | null
    customer_email?: string | null
    emails?: string | null
    invoice_date?: Date | string | null
    invoice_email?: string | null
    billing_name?: string | null
    billing_company?: string | null
    billing_address?: string | null
    billing_city?: string | null
    billing_state?: string | null
    billing_country?: string | null
    billing_zip?: string | null
    billing_phone?: string | null
    billing_fax?: string | null
    shipping_name?: string | null
    shipping_company?: string | null
    shipping_address?: string | null
    shipping_city?: string | null
    shipping_state?: string | null
    shipping_country?: string | null
    shipping_zip?: string | null
    shipping_phone?: string | null
    shipping_email?: string | null
    shipping_fax?: string | null
    sales_person?: number | null
    project_manager?: number | null
    accept_agreement?: number | null
    date_created?: Date | string | null
    created_month?: string | null
    created_year?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
  }

  export type PasswordResetOTPUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetOTPUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetOTPUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    QuoteItems?: QuoteItemUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_item_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    QuoteItems?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote_item_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_type?: EnumQuoteTypeFieldUpdateOperationsInput | $Enums.QuoteType
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    deposit_paid?: NullableStringFieldUpdateOperationsInput | string | null
    shipping?: NullableStringFieldUpdateOperationsInput | string | null
    tax_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    lead_time?: NullableStringFieldUpdateOperationsInput | string | null
    payable?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition?: NullableStringFieldUpdateOperationsInput | string | null
    freight_condition_dismiss?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_email?: NullableStringFieldUpdateOperationsInput | string | null
    billing_name?: NullableStringFieldUpdateOperationsInput | string | null
    billing_company?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: NullableStringFieldUpdateOperationsInput | string | null
    billing_state?: NullableStringFieldUpdateOperationsInput | string | null
    billing_country?: NullableStringFieldUpdateOperationsInput | string | null
    billing_zip?: NullableStringFieldUpdateOperationsInput | string | null
    billing_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_fax?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_name?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_company?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_state?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_country?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_zip?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_phone?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_fax?: NullableStringFieldUpdateOperationsInput | string | null
    sales_person?: NullableIntFieldUpdateOperationsInput | number | null
    project_manager?: NullableIntFieldUpdateOperationsInput | number | null
    accept_agreement?: NullableIntFieldUpdateOperationsInput | number | null
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_month?: NullableStringFieldUpdateOperationsInput | string | null
    created_year?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QuoteItemCreateManyQuoteInput = {
    id?: string
    file_name?: string | null
    file_url?: string | null
    status?: boolean
    quantity?: number
    service?: string | null
    material?: string | null
    finish?: string | null
    description?: string | null
    process?: string | null
    specification?: string | null
    price?: string | null
    cost?: string | null
    cost_shipping_price?: string | null
    cost_shipping_total?: string | null
    custom_shipping_total?: string | null
    buy_price?: string | null
    buy_shipping_price?: string | null
    buy_shipping_total?: string | null
    quantity_owed?: string | null
    invoiced?: boolean | null
    non_taxable?: number | null
    non_shipping?: number | null
    is_deleted?: boolean | null
    vendor_id?: string | null
    vendor_details?: string | null
    last_updated_by?: number | null
    work_instructions?: string | null
    add_vendor?: boolean | null
    markings?: string | null
    part_item_number?: string | null
    file_year?: string | null
    file_month?: string | null
    tab_open?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type QuoteItemUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    service?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    custom_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_owed?: NullableStringFieldUpdateOperationsInput | string | null
    invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    non_taxable?: NullableIntFieldUpdateOperationsInput | number | null
    non_shipping?: NullableIntFieldUpdateOperationsInput | number | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_details?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    work_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    add_vendor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    markings?: NullableStringFieldUpdateOperationsInput | string | null
    part_item_number?: NullableStringFieldUpdateOperationsInput | string | null
    file_year?: NullableStringFieldUpdateOperationsInput | string | null
    file_month?: NullableStringFieldUpdateOperationsInput | string | null
    tab_open?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteItemUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    service?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    custom_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_owed?: NullableStringFieldUpdateOperationsInput | string | null
    invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    non_taxable?: NullableIntFieldUpdateOperationsInput | number | null
    non_shipping?: NullableIntFieldUpdateOperationsInput | number | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_details?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    work_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    add_vendor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    markings?: NullableStringFieldUpdateOperationsInput | string | null
    part_item_number?: NullableStringFieldUpdateOperationsInput | string | null
    file_year?: NullableStringFieldUpdateOperationsInput | string | null
    file_month?: NullableStringFieldUpdateOperationsInput | string | null
    tab_open?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteItemUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    service?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    cost_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    custom_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    buy_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_price?: NullableStringFieldUpdateOperationsInput | string | null
    buy_shipping_total?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_owed?: NullableStringFieldUpdateOperationsInput | string | null
    invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    non_taxable?: NullableIntFieldUpdateOperationsInput | number | null
    non_shipping?: NullableIntFieldUpdateOperationsInput | number | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_details?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    work_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    add_vendor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    markings?: NullableStringFieldUpdateOperationsInput | string | null
    part_item_number?: NullableStringFieldUpdateOperationsInput | string | null
    file_year?: NullableStringFieldUpdateOperationsInput | string | null
    file_month?: NullableStringFieldUpdateOperationsInput | string | null
    tab_open?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressCreateManyCustomerInput = {
    id?: string
    billing_address: string
    billing_address2?: string | null
    billing_city: string
    billing_state: string
    billing_zip: string
    billing_country: string
    shipping_address: string
    shipping_address2?: string | null
    shipping_city: string
    shipping_state: string
    shipping_zip: string
    shipping_country: string
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerContactCreateManyCustomerInput = {
    id?: string
    customer_name: string
    contact_name?: string | null
    job_title?: string | null
    contact_email?: string | null
    contact_phone?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerNotesAndAttachmentsCreateManyCustomerInput = {
    id?: string
    internal_notes?: string | null
    tags?: CustomerNotesAndAttachmentsCreatetagsInput | string[]
    file_url?: string | null
    file_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerAddressUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_address?: StringFieldUpdateOperationsInput | string
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: StringFieldUpdateOperationsInput | string
    billing_state?: StringFieldUpdateOperationsInput | string
    billing_zip?: StringFieldUpdateOperationsInput | string
    billing_country?: StringFieldUpdateOperationsInput | string
    shipping_address?: StringFieldUpdateOperationsInput | string
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_zip?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_address?: StringFieldUpdateOperationsInput | string
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: StringFieldUpdateOperationsInput | string
    billing_state?: StringFieldUpdateOperationsInput | string
    billing_zip?: StringFieldUpdateOperationsInput | string
    billing_country?: StringFieldUpdateOperationsInput | string
    shipping_address?: StringFieldUpdateOperationsInput | string
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_zip?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_address?: StringFieldUpdateOperationsInput | string
    billing_address2?: NullableStringFieldUpdateOperationsInput | string | null
    billing_city?: StringFieldUpdateOperationsInput | string
    billing_state?: StringFieldUpdateOperationsInput | string
    billing_zip?: StringFieldUpdateOperationsInput | string
    billing_country?: StringFieldUpdateOperationsInput | string
    shipping_address?: StringFieldUpdateOperationsInput | string
    shipping_address2?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_zip?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerContactUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNotesAndAttachmentsUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerNotesAndAttachmentsUpdatetagsInput | string[]
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNotesAndAttachmentsUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerNotesAndAttachmentsUpdatetagsInput | string[]
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNotesAndAttachmentsUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerNotesAndAttachmentsUpdatetagsInput | string[]
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyMaterialCreateManyServiceInput = {
    id?: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyFinishCreateManyServiceInput = {
    id?: string
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyMaterialUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyMaterialUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyMaterialUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyFinishUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyFinishUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyFinishUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capability_sub_categoriesCreateManyCapabilityInput = {
    id?: string
    name: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_vendor_capability_sub_categoriesUpdateWithoutCapabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capability_sub_categoriesUncheckedUpdateWithoutCapabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_vendor_capability_sub_categoriesUncheckedUpdateManyWithoutCapabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}